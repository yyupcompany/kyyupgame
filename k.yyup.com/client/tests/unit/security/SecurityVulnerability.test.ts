
vi.mock('@/components/security/SecurityVulnerability.vue', () => ({
  default: {
    name: 'SecurityVulnerability',
    template: '<div>Mocked security/SecurityVulnerability</div>'
  }
}))

import { 
// 控制台错误检测
let consoleSpy: any

beforeEach(() => {
  // 监听控制台错误
  consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {})
})

afterEach(() => {
  // 验证没有控制台错误
  expect(consoleSpy).not.toHaveBeenCalled()
  consoleSpy.mockRestore()
})

describe, it, expect, beforeEach, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import { createPinia, setActivePinia } from 'pinia';
import SecurityVulnerability from '@/components/security/SecurityVulnerability.vue';
import { useSecurityStore } from '@/stores/security';
import { useAuthStore } from '@/stores/auth';
import axios from 'axios';

// Mock axios
vi.mock('axios');
const mockedAxios = axios as any;

describe('SecurityVulnerability', () => {
  let wrapper: any;
  let securityStore: any;
  let authStore: any;

  beforeEach(() => {
    vi.clearAllMocks();
    setActivePinia(createPinia());
    securityStore = useSecurityStore();
    authStore = useAuthStore();

    // Mock auth store with admin user
    authStore.user = {
      id: 1,
      username: 'admin',
      role: 'admin',
      permissions: ['security:read', 'security:write', 'security:manage']
    };

    // Mock security store data
    securityStore.vulnerabilities = [];
    securityStore.scanResults = null;
    securityStore.securityMetrics = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      total: 0
    };

    wrapper = mount(SecurityVulnerability, {
      global: {
        stubs: ['el-card', 'el-table', 'el-button', 'el-tag', 'el-dialog', 'el-form', 'el-form-item', 'el-input', 'el-select', 'el-option'],
        plugins: []
      }
    });
  });

  describe('SQL Injection Detection', () => {
    it('should detect SQL injection attempts in user input', async () => {
      const maliciousInputs = [
        "1' OR '1'='1",
        "1; DROP TABLE users; --",
        "1' UNION SELECT username, password FROM users--",
        "admin'--",
        "' OR 1=1--",
        "1' AND 1=1 UNION SELECT NULL, version()--"
      ];

      for (const input of maliciousInputs) {
        const isMalicious = await wrapper.vm.detectSqlInjection(input);
        expect(isMalicious).toBe(true);
      }
    });

    it('should allow legitimate SQL queries', async () => {
      const legitimateInputs = [
        "SELECT * FROM users WHERE id = 1",
        "INSERT INTO users (name, email) VALUES ('John', 'john@example.com')",
        "UPDATE users SET name = 'Jane' WHERE id = 1",
        "DELETE FROM users WHERE id = 1"
      ];

      for (const input of legitimateInputs) {
        const isMalicious = await wrapper.vm.detectSqlInjection(input);
        expect(isMalicious).toBe(false);
      }
    });

    it('should sanitize SQL input parameters', async () => {
      const maliciousParam = "1' OR '1'='1";
      const sanitized = await wrapper.vm.sanitizeSqlInput(maliciousParam);
      expect(sanitized).not.toContain("'");
      expect(sanitized).not.toContain("OR");
      expect(sanitized).not.toContain("=");
    });
  });

  describe('Cross-Site Scripting (XSS) Detection', () => {
    it('should detect XSS attempts in user input', async () => {
      const maliciousInputs = [
        "<script>alert('XSS')</script>",
        "javascript:alert('XSS')",
        "<img src='x' onerror='alert(1)'>",
        "<svg onload='alert(1)'>",
        "<iframe src='javascript:alert(1)'>",
        "<body onload='alert(1)'>",
        "';alert(String.fromCharCode(88,83,83));//",
        "<scr<script>ipt>alert('XSS')</scr<script>ipt>"
      ];

      for (const input of maliciousInputs) {
        const isMalicious = await wrapper.vm.detectXSS(input);
        expect(isMalicious).toBe(true);
      }
    });

    it('should allow legitimate HTML content', async () => {
      const legitimateInputs = [
        "<p>This is a paragraph</p>",
        "<div>Normal content</div>",
        "<span>Text content</span>",
        "<h1>Heading</h1>",
        "<ul><li>List item</li></ul>"
      ];

      for (const input of legitimateInputs) {
        const isMalicious = await wrapper.vm.detectXSS(input);
        expect(isMalicious).toBe(false);
      }
    });

    it('should sanitize HTML input to prevent XSS', async () => {
      const maliciousHtml = "<script>alert('XSS')</script><p>Valid content</p>";
      const sanitized = await wrapper.vm.sanitizeHtmlInput(maliciousHtml);
      expect(sanitized).not.toContain('<script>');
      expect(sanitized).toContain('<p>Valid content</p>');
    });
  });

  describe('Cross-Site Request Forgery (CSRF) Protection', () => {
    it('should validate CSRF tokens for POST requests', async () => {
      const mockCsrfToken = 'valid-csrf-token';
      securityStore.csrfToken = mockCsrfToken;

      const requestData = {
        username: 'testuser',
        email: 'test@example.com'
      };

      const isValid = await wrapper.vm.validateCsrfToken(requestData, mockCsrfToken);
      expect(isValid).toBe(true);
    });

    it('should reject requests without CSRF tokens', async () => {
      const requestData = {
        username: 'testuser',
        email: 'test@example.com'
      };

      const isValid = await wrapper.vm.validateCsrfToken(requestData, '');
      expect(isValid).toBe(false);
    });

    it('should reject requests with invalid CSRF tokens', async () => {
      const requestData = {
        username: 'testuser',
        email: 'test@example.com'
      };

      const isValid = await wrapper.vm.validateCsrfToken(requestData, 'invalid-token');
      expect(isValid).toBe(false);
    });

    it('should generate new CSRF tokens for sensitive operations', async () => {
      const newToken = await wrapper.vm.generateCsrfToken();
      expect(newToken).toBeDefined();
      expect(newToken.length).toBeGreaterThan(0);
      expect(typeof newToken).toBe('string');
    });
  });

  describe('Authentication Bypass Detection', () => {
    it('should detect session hijacking attempts', async () => {
      const suspiciousSessionData = {
        userId: 1,
        sessionId: 'suspicious-session-id',
        ipAddress: '192.168.1.100',
        userAgent: 'Malicious Bot'
      };

      const isSuspicious = await wrapper.vm.detectSessionHijacking(suspiciousSessionData);
      expect(isSuspicious).toBe(true);
    });

    it('should detect brute force login attempts', async () => {
      const loginAttempts = [
        { username: 'admin', password: 'wrong1', timestamp: Date.now() - 1000 },
        { username: 'admin', password: 'wrong2', timestamp: Date.now() - 2000 },
        { username: 'admin', password: 'wrong3', timestamp: Date.now() - 3000 },
        { username: 'admin', password: 'wrong4', timestamp: Date.now() - 4000 },
        { username: 'admin', password: 'wrong5', timestamp: Date.now() - 5000 }
      ];

      const isBruteForce = await wrapper.vm.detectBruteForce(loginAttempts);
      expect(isBruteForce).toBe(true);
    });

    it('should implement rate limiting for authentication', async () => {
      const ipAddress = '192.168.1.100';
      
      // Simulate multiple rapid requests
      for (let i = 0; i < 6; i++) {
        const isAllowed = await wrapper.vm.checkRateLimit(ipAddress);
        if (i >= 5) {
          expect(isAllowed).toBe(false);
        } else {
          expect(isAllowed).toBe(true);
        }
      }
    });

    it('should validate JWT token integrity', async () => {
      const validToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c';
      const invalidToken = 'invalid.token.here';

      const isValid = await wrapper.vm.validateJwtToken(validToken);
      expect(isValid).toBe(true);

      const isInvalid = await wrapper.vm.validateJwtToken(invalidToken);
      expect(isInvalid).toBe(false);
    });
  });

  describe('Input Validation Security', () => {
    it('should validate email format to prevent email injection', async () => {
      const validEmails = [
        'user@example.com',
        'user.name@example.com',
        'user+tag@example.com',
        'user@sub.example.com'
      ];

      const invalidEmails = [
        'user@example.com<script>alert(1)</script>',
        'user@example.com; ls -la',
        'user@example.com|cat /etc/passwd',
        'user@example.com$(cat /etc/passwd)'
      ];

      for (const email of validEmails) {
        const isValid = await wrapper.vm.validateEmail(email);
        expect(isValid).toBe(true);
      }

      for (const email of invalidEmails) {
        const isValid = await wrapper.vm.validateEmail(email);
        expect(isValid).toBe(false);
      }
    });

    it('should validate phone number format', async () => {
      const validPhones = [
        '13800138000',
        '+8613800138000',
        '021-12345678',
        '0755-12345678'
      ];

      const invalidPhones = [
        '123456', // Too short
        'abcdefghij', // Contains letters
        '13800138000<script>alert(1)</script>',
        '13800138000; rm -rf /'
      ];

      for (const phone of validPhones) {
        const isValid = await wrapper.vm.validatePhone(phone);
        expect(isValid).toBe(true);
      }

      for (const phone of invalidPhones) {
        const isValid = await wrapper.vm.validatePhone(phone);
        expect(isValid).toBe(false);
      }
    });

    it('should sanitize file upload names', async () => {
      const maliciousFilenames = [
        '../../../etc/passwd',
        'file.php;.jpg',
        'file.php%00.jpg',
        'CON', // Windows reserved name
        'AUX', // Windows reserved name
        'file<script>.jpg'
      ];

      for (const filename of maliciousFilenames) {
        const sanitized = await wrapper.vm.sanitizeFilename(filename);
        expect(sanitized).not.toContain('..');
        expect(sanitized).not.toContain(';');
        expect(sanitized).not.toContain('<script>');
        expect(sanitized).not.toBe('CON');
        expect(sanitized).not.toBe('AUX');
      }
    });
  });

  describe('API Security Testing', () => {
    it('should validate API request headers', async () => {
      const validHeaders = {
        'Content-Type': 'application/json',
        'X-Requested-With': 'XMLHttpRequest',
        'Authorization': 'Bearer valid-token'
      };

      const invalidHeaders = {
        'Content-Type': 'text/html',
        'X-Requested-With': 'Malicious'
      };

      const isValid = await wrapper.vm.validateApiHeaders(validHeaders);
      expect(isValid).toBe(true);

      const isInvalid = await wrapper.vm.validateApiHeaders(invalidHeaders);
      expect(isInvalid).toBe(false);
    });

    it('should detect API parameter tampering', async () => {
      const requestParams = {
        userId: 1,
        amount: 100,
        timestamp: Date.now()
      };

      const tamperedParams = {
        ...requestParams,
        userId: 2, // Tampered user ID
        amount: 10000 // Tampered amount
      };

      const isTampered = await wrapper.vm.detectParameterTampering(tamperedParams, requestParams);
      expect(isTampered).toBe(true);
    });

    it('should implement API rate limiting', async () => {
      const clientId = 'test-client';
      
      // Simulate API calls
      for (let i = 0; i < 101; i++) {
        const isAllowed = await wrapper.vm.checkApiRateLimit(clientId);
        if (i >= 100) {
          expect(isAllowed).toBe(false);
        } else {
          expect(isAllowed).toBe(true);
        }
      }
    });
  });

  describe('Security Scan Integration', () => {
    it('should perform comprehensive security scan', async () => {
      const scanConfig = {
        scanSqlInjection: true,
        scanXss: true,
        scanCsrf: true,
        scanAuthBypass: true,
        scanInputValidation: true,
        scanApiSecurity: true
      };

      mockedAxios.post.mockResolvedValue({
        data: {
          success: true,
          results: {
            vulnerabilities: [
              { type: 'SQL_INJECTION', severity: 'high', description: 'Potential SQL injection found' },
              { type: 'XSS', severity: 'medium', description: 'XSS vulnerability detected' }
            ],
            score: 75,
            recommendations: [
              'Implement input validation',
              'Use parameterized queries',
              'Add CSRF protection'
            ]
          }
        }
      });

      const scanResults = await wrapper.vm.performSecurityScan(scanConfig);
      expect(scanResults.success).toBe(true);
      expect(scanResults.results.vulnerabilities.length).toBeGreaterThan(0);
      expect(scanResults.results.score).toBeGreaterThan(0);
      expect(scanResults.results.recommendations.length).toBeGreaterThan(0);
    });

    it('should handle security scan failures gracefully', async () => {
      const scanConfig = {
        scanSqlInjection: true,
        scanXss: true
      };

      mockedAxios.post.mockRejectedValue(new Error('Scan failed'));

      const scanResults = await wrapper.vm.performSecurityScan(scanConfig);
      expect(scanResults.success).toBe(false);
      expect(scanResults.error).toBeDefined();
    });

    it('should generate security vulnerability report', async () => {
      const vulnerabilities = [
        { type: 'SQL_INJECTION', severity: 'critical', affected: 'login.php' },
        { type: 'XSS', severity: 'high', affected: 'profile.php' },
        { type: 'CSRF', severity: 'medium', affected: 'settings.php' }
      ];

      const report = await wrapper.vm.generateSecurityReport(vulnerabilities);
      expect(report.title).toBe('Security Vulnerability Report');
      expect(report.vulnerabilities.length).toBe(3);
      expect(report.summary.critical).toBe(1);
      expect(report.summary.high).toBe(1);
      expect(report.summary.medium).toBe(1);
    });
  });

  describe('Security Metrics and Monitoring', () => {
    it('should calculate security risk score', async () => {
      const vulnerabilities = [
        { severity: 'critical', count: 2 },
        { severity: 'high', count: 5 },
        { severity: 'medium', count: 10 },
        { severity: 'low', count: 15 }
      ];

      const riskScore = await wrapper.vm.calculateRiskScore(vulnerabilities);
      expect(riskScore).toBeGreaterThan(0);
      expect(riskScore).toBeLessThanOrEqual(100);
    });

    it('should track security incidents', async () => {
      const incident = {
        type: 'SQL_INJECTION_ATTEMPT',
        severity: 'high',
        timestamp: Date.now(),
        ipAddress: '192.168.1.100',
        details: 'SQL injection attempt detected in login form'
      };

      await wrapper.vm.trackSecurityIncident(incident);
      expect(securityStore.incidents.length).toBeGreaterThan(0);
      expect(securityStore.incidents[0].type).toBe('SQL_INJECTION_ATTEMPT');
    });

    it('should generate security alerts for critical vulnerabilities', async () => {
      const criticalVulnerability = {
        type: 'REMOTE_CODE_EXECUTION',
        severity: 'critical',
        description: 'Remote code execution vulnerability found'
      };

      await wrapper.vm.generateSecurityAlert(criticalVulnerability);
      expect(securityStore.alerts.length).toBeGreaterThan(0);
      expect(securityStore.alerts[0].severity).toBe('critical');
    });
  });

  describe('Performance and Load Testing for Security', () => {
    it('should handle security checks under load', async () => {
      const startTime = Date.now();
      const concurrentRequests = 50;

      const promises = Array(concurrentRequests).fill(0).map(() => 
        wrapper.vm.detectSqlInjection("1' OR '1'='1")
      );

      const results = await Promise.all(promises);
      const endTime = Date.now();

      expect(results.every(result => result === true)).toBe(true);
      expect(endTime - startTime).toBeLessThan(5000); // Should complete within 5 seconds
    });

    it('should maintain security validation performance with large datasets', async () => {
      const largeDataset = Array(1000).fill(0).map((_, i) => ({
        input: `test${i}`,
        expected: false
      }));

      const startTime = Date.now();
      const results = await Promise.all(
        largeDataset.map(item => wrapper.vm.detectXSS(item.input))
      );
      const endTime = Date.now();

      expect(results.length).toBe(1000);
      expect(endTime - startTime).toBeLessThan(3000); // Should complete within 3 seconds
    });
  });

  describe('Error Handling and Logging', () => {
    it('should log security-related errors properly', async () => {
      const error = new Error('Security validation failed');
      
      await wrapper.vm.logSecurityError(error);
      expect(securityStore.errorLogs.length).toBeGreaterThan(0);
      expect(securityStore.errorLogs[0].message).toBe('Security validation failed');
    });

    it('should handle malformed input gracefully', async () => {
      const malformedInputs = [
        null,
        undefined,
        '',
        {},
        [],
        123,
        true,
        false
      ];

      for (const input of malformedInputs) {
        const result = await wrapper.vm.detectSqlInjection(input);
        expect(result).toBe(false); // Should not crash, return false for invalid input
      }
    });

    it('should provide meaningful error messages for security failures', async () => {
      try {
        await wrapper.vm.performSecurityScan(null);
      } catch (error) {
        expect(error.message).toContain('Invalid scan configuration');
      }
    });
  });
});