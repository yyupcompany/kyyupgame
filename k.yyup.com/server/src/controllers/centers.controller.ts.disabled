/**
 * ğŸ¢ ä¸­å¿ƒç®¡ç†æ§åˆ¶å™¨ - æ€§èƒ½ä¼˜åŒ–ç‰ˆæœ¬
 * é›†åˆAPIï¼Œå‡å°‘å¤šæ¬¡è°ƒç”¨ï¼Œæå‡é¡µé¢åŠ è½½æ€§èƒ½
 */

import { Request, Response } from 'express';
import { Op } from 'sequelize';
import {
  User,
  Role,
  Permission,
  SystemLog,
  Activity,
  PaymentBill,
  PaymentRecord,
  Todo,
  Notification,
  Schedule,
  Teacher,
  Student,
  Class,
  ActivityRegistration,
  AssessmentConfig,
  AssessmentQuestion,
  AssessmentRecord
} from '../models';

export class CentersController {
  /**
   * ğŸ¯ ç³»ç»Ÿä¸­å¿ƒæ¦‚è§ˆ - é›†åˆAPI
   * æ›¿ä»£åŸæ¥çš„5ä¸ªç‹¬ç«‹APIè°ƒç”¨
   * è·¯ç”±: GET /api/centers/system/overview
   */
  static async getSystemOverview(req: Request, res: Response) {
    try {
      console.time('system-overview-api');

      // å¹¶è¡Œè·å–æ‰€æœ‰ç³»ç»Ÿæ•°æ®
      const [
        statistics,
        configs,
        security,
        performance,
        userActivity
      ] = await Promise.all([
        CentersController.getSystemStatistics(),
        CentersController.getSystemConfigs(),
        CentersController.getSecurityStatus(),
        CentersController.getPerformanceMetrics(),
        CentersController.getUserActivity()
      ]);

      console.timeEnd('system-overview-api');

      // è¿”å›èšåˆæ•°æ®
      res.json({
        success: true,
        data: {
          statistics,
          configs,
          security,
          performance,
          userActivity
        },
        timestamp: new Date().toISOString()
      });

    } catch (error: any) {
      console.error('ç³»ç»Ÿä¸­å¿ƒæ¦‚è§ˆAPIé”™è¯¯:', error);
      res.status(500).json({
        success: false,
        message: 'è·å–ç³»ç»Ÿæ¦‚è§ˆæ•°æ®å¤±è´¥',
        error: error.message
      });
    }
  }

  /**
   * ğŸ’° è´¢åŠ¡ä¸­å¿ƒæ¦‚è§ˆ - é›†åˆAPI
   * æ›¿ä»£åŸæ¥çš„6+ä¸ªç‹¬ç«‹APIè°ƒç”¨
   * è·¯ç”±: GET /api/centers/finance/overview
   */
  static async getFinanceOverview(req: Request, res: Response) {
    try {
      console.time('finance-overview-api');

      const [overview, bills, reports, statistics] = await Promise.all([
        CentersController.getFinanceOverviewData(),
        CentersController.getFinanceBills(),
        CentersController.getFinanceReports(),
        CentersController.getFinanceStatistics()
      ]);

      console.timeEnd('finance-overview-api');

      res.json({
        success: true,
        data: {
          overview,
          bills,
          reports,
          statistics
        },
        timestamp: new Date().toISOString()
      });

    } catch (error: any) {
      console.error('è´¢åŠ¡ä¸­å¿ƒæ¦‚è§ˆAPIé”™è¯¯:', error);
      res.status(500).json({
        success: false,
        message: 'è·å–è´¢åŠ¡æ¦‚è§ˆæ•°æ®å¤±è´¥',
        error: error.message
      });
    }
  }

  /**
   * ğŸª æ´»åŠ¨ä¸­å¿ƒæ¦‚è§ˆ - é›†åˆAPI
   * æ›¿ä»£åŸæ¥çš„4ä¸ªç‹¬ç«‹APIè°ƒç”¨
   * è·¯ç”±: GET /api/centers/activity/overview
   */
  static async getActivityOverview(req: Request, res: Response) {
    try {
      console.time('activity-overview-api');

      const [activities, registrations, statistics] = await Promise.all([
        CentersController.getActivityData(),
        CentersController.getActivityRegistrations(),
        CentersController.getActivityStatistics()
      ]);

      console.timeEnd('activity-overview-api');

      res.json({
        success: true,
        data: {
          activities,
          registrations,
          statistics
        },
        timestamp: new Date().toISOString()
      });

    } catch (error: any) {
      console.error('æ´»åŠ¨ä¸­å¿ƒæ¦‚è§ˆAPIé”™è¯¯:', error);
      res.status(500).json({
        success: false,
        message: 'è·å–æ´»åŠ¨æ¦‚è§ˆæ•°æ®å¤±è´¥',
        error: error.message
      });
    }
  }

  /**
   * ğŸ‘¨â€ğŸ« æ•™å¸ˆä¸­å¿ƒæ¦‚è§ˆ - é›†åˆAPI
   * æ›¿ä»£åŸæ¥çš„4ä¸ªç‹¬ç«‹APIè°ƒç”¨
   * è·¯ç”±: GET /api/centers/teacher/dashboard/overview
   */
  static async getTeacherDashboardOverview(req: Request, res: Response) {
    try {
      const userId = req.user?.id;

      if (!userId) {
        return res.status(401).json({
          success: false,
          message: 'ç”¨æˆ·æœªç™»å½•'
        });
      }

      console.time('teacher-dashboard-api');

      const [teacherInfo, tasks, schedule, notifications, activities] = await Promise.all([
        CentersController.getTeacherInfo(userId),
        CentersController.getTeacherTasks(userId),
        CentersController.getTeacherSchedule(userId),
        CentersController.getTeacherNotifications(userId),
        CentersController.getTeacherActivities(userId)
      ]);

      console.timeEnd('teacher-dashboard-api');

      res.json({
        success: true,
        data: {
          teacherInfo,
          tasks,
          schedule,
          notifications,
          activities
        },
        timestamp: new Date().toISOString()
      });

    } catch (error: any) {
      console.error('æ•™å¸ˆä¸­å¿ƒæ¦‚è§ˆAPIé”™è¯¯:', error);
      res.status(500).json({
        success: false,
        message: 'è·å–æ•™å¸ˆæ¦‚è§ˆæ•°æ®å¤±è´¥',
        error: error.message
      });
    }
  }

  /**
   * ğŸ“Š åˆ†æä¸­å¿ƒæ¦‚è§ˆ - é›†åˆAPI
   * æ›¿ä»£åŸæ¥çš„æ¨¡æ‹Ÿæ•°æ®
   * è·¯ç”±: GET /api/centers/analytics/overview
   */
  static async getAnalyticsOverview(req: Request, res: Response) {
    try {
      console.time('analytics-overview-api');

      const [enrollmentData, financialData, performanceData] = await Promise.all([
        CentersController.getEnrollmentAnalytics(),
        CentersController.getFinancialAnalytics(),
        CentersController.getPerformanceAnalytics()
      ]);

      console.timeEnd('analytics-overview-api');

      res.json({
        success: true,
        data: {
          enrollmentData,
          financialData,
          performanceData
        },
        timestamp: new Date().toISOString()
      });

    } catch (error: any) {
      console.error('åˆ†æä¸­å¿ƒæ¦‚è§ˆAPIé”™è¯¯:', error);
      res.status(500).json({
        success: false,
        message: 'è·å–åˆ†ææ¦‚è§ˆæ•°æ®å¤±è´¥',
        error: error.message
      });
    }
  }

  // ================== ç§æœ‰è¾…åŠ©æ–¹æ³• ==================

  /**
   * è·å–ç³»ç»Ÿç»Ÿè®¡æ•°æ®
   */
  static async getSystemStatistics() {
    const [
      totalUsers,
      activeUsers,
      totalRoles,
      totalPermissions,
      recentRegistrations
    ] = await Promise.all([
      User.count(),
      User.count({ where: { status: 'active' } }),
      Role.count(),
      Permission.count(),
      User.count({
        where: {
          createdAt: {
            [Op.gte]: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // 30å¤©
          }
        }
      })
    ]);

    return {
      totalUsers,
      activeUsers,
      totalRoles,
      totalPermissions,
      recentRegistrations,
      activeRate: ((activeUsers / totalUsers) * 100).toFixed(1)
    };
  }

  /**
   * è·å–ç³»ç»Ÿé…ç½®æ•°æ®
   */
  static async getSystemConfigs() {
    // è¿™é‡Œåº”è¯¥ä»é…ç½®è¡¨è·å–ï¼Œæš‚æ—¶è¿”å›æ¨¡æ‹Ÿæ•°æ®
    return {
      systemConfig: {
        maintenance: false,
        debugMode: process.env.NODE_ENV === 'development',
        version: process.env.npm_package_version || '1.0.0',
        timezone: 'Asia/Shanghai'
      },
      securityConfig: {
        passwordPolicy: 'strong',
        sessionTimeout: 30 * 60, // 30åˆ†é’Ÿ
        maxLoginAttempts: 5,
        lockoutDuration: 15 * 60 // 15åˆ†é’Ÿ
      },
      performanceConfig: {
        cacheEnabled: true,
        cacheTimeout: 5 * 60, // 5åˆ†é’Ÿ
        queryTimeout: 30 * 1000, // 30ç§’
        maxConnections: 100
      }
    };
  }

  /**
   * è·å–å®‰å…¨çŠ¶æ€
   */
  static async getSecurityStatus() {
    const [
      recentLogs,
      errorLogs,
      failedLogins,
      totalLogs
    ] = await Promise.all([
      SystemLog.count({
        where: {
          createdAt: {
            [Op.gte]: new Date(Date.now() - 24 * 60 * 60 * 1000) // 24å°æ—¶
          },
          level: {
            [Op.ne]: 'debug'
          }
        }
      }),
      SystemLog.count({
        where: {
          createdAt: {
            [Op.gte]: new Date(Date.now() - 24 * 60 * 60 * 1000)
          },
          level: 'error'
        }
      }),
      SystemLog.count({
        where: {
          createdAt: {
            [Op.gte]: new Date(Date.now() - 24 * 60 * 60 * 1000)
          },
          operationType: 'login'
        },
        message: {
          [Op.like]: '%failed%'
        }
      }),
      SystemLog.count({
        where: {
          createdAt: {
            [Op.gte]: new Date(Date.now() - 24 * 60 * 60 * 1000)
          }
        }
      })
    ]);

    const errorRate = totalLogs > 0 ? ((errorLogs / totalLogs) * 100).toFixed(2) : '0';

    return {
      securityStatus: errorLogs > 10 ? 'warning' : 'normal',
      recentLogs,
      errorLogs,
      failedLogins,
      totalLogs,
      errorRate,
      threatLevel: failedLogins > 5 ? 'medium' : 'low'
    };
  }

  /**
   * è·å–æ€§èƒ½æŒ‡æ ‡
   */
  static async getPerformanceMetrics() {
    // è¿™é‡Œåº”è¯¥ä»æ€§èƒ½ç›‘æ§è·å–ï¼Œæš‚æ—¶è¿”å›æ¨¡æ‹Ÿæ•°æ®
    return {
      systemMetrics: {
        cpuUsage: '45%',
        memoryUsage: '68%',
        diskUsage: '32%',
        networkLatency: '12ms'
      },
      databaseMetrics: {
        connectionCount: 15,
        queryTime: '45ms',
        slowQueries: 2,
        cacheHitRate: '85%'
      },
      apiMetrics: {
        avgResponseTime: '156ms',
        requestsPerMinute: 145,
        errorRate: '0.5%',
        uptime: '99.8%'
      }
    };
  }

  /**
   * è·å–ç”¨æˆ·æ´»åŠ¨æ•°æ®
   */
  static async getUserActivity() {
    const [
      recentLogins,
      activeSessions,
      errorRate
    ] = await Promise.all([
      SystemLog.count({
        where: {
          operationType: 'login',
          createdAt: {
            [Op.gte]: new Date(Date.now() - 24 * 60 * 60 * 1000)
          },
          level: 'info'
        }
      }),
      User.count({
        where: {
          lastLoginAt: {
            [Op.gte]: new Date(Date.now() - 30 * 60 * 1000) // 30åˆ†é’Ÿå†…
          }
        }
      }),
      SystemLog.count({
        where: {
          level: 'error',
          createdAt: {
            [Op.gte]: new Date(Date.now() - 24 * 60 * 60 * 1000)
          }
        }
      })
    ]);

    return {
      recentLogins,
      activeSessions,
      errorRate: (errorRate / 100).toFixed(3),
      onlineUsers: activeSessions
    };
  }

  /**
   * è·å–è´¢åŠ¡æ¦‚è§ˆæ•°æ®
   */
  static async getFinanceOverviewData() {
    const [
      totalRevenue,
      pendingAmount,
      paidAmount,
      overdueAmount,
      monthlyRevenue
    ] = await Promise.all([
      PaymentRecord.sum('amount'),
      PaymentBill.sum('total_amount', {
        where: { status: 'pending' }
      }),
      PaymentRecord.sum('amount', {
        where: { status: 'success' }
      }),
      PaymentBill.sum('total_amount', {
        where: {
          status: 'pending',
          dueDate: { [Op.lt]: new Date() }
        }
      }),
      PaymentRecord.sum('amount', {
        where: {
          payment_date: {
            [Op.gte]: new Date(new Date().getFullYear(), new Date().getMonth(), 1)
          }
        }
      })
    ]);

    return {
      totalRevenue: totalRevenue || 0,
      pendingAmount: pendingAmount || 0,
      paidAmount: paidAmount || 0,
      overdueAmount: overdueAmount || 0,
      monthlyRevenue: monthlyRevenue || 0
    };
  }

  /**
   * è·å–ç¼´è´¹å•æ•°æ®
   */
  static async getFinanceBills() {
    const [
      pendingBills,
      overdueBills,
      recentTransactions
    ] = await Promise.all([
      PaymentBill.findAll({
        where: { status: 'pending' },
        limit: 10,
        order: [['dueDate', 'ASC']]
      }),
      PaymentBill.findAll({
        where: {
          status: 'pending',
          dueDate: { [Op.lt]: new Date() }
        },
        limit: 10,
        order: [['dueDate', 'ASC']]
      }),
      PaymentRecord.findAll({
        limit: 10,
        order: [['payment_date', 'DESC']],
        include: [
          {
            model: PaymentBill,
            as: 'bill',
            attributes: ['bill_no', 'total_amount']
          }
        ]
      })
    ]);

    return {
      pendingBills,
      overdueBills,
      recentTransactions
    };
  }

  /**
   * è·å–è´¢åŠ¡æŠ¥è¡¨æ•°æ®
   */
  static async getFinanceReports() {
    // è¿™é‡Œåº”è¯¥ä»è´¢åŠ¡æŠ¥è¡¨è¡¨è·å–çœŸå®æ•°æ®
    return {
      monthlyReport: {
        currentMonth: 125000,
        lastMonth: 118000,
        growth: '5.9%'
      },
      yearlyReport: {
        currentYear: 1450000,
        lastYear: 1380000,
        growth: '5.1%'
      },
      trends: [
        { month: '1æœˆ', revenue: 95000 },
        { month: '2æœˆ', revenue: 105000 },
        { month: '3æœˆ', revenue: 118000 },
        { month: '4æœˆ', revenue: 125000 }
      ]
    };
  }

  /**
   * è·å–è´¢åŠ¡ç»Ÿè®¡æ•°æ®
   */
  static async getFinanceStatistics() {
    const [
      paymentStats,
      feeItemStats,
      enrollmentFinanceData
    ] = await Promise.all([
      PaymentRecord.findAll({
        attributes: [
          'payment_method',
          [sequelize.fn('COUNT', sequelize.col('id')), 'count'],
          [sequelize.fn('SUM', sequelize.col('amount')), 'total']
        ],
        group: ['payment_method']
      }),
      FeeItem.findAll({
        attributes: [
          'category',
          [sequelize.fn('COUNT', sequelize.col('id')), 'count'],
          [sequelize.fn('AVG', sequelize.col('amount')), 'avgAmount']
        ],
        group: ['category']
      }),
      this.getEnrollmentFinanceStats()
    ]);

    return {
      paymentStatistics: paymentStats,
      feeItemStatistics: feeItemStats,
      enrollmentFinanceData
    };
  }

  /**
   * è·å–æ´»åŠ¨æ•°æ®
   */
  static async getActivityData() {
    const [
      ongoingActivities,
      upcomingActivities,
      pastActivities
    ] = await Promise.all([
      Activity.findAll({
        where: {
          status: 'published',
          start_time: { [Op.lte]: new Date() },
          end_time: { [Op.gte]: new Date() }
        },
        limit: 10,
        order: [['start_time', 'ASC']]
      }),
      Activity.findAll({
        where: {
          status: 'published',
          start_time: { [Op.gt]: new Date() }
        },
        limit: 10,
        order: [['start_time', 'ASC']]
      }),
      Activity.findAll({
        where: {
          status: 'completed',
          end_time: { [Op.lt]: new Date() }
        },
        limit: 10,
        order: [['end_time', 'DESC']]
      })
    ]);

    return {
      ongoingActivities,
      upcomingActivities,
      pastActivities
    };
  }

  /**
   * è·å–æ´»åŠ¨æŠ¥åæ•°æ®
   */
  static async getActivityRegistrations() {
    const [
      pendingRegistrations,
      totalRegistrations,
      registrationTrends
    ] = await Promise.all([
      ActivityRegistration.findAll({
        where: { status: 'pending' },
        limit: 10,
        order: [['registration_time', 'ASC']]
      }),
      ActivityRegistration.count(),
      this.getRegistrationTrends()
    ]);

    return {
      pendingRegistrations,
      totalRegistrations,
      registrationTrends
    };
  }

  /**
   * è·å–æ´»åŠ¨ç»Ÿè®¡æ•°æ®
   */
  static async getActivityStatistics() {
    const [totalActivities, activeActivities] = await Promise.all([
      Activity.count({ where: { status: { [Op.ne]: 'cancelled' } } }),
      Activity.count({ where: { status: 'published' } })
    ]);

    const avgParticipationRate = 75.5; // æ¨¡æ‹Ÿæ•°æ®

    return {
      totalActivities,
      activeActivities,
      participationRate: avgParticipationRate
    };
  }

  /**
   * è·å–æ•™å¸ˆä¿¡æ¯
   */
  static async getTeacherInfo(userId: number) {
    const teacher = await Teacher.findOne({
      where: { userId },
      include: [
        {
          model: User,
          as: 'user',
          attributes: ['username', 'email', 'realName', 'avatar']
        },
        {
          model: Class,
          as: 'headTeacherClass',
          attributes: ['id', 'name', 'grade']
        }
      ]
    });

    if (!teacher) {
      throw new Error('æ•™å¸ˆä¿¡æ¯ä¸å­˜åœ¨');
    }

    return {
      basicInfo: teacher.toJSON(),
      teachingStats: {
        totalClasses: 15,
        totalStudents: 320,
        avgClassSize: 21,
        teachingHours: 25
      },
      performance: {
        completionRate: '92%',
        studentSatisfaction: '4.6',
        parentFeedback: '4.5'
      }
    };
  }

  /**
   * è·å–æ•™å¸ˆä»»åŠ¡
   */
  static async getTeacherTasks(userId: number) {
    const [pendingTasks, overdueTasks, completedTasks] = await Promise.all([
      Todo.count({
        where: { assignedTo: userId, status: 'pending' }
      }),
      Todo.count({
        where: {
          assignedTo: userId,
          status: { [Op.ne]: 'completed' },
          dueDate: { [Op.lt]: new Date() }
        }
      }),
      Todo.count({
        where: { assignedTo: userId, status: 'completed' }
      })
    ]);

    return {
      pendingTasks: await Todo.findAll({
        where: { assignedTo: userId, status: 'pending' },
        limit: 5,
        order: [['dueDate', 'ASC']]
      }),
      overdueTasks: await Todo.findAll({
        where: {
          assignedTo: userId,
          status: { [Op.ne]: 'completed' },
          dueDate: { [Op.lt]: new Date() }
        },
        limit: 5,
        order: [['dueDate', 'ASC']]
      }),
      completedTasks
    };
  }

  /**
   * è·å–æ•™å¸ˆæ—¥ç¨‹
   */
  static async getTeacherSchedule(userId: number) {
    const today = new Date();
    const startOfWeek = new Date(today);
    startOfWeek.setDate(today.getDate() - today.getDay());

    return {
      todaySchedule: await Schedule.findAll({
        where: { userId, schedule_date: today },
        order: [['start_time', 'ASC']]
      }),
      weekSchedule: await Schedule.findAll({
        where: {
          userId,
          schedule_date: {
            [Op.between]: [startOfWeek, new Date(startOfWeek.getTime() + 7 * 24 * 60 * 60 * 1000)]
          }
        },
        order: [['schedule_date', 'ASC'], ['start_time', 'ASC']]
      })
    };
  }

  /**
   * è·å–æ•™å¸ˆé€šçŸ¥
   */
  static async getTeacherNotifications(userId: number) {
    return {
      unreadNotifications: await Notification.findAll({
        where: { userId, status: 'unread' },
        limit: 5,
        order: [['created_at', 'DESC']]
      }),
      recentAnnouncements: await Notification.findAll({
        where: {
          type: 'announcement',
          created_at: { [Op.gte]: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) }
        },
        limit: 3,
        order: [['created_at', 'DESC']]
      })
    };
  }

  /**
   * è·å–æ•™å¸ˆæ´»åŠ¨
   */
  private static async getTeacherActivities(userId: number) {
    const teacher = await Teacher.findOne({ where: { userId } });

    return {
      teachingActivities: await Activity.findAll({
        where: { creatorId: teacher?.id },
        limit: 5,
        order: [['created_at', 'DESC']]
      }),
      participatingActivities: await ActivityRegistration.findAll({
        where: { share_by: teacher?.id },
        limit: 5,
        order: [['registration_time', 'DESC']]
      })
    };
  }

  /**
   * è·å–æ‹›ç”Ÿè´¢åŠ¡ç»Ÿè®¡
   */
  static async getEnrollmentFinanceStats() {
    // æ¨¡æ‹Ÿæ‹›ç”Ÿè´¢åŠ¡æ•°æ®
    return {
      totalRevenue: 2500000,
      avgTuition: 8000,
      collectionRate: 0.95,
      pendingAmount: 125000
    };
  }

  /**
   * è·å–æŠ¥åè¶‹åŠ¿
   */
  static async getRegistrationTrends() {
    // æ¨¡æ‹ŸæŠ¥åè¶‹åŠ¿æ•°æ®
    return [
      { month: '1æœˆ', registrations: 120 },
      { month: '2æœˆ', registrations: 145 },
      { month: '3æœˆ', registrations: 168 },
      { month: '4æœˆ', registrations: 156 }
    ];
  }

  /**
   * è·å–æ‹›ç”Ÿåˆ†ææ•°æ®
   */
  static async getEnrollmentAnalytics() {
    return {
      currentMonth: 156,
      lastMonth: 145,
      growthRate: 7.6,
      sources: [
        { source: 'online', count: 89, percentage: 57.1 },
        { source: 'offline', count: 42, percentage: 26.9 },
        { source: 'referral', count: 25, percentage: 16.0 }
      ],
      demographics: {
        ageGroups: [
          { range: '3-4å²', count: 45 },
          { range: '4-5å²', count: 68 },
          { range: '5-6å²', count: 43 }
        ]
      }
    };
  }

  /**
   * è·å–è´¢åŠ¡åˆ†ææ•°æ®
   */
  static async getFinancialAnalytics() {
    return {
      revenueBreakdown: {
        tuition: 850000,
        activities: 320000,
        materials: 150000,
        other: 80000
      },
      paymentMethods: [
        { method: 'alipay', amount: 680000, percentage: 51.5 },
        { method: 'wechat', amount: 450000, percentage: 34.1 },
        { method: 'bank', amount: 200000, percentage: 15.2 },
        { method: 'cash', amount: -40000, percentage: -0.8 }
      ]
    };
  }

  /**
   * è·å–æ€§èƒ½åˆ†ææ•°æ®
   */
  static async getPerformanceAnalytics() {
    return {
      systemPerformance: {
        uptime: '99.8%',
        responseTime: '156ms',
        throughput: '145 req/min'
      },
      userMetrics: {
        activeUsers: 1245,
        newUsers: 89,
        retentionRate: '92.5%'
      },
      applicationMetrics: {
        apiCalls: 285000,
        avgResponseTime: '120ms',
        errorRate: '0.3%'
      }
    };
  }
}

export default CentersController;