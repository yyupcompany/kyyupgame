/**
 * å‘¼å«ä¸­å¿ƒæ§åˆ¶å™¨
 * å¤„ç†æ‰€æœ‰å‘¼å«ä¸­å¿ƒç›¸å…³çš„HTTPè¯·æ±‚
 */

import { Request, Response } from 'express'
// import callCenterService from '../services/call-center.service'  // æš‚æ—¶ç¦ç”¨
import { sipUDPService } from '../services/sip-udp.service'
import { sipConfigService } from '../services/sip-config.service'
import { ApiResponse } from '../utils/response'
import { User } from '../models'

class CallCenterController {
  /**
   * è·å–æ¦‚è§ˆæ•°æ®
   */
  async getOverview(req: Request, res: Response) {
    try {
      const userId = (req as any).user.id

      // è·å–æ´»è·ƒé€šè¯æ•°
      const activeCallCount = sipUDPService.getActiveCallCount()

      // è·å–SIPé…ç½®çŠ¶æ€
      const sipConfig = sipConfigService.getConfig()

      const overviewData = {
        activeCalls: activeCallCount,
        sipStatus: sipConfig ? 'connected' : 'disconnected',
        sipServer: sipConfig ? `${sipConfig.server_host}:${sipConfig.server_port}` : null
      }

      return ApiResponse.success(res, overviewData, 'è·å–æ¦‚è§ˆæ•°æ®æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–æ¦‚è§ˆæ•°æ®å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–æ¦‚è§ˆæ•°æ®å¤±è´¥', 'ERROR')
    }
  }

  /**
   * SIPè¿æ¥ç®¡ç†
   */
  async getSIPStatus(req: Request, res: Response) {
    try {
      const sipConfig = sipConfigService.getConfig()

      if (!sipConfig) {
        return ApiResponse.error(res, 'SIPé…ç½®æœªåŠ è½½', 'NOT_FOUND')
      }

      const sipStatus = {
        isConnected: sipConfigService.isConfigLoaded(),
        server: `${sipConfig.server_host}:${sipConfig.server_port}`,
        username: sipConfig.username,
        protocol: sipConfig.protocol,
        lastRegisterTime: sipConfig.last_register_time,
        activeCalls: sipUDPService.getActiveCallCount()
      }

      return ApiResponse.success(res, sipStatus, 'è·å–SIPçŠ¶æ€æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–SIPçŠ¶æ€å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–SIPçŠ¶æ€å¤±è´¥', 'ERROR')
    }
  }

  async connectSIP(req: Request, res: Response) {
    try {
      // é‡æ–°åŠ è½½SIPé…ç½®
      await sipConfigService.reloadConfig()

      // åˆå§‹åŒ–UDPæœåŠ¡
      await sipUDPService.initialize()

      return ApiResponse.success(res, {
        message: 'SIPæœåŠ¡å·²åˆå§‹åŒ–',
        config: sipConfigService.getServerAddress()
      }, 'SIPè¿æ¥æˆåŠŸ')
    } catch (error) {
      console.error('âŒ SIPè¿æ¥å¤±è´¥:', error)
      return ApiResponse.error(res, 'SIPè¿æ¥å¤±è´¥', 'ERROR')
    }
  }

  async disconnectSIP(req: Request, res: Response) {
    try {
      // UDPæ¨¡å¼ä¸‹æš‚ä¸æ”¯æŒæ–­å¼€è¿æ¥
      return ApiResponse.success(res, null, 'UDPæ¨¡å¼ä¸‹æ— éœ€æ–­å¼€è¿æ¥')
    } catch (error) {
      console.error('âŒ SIPæ–­å¼€å¤±è´¥:', error)
      return ApiResponse.error(res, 'SIPæ–­å¼€å¤±è´¥', 'ERROR')
    }
  }

  async testSIPConnection(req: Request, res: Response) {
    try {
      const sipConfig = sipConfigService.getConfig()

      if (!sipConfig) {
        return ApiResponse.error(res, 'SIPé…ç½®æœªåŠ è½½', 'NOT_FOUND')
      }

      const testResult = {
        success: true,
        server: `${sipConfig.server_host}:${sipConfig.server_port}`,
        protocol: sipConfig.protocol,
        message: 'SIPé…ç½®æœ‰æ•ˆ'
      }

      return ApiResponse.success(res, testResult, 'SIPè¿æ¥æµ‹è¯•å®Œæˆ')
    } catch (error) {
      console.error('âŒ SIPè¿æ¥æµ‹è¯•å¤±è´¥:', error)
      return ApiResponse.error(res, 'SIPè¿æ¥æµ‹è¯•å¤±è´¥', 'ERROR')
    }
  }

  async updateSIPConfig(req: Request, res: Response) {
    try {
      const { id, ...updates } = req.body

      if (!id) {
        return ApiResponse.error(res, 'é…ç½®IDä¸èƒ½ä¸ºç©º', 'VALIDATION_ERROR')
      }

      const success = await sipConfigService.updateConfig(id, updates)

      if (success) {
        return ApiResponse.success(res, null, 'SIPé…ç½®æ›´æ–°æˆåŠŸ')
      } else {
        return ApiResponse.error(res, 'SIPé…ç½®æ›´æ–°å¤±è´¥', 'ERROR')
      }
    } catch (error) {
      console.error('âŒ æ›´æ–°SIPé…ç½®å¤±è´¥:', error)
      return ApiResponse.error(res, 'æ›´æ–°SIPé…ç½®å¤±è´¥', 'ERROR')
    }
  }

  /**
   * é€šè¯ç®¡ç†ï¼ˆæ—§ç‰ˆWebSocketæ–¹å¼ - æš‚æ—¶ç¦ç”¨ï¼‰
   */
  async makeCall(req: Request, res: Response) {
    try {
      return ApiResponse.error(res, 'è¯·ä½¿ç”¨UDPå‘¼å«æ¥å£: POST /api/call-center/call/udp/make', 'DEPRECATED')
    } catch (error) {
      console.error('âŒ å‘èµ·é€šè¯å¤±è´¥:', error)
      return ApiResponse.error(res, 'å‘èµ·é€šè¯å¤±è´¥', 'ERROR')
    }
  }

  /**
   * ä½¿ç”¨UDPæ–¹å¼å‘èµ·å‘¼å«ï¼ˆæ–°å¢ï¼‰
   * åŸºäºæˆåŠŸçš„Pythonæµ‹è¯•è„šæœ¬
   */
  async makeCallUDP(req: Request, res: Response) {
    try {
      const userId = (req as any).user.id
      const { phoneNumber, customerId, systemPrompt } = req.body

      // éªŒè¯ç”µè¯å·ç 
      if (!phoneNumber) {
        return ApiResponse.error(res, 'ç”µè¯å·ç ä¸èƒ½ä¸ºç©º', 'VALIDATION_ERROR')
      }

      console.log(`ğŸ“ ç”¨æˆ· ${userId} å‘èµ·UDPå‘¼å«: ${phoneNumber}`)

      // ä½¿ç”¨UDP SIPæœåŠ¡å‘èµ·å‘¼å«
      const callId = await sipUDPService.makeCall(
        phoneNumber,
        customerId,
        systemPrompt
      )

      return ApiResponse.success(res, {
        callId,
        phoneNumber,
        status: 'connecting',
        message: 'å‘¼å«å·²å‘èµ·ï¼Œç­‰å¾…æ¥é€š'
      }, 'UDPå‘¼å«å‘èµ·æˆåŠŸ')
    } catch (error) {
      console.error('âŒ UDPå‘¼å«å¤±è´¥:', error)
      return ApiResponse.error(
        res,
        error instanceof Error ? error.message : 'UDPå‘¼å«å¤±è´¥',
        'CALL_ERROR'
      )
    }
  }

  /**
   * è·å–UDPå‘¼å«çŠ¶æ€
   */
  async getCallStatusUDP(req: Request, res: Response) {
    try {
      const { callId } = req.params

      const callInfo = sipUDPService.getCallInfo(callId)

      if (!callInfo) {
        return ApiResponse.error(res, 'é€šè¯ä¸å­˜åœ¨', 'NOT_FOUND')
      }

      return ApiResponse.success(res, {
        callId: callInfo.callId,
        phoneNumber: callInfo.phoneNumber,
        status: callInfo.status,
        startTime: callInfo.startTime,
        duration: Math.floor((Date.now() - callInfo.startTime.getTime()) / 1000)
      }, 'è·å–é€šè¯çŠ¶æ€æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–é€šè¯çŠ¶æ€å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–é€šè¯çŠ¶æ€å¤±è´¥', 'ERROR')
    }
  }

  /**
   * æŒ‚æ–­UDPå‘¼å«
   */
  async hangupCallUDP(req: Request, res: Response) {
    try {
      const { callId } = req.body

      if (!callId) {
        return ApiResponse.error(res, 'callIdä¸èƒ½ä¸ºç©º', 'VALIDATION_ERROR')
      }

      await sipUDPService.hangupCall(callId)

      return ApiResponse.success(res, null, 'é€šè¯å·²æŒ‚æ–­')
    } catch (error) {
      console.error('âŒ æŒ‚æ–­é€šè¯å¤±è´¥:', error)
      return ApiResponse.error(
        res,
        error instanceof Error ? error.message : 'æŒ‚æ–­é€šè¯å¤±è´¥',
        'ERROR'
      )
    }
  }

  /**
   * è·å–æ‰€æœ‰æ´»è·ƒçš„UDPå‘¼å«
   */
  async getActiveCallsUDP(req: Request, res: Response) {
    try {
      const activeCalls = sipUDPService.getActiveCalls()

      return ApiResponse.success(res, {
        total: activeCalls.length,
        calls: activeCalls.map(call => ({
          callId: call.callId,
          phoneNumber: call.phoneNumber,
          status: call.status,
          startTime: call.startTime,
          duration: Math.floor((Date.now() - call.startTime.getTime()) / 1000)
        }))
      }, 'è·å–æ´»è·ƒé€šè¯æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–æ´»è·ƒé€šè¯å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–æ´»è·ƒé€šè¯å¤±è´¥', 'ERROR')
    }
  }

  async answerCall(req: Request, res: Response) {
    try {
      const { callId } = req.params

      await callCenterService.answerCall(callId)

      return ApiResponse.success(res, null, 'æ¥å¬é€šè¯æˆåŠŸ')
    } catch (error) {
      console.error('âŒ æ¥å¬é€šè¯å¤±è´¥:', error)
      return ApiResponse.error(res, 'æ¥å¬é€šè¯å¤±è´¥', 'ERROR')
    }
  }

  async hangupCall(req: Request, res: Response) {
    try {
      const { callId } = req.body

      await callCenterService.hangupCall(callId)

      return ApiResponse.success(res, null, 'æŒ‚æ–­é€šè¯æˆåŠŸ')
    } catch (error) {
      console.error('âŒ æŒ‚æ–­é€šè¯å¤±è´¥:', error)
      return ApiResponse.error(res, 'æŒ‚æ–­é€šè¯å¤±è´¥', 'ERROR')
    }
  }

  async holdCall(req: Request, res: Response) {
    try {
      const { callId } = req.body

      await callCenterService.holdCall(callId)

      return ApiResponse.success(res, null, 'ä¿æŒé€šè¯æˆåŠŸ')
    } catch (error) {
      console.error('âŒ ä¿æŒé€šè¯å¤±è´¥:', error)
      return ApiResponse.error(res, 'ä¿æŒé€šè¯å¤±è´¥', 'ERROR')
    }
  }

  async unholdCall(req: Request, res: Response) {
    try {
      const { callId } = req.body

      await callCenterService.unholdCall(callId)

      return ApiResponse.success(res, null, 'æ¢å¤é€šè¯æˆåŠŸ')
    } catch (error) {
      console.error('âŒ æ¢å¤é€šè¯å¤±è´¥:', error)
      return ApiResponse.error(res, 'æ¢å¤é€šè¯å¤±è´¥', 'ERROR')
    }
  }

  async transferCall(req: Request, res: Response) {
    try {
      const { callId, targetExtension } = req.body

      await callCenterService.transferCall(callId, targetExtension)

      return ApiResponse.success(res, null, 'è½¬ç§»é€šè¯æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è½¬ç§»é€šè¯å¤±è´¥:', error)
      return ApiResponse.error(res, 'è½¬ç§»é€šè¯å¤±è´¥', 'ERROR')
    }
  }

  async getActiveCalls(req: Request, res: Response) {
    try {
      const activeCalls = await callCenterService.getActiveCalls()

      return ApiResponse.success(res, activeCalls, 'è·å–æ´»è·ƒé€šè¯æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–æ´»è·ƒé€šè¯å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–æ´»è·ƒé€šè¯å¤±è´¥', 'ERROR')
    }
  }

  async getCallHistory(req: Request, res: Response) {
    try {
      const userId = (req as any).user.id
      const {
        page = 1,
        pageSize = 20,
        startDate,
        endDate,
        status,
        extension
      } = req.query

      const historyData = await callCenterService.getRecordings({
        page: Number(page),
        pageSize: Number(pageSize),
        startDate: startDate ? new Date(startDate as string) : undefined,
        endDate: endDate ? new Date(endDate as string) : undefined,
        status: status as string,
        userId
      })

      return ApiResponse.success(res, historyData, 'è·å–é€šè¯å†å²æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–é€šè¯å†å²å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–é€šè¯å†å²å¤±è´¥', 'ERROR')
    }
  }

  async getCallStatistics(req: Request, res: Response) {
    try {
      const { period = 'today' } = req.query

      const statistics = await callCenterService.getStatistics(period as any)

      return ApiResponse.success(res, statistics, 'è·å–é€šè¯ç»Ÿè®¡æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–é€šè¯ç»Ÿè®¡å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–é€šè¯ç»Ÿè®¡å¤±è´¥', 'ERROR')
    }
  }

  async sendDTMF(req: Request, res: Response) {
    try {
      const { callId, digits } = req.body

      // è¿™é‡Œå¯ä»¥æ·»åŠ DTMFå‘é€é€»è¾‘
      console.log(`ğŸ”¢ å‘é€DTMF: ${callId} -> ${digits}`)

      return ApiResponse.success(res, null, 'DTMFå‘é€æˆåŠŸ')
    } catch (error) {
      console.error('âŒ DTMFå‘é€å¤±è´¥:', error)
      return ApiResponse.error(res, 'DTMFå‘é€å¤±è´¥', 'ERROR')
    }
  }

  /**
   * å½•éŸ³ç®¡ç†
   */
  async startRecording(req: Request, res: Response) {
    try {
      const { callId } = req.body

      await callCenterService.startRecording(callId)

      return ApiResponse.success(res, null, 'å¼€å§‹å½•éŸ³æˆåŠŸ')
    } catch (error) {
      console.error('âŒ å¼€å§‹å½•éŸ³å¤±è´¥:', error)
      return ApiResponse.error(res, 'å¼€å§‹å½•éŸ³å¤±è´¥', 'ERROR')
    }
  }

  async stopRecording(req: Request, res: Response) {
    try {
      const { callId } = req.body

      const recording = await callCenterService.stopRecording(callId)

      return ApiResponse.success(res, recording, 'åœæ­¢å½•éŸ³æˆåŠŸ')
    } catch (error) {
      console.error('âŒ åœæ­¢å½•éŸ³å¤±è´¥:', error)
      return ApiResponse.error(res, 'åœæ­¢å½•éŸ³å¤±è´¥', 'ERROR')
    }
  }

  async getRecordings(req: Request, res: Response) {
    try {
      const userId = (req as any).user.id
      const {
        page = 1,
        pageSize = 20,
        phoneNumber,
        contactName,
        startDate,
        endDate,
        status = 'all'
      } = req.query

      const recordingsData = await callCenterService.getRecordings({
        page: Number(page),
        pageSize: Number(pageSize),
        phoneNumber: phoneNumber as string,
        contactName: contactName as string,
        startDate: startDate ? new Date(startDate as string) : undefined,
        endDate: endDate ? new Date(endDate as string) : undefined,
        status: status as string,
        userId
      })

      return ApiResponse.success(res, recordingsData, 'è·å–å½•éŸ³åˆ—è¡¨æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–å½•éŸ³åˆ—è¡¨å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–å½•éŸ³åˆ—è¡¨å¤±è´¥', 'ERROR')
    }
  }

  async getRecording(req: Request, res: Response) {
    try {
      const { id } = req.params

      // è¿™é‡Œå¯ä»¥æ·»åŠ è·å–å½•éŸ³è¯¦æƒ…çš„é€»è¾‘
      const recording = { id, status: 'completed' }

      return ApiResponse.success(res, recording, 'è·å–å½•éŸ³è¯¦æƒ…æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–å½•éŸ³è¯¦æƒ…å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–å½•éŸ³è¯¦æƒ…å¤±è´¥', 'ERROR')
    }
  }

  async downloadRecording(req: Request, res: Response) {
    try {
      const { id } = req.params

      // æ¨¡æ‹Ÿä¸‹è½½URLç”Ÿæˆ
      const downloadData = {
        downloadUrl: `/api/call-center/recordings/${id}/download/file`,
        expiresAt: new Date(Date.now() + 3600000) // 1å°æ—¶åè¿‡æœŸ
      }

      return ApiResponse.success(res, downloadData, 'è·å–ä¸‹è½½é“¾æ¥æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–ä¸‹è½½é“¾æ¥å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–ä¸‹è½½é“¾æ¥å¤±è´¥', 'ERROR')
    }
  }

  async deleteRecording(req: Request, res: Response) {
    try {
      const { id } = req.params

      // è¿™é‡Œå¯ä»¥æ·»åŠ åˆ é™¤å½•éŸ³çš„é€»è¾‘
      console.log(`ğŸ—‘ï¸ åˆ é™¤å½•éŸ³: ${id}`)

      return ApiResponse.success(res, null, 'åˆ é™¤å½•éŸ³æˆåŠŸ')
    } catch (error) {
      console.error('âŒ åˆ é™¤å½•éŸ³å¤±è´¥:', error)
      return ApiResponse.error(res, 'åˆ é™¤å½•éŸ³å¤±è´¥', 'ERROR')
    }
  }

  async getTranscript(req: Request, res: Response) {
    try {
      const { id } = req.params

      // è¿™é‡Œå¯ä»¥æ·»åŠ è·å–è½¬å†™å†…å®¹çš„é€»è¾‘
      const transcriptData = {
        transcript: 'è¿™æ˜¯é€šè¯çš„è½¬å†™å†…å®¹...',
        language: 'zh-CN'
      }

      return ApiResponse.success(res, transcriptData, 'è·å–è½¬å†™å†…å®¹æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–è½¬å†™å†…å®¹å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–è½¬å†™å†…å®¹å¤±è´¥', 'ERROR')
    }
  }

  async updateTranscript(req: Request, res: Response) {
    try {
      const { id } = req.params
      const { transcript } = req.body

      // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´æ–°è½¬å†™å†…å®¹çš„é€»è¾‘
      console.log(`ğŸ“ æ›´æ–°è½¬å†™å†…å®¹: ${id}`)

      return ApiResponse.success(res, null, 'æ›´æ–°è½¬å†™å†…å®¹æˆåŠŸ')
    } catch (error) {
      console.error('âŒ æ›´æ–°è½¬å†™å†…å®¹å¤±è´¥:', error)
      return ApiResponse.error(res, 'æ›´æ–°è½¬å†™å†…å®¹å¤±è´¥', 'ERROR')
    }
  }

  async requestTranscription(req: Request, res: Response) {
    try {
      const { id } = req.params
      const { language = 'zh-CN' } = req.body

      // è¿™é‡Œå¯ä»¥æ·»åŠ è¯·æ±‚è½¬å†™çš„é€»è¾‘
      console.log(`ğŸ¯ è¯·æ±‚è½¬å†™: ${id} (${language})`)

      return ApiResponse.success(res, null, 'è½¬å†™è¯·æ±‚å·²æäº¤')
    } catch (error) {
      console.error('âŒ è½¬å†™è¯·æ±‚å¤±è´¥:', error)
      return ApiResponse.error(res, 'è½¬å†™è¯·æ±‚å¤±è´¥', 'ERROR')
    }
  }

  /**
   * AIåˆ†æåŠŸèƒ½
   */
  async analyzeCall(req: Request, res: Response) {
    try {
      const { callId } = req.params
      const { includeTranscript = false } = req.body

      const analysis = await callCenterService.analyzeCall(callId)

      return ApiResponse.success(res, analysis, 'AIåˆ†æå®Œæˆ')
    } catch (error) {
      console.error('âŒ AIåˆ†æå¤±è´¥:', error)
      return ApiResponse.error(res, 'AIåˆ†æå¤±è´¥', 'ERROR')
    }
  }

  async batchAnalyze(req: Request, res: Response) {
    try {
      const { callIds } = req.body

      // è¿™é‡Œå¯ä»¥æ·»åŠ æ‰¹é‡åˆ†æé€»è¾‘
      const results = []
      const failed = []

      for (const callId of callIds) {
        try {
          const analysis = await callCenterService.analyzeCall(callId)
          results.push(analysis)
        } catch (error) {
          failed.push(callId)
        }
      }

      return ApiResponse.success(res, { results, failed }, 'æ‰¹é‡åˆ†æå®Œæˆ')
    } catch (error) {
      console.error('âŒ æ‰¹é‡åˆ†æå¤±è´¥:', error)
      return ApiResponse.error(res, 'æ‰¹é‡åˆ†æå¤±è´¥', 'ERROR')
    }
  }

  async synthesizeVoice(req: Request, res: Response) {
    try {
      const synthesisRequest = req.body

      const synthesisResult = await callCenterService.synthesizeVoice(synthesisRequest)

      return ApiResponse.success(res, synthesisResult, 'è¯­éŸ³åˆæˆå®Œæˆ')
    } catch (error) {
      console.error('âŒ è¯­éŸ³åˆæˆå¤±è´¥:', error)
      return ApiResponse.error(res, 'è¯­éŸ³åˆæˆå¤±è´¥', 'ERROR')
    }
  }

  async getSynthesisStatus(req: Request, res: Response) {
    try {
      const { taskId } = req.params

      // è¿™é‡Œå¯ä»¥æ·»åŠ è·å–åˆæˆçŠ¶æ€çš„é€»è¾‘
      const statusData = {
        status: 'completed',
        progress: 100,
        result: {
          id: taskId,
          audioUrl: `/api/call-center/ai/audio/${taskId}`,
          duration: 10,
          fileSize: 50000
        }
      }

      return ApiResponse.success(res, statusData, 'è·å–åˆæˆçŠ¶æ€æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–åˆæˆçŠ¶æ€å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–åˆæˆçŠ¶æ€å¤±è´¥', 'ERROR')
    }
  }

  async startTranscription(req: Request, res: Response) {
    try {
      const { callId } = req.params
      const { language = 'zh-CN' } = req.body

      // è¿™é‡Œå¯ä»¥æ·»åŠ å¼€å§‹è½¬å†™çš„é€»è¾‘
      console.log(`ğŸ™ï¸ å¼€å§‹è½¬å†™: ${callId} (${language})`)

      return ApiResponse.success(res, null, 'è½¬å†™å·²å¼€å§‹')
    } catch (error) {
      console.error('âŒ å¼€å§‹è½¬å†™å¤±è´¥:', error)
      return ApiResponse.error(res, 'å¼€å§‹è½¬å†™å¤±è´¥', 'ERROR')
    }
  }

  async stopTranscription(req: Request, res: Response) {
    try {
      const { callId } = req.params

      // è¿™é‡Œå¯ä»¥æ·»åŠ åœæ­¢è½¬å†™çš„é€»è¾‘
      console.log(`â¹ï¸ åœæ­¢è½¬å†™: ${callId}`)

      return ApiResponse.success(res, null, 'è½¬å†™å·²åœæ­¢')
    } catch (error) {
      console.error('âŒ åœæ­¢è½¬å†™å¤±è´¥:', error)
      return ApiResponse.error(res, 'åœæ­¢è½¬å†™å¤±è´¥', 'ERROR')
    }
  }

  async getTranscriptionResult(req: Request, res: Response) {
    try {
      const { callId } = req.params

      // è¿™é‡Œå¯ä»¥æ·»åŠ è·å–è½¬å†™ç»“æœçš„é€»è¾‘
      const resultData = {
        transcript: 'è¿™æ˜¯å®æ—¶çš„è½¬å†™å†…å®¹...',
        isFinal: false,
        confidence: 0.95
      }

      return ApiResponse.success(res, resultData, 'è·å–è½¬å†™ç»“æœæˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–è½¬å†™ç»“æœå¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–è½¬å†™ç»“æœå¤±è´¥', 'ERROR')
    }
  }

  async analyzeSentiment(req: Request, res: Response) {
    try {
      const { callId } = req.params

      // è¿™é‡Œå¯ä»¥æ·»åŠ æƒ…æ„Ÿåˆ†æçš„é€»è¾‘
      const sentimentData = {
        sentiment: 'positive',
        confidence: 0.85,
        emotions: {
          happy: 0.7,
          neutral: 0.2,
          sad: 0.05,
          angry: 0.05
        }
      }

      return ApiResponse.success(res, sentimentData, 'æƒ…æ„Ÿåˆ†æå®Œæˆ')
    } catch (error) {
      console.error('âŒ æƒ…æ„Ÿåˆ†æå¤±è´¥:', error)
      return ApiResponse.error(res, 'æƒ…æ„Ÿåˆ†æå¤±è´¥', 'ERROR')
    }
  }

  async generateResponse(req: Request, res: Response) {
    try {
      const { callId } = req.params
      const { lastMessage, intent } = req.body

      // è¿™é‡Œå¯ä»¥æ·»åŠ ç”Ÿæˆæ™ºèƒ½å›å¤çš„é€»è¾‘
      const responseData = {
        response: 'æ ¹æ®å®¢æˆ·çš„é—®é¢˜ï¼Œæˆ‘å»ºè®®æ‚¨...',
        confidence: 0.9,
        suggestions: [
          'æä¾›è¯¦ç»†çš„äº§å“ä¿¡æ¯',
          'é¢„çº¦å®åœ°å‚è§‚',
          'å‘é€è¯¾ç¨‹èµ„æ–™'
        ]
      }

      return ApiResponse.success(res, responseData, 'ç”Ÿæˆæ™ºèƒ½å›å¤æˆåŠŸ')
    } catch (error) {
      console.error('âŒ ç”Ÿæˆæ™ºèƒ½å›å¤å¤±è´¥:', error)
      return ApiResponse.error(res, 'ç”Ÿæˆæ™ºèƒ½å›å¤å¤±è´¥', 'ERROR')
    }
  }

  /**
   * åˆ†æœºç®¡ç†
   */
  async getExtensions(req: Request, res: Response) {
    try {
      const userId = (req as any).user.id

      const extensions = await callCenterService.getExtensions(userId)

      return ApiResponse.success(res, extensions, 'è·å–åˆ†æœºåˆ—è¡¨æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–åˆ†æœºåˆ—è¡¨å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–åˆ†æœºåˆ—è¡¨å¤±è´¥', 'ERROR')
    }
  }

  async getExtension(req: Request, res: Response) {
    try {
      const { id } = req.params

      // è¿™é‡Œå¯ä»¥æ·»åŠ è·å–åˆ†æœºè¯¦æƒ…çš„é€»è¾‘
      const extension = {
        id,
        extension: '1001',
        name: 'ä¸»åå¸­',
        status: 'online'
      }

      return ApiResponse.success(res, extension, 'è·å–åˆ†æœºè¯¦æƒ…æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–åˆ†æœºè¯¦æƒ…å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–åˆ†æœºè¯¦æƒ…å¤±è´¥', 'ERROR')
    }
  }

  async updateExtensionStatus(req: Request, res: Response) {
    try {
      const { id } = req.params
      const { status } = req.body

      await callCenterService.updateExtensionStatus(id, status)

      return ApiResponse.success(res, null, 'æ›´æ–°åˆ†æœºçŠ¶æ€æˆåŠŸ')
    } catch (error) {
      console.error('âŒ æ›´æ–°åˆ†æœºçŠ¶æ€å¤±è´¥:', error)
      return ApiResponse.error(res, 'æ›´æ–°åˆ†æœºçŠ¶æ€å¤±è´¥', 'ERROR')
    }
  }

  async resetExtension(req: Request, res: Response) {
    try {
      const { id } = req.params

      // è¿™é‡Œå¯ä»¥æ·»åŠ é‡ç½®åˆ†æœºçš„é€»è¾‘
      console.log(`ğŸ”„ é‡ç½®åˆ†æœº: ${id}`)

      return ApiResponse.success(res, null, 'é‡ç½®åˆ†æœºæˆåŠŸ')
    } catch (error) {
      console.error('âŒ é‡ç½®åˆ†æœºå¤±è´¥:', error)
      return ApiResponse.error(res, 'é‡ç½®åˆ†æœºå¤±è´¥', 'ERROR')
    }
  }

  /**
   * è”ç³»äººç®¡ç†
   */
  async getContacts(req: Request, res: Response) {
    try {
      const userId = (req as any).user.id
      const {
        page = 1,
        pageSize = 20,
        search,
        tags
      } = req.query

      const contactsData = await callCenterService.getContacts({
        page: Number(page),
        pageSize: Number(pageSize),
        search: search as string,
        tags: tags ? (tags as string).split(',') : undefined,
        userId
      })

      return ApiResponse.success(res, contactsData, 'è·å–è”ç³»äººåˆ—è¡¨æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–è”ç³»äººåˆ—è¡¨å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–è”ç³»äººåˆ—è¡¨å¤±è´¥', 'ERROR')
    }
  }

  async createContact(req: Request, res: Response) {
    try {
      const userId = (req as any).user.id
      const contactData = req.body

      // è¿™é‡Œå¯ä»¥æ·»åŠ åˆ›å»ºè”ç³»äººçš„é€»è¾‘
      const contact = {
        id: Date.now(),
        ...contactData,
        createdBy: userId
      }

      return ApiResponse.success(res, contact, 'åˆ›å»ºè”ç³»äººæˆåŠŸ')
    } catch (error) {
      console.error('âŒ åˆ›å»ºè”ç³»äººå¤±è´¥:', error)
      return ApiResponse.error(res, 'åˆ›å»ºè”ç³»äººå¤±è´¥', 'ERROR')
    }
  }

  async updateContact(req: Request, res: Response) {
    try {
      const { id } = req.params
      const updateData = req.body

      // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´æ–°è”ç³»äººçš„é€»è¾‘
      console.log(`âœï¸ æ›´æ–°è”ç³»äºº: ${id}`)

      return ApiResponse.success(res, null, 'æ›´æ–°è”ç³»äººæˆåŠŸ')
    } catch (error) {
      console.error('âŒ æ›´æ–°è”ç³»äººå¤±è´¥:', error)
      return ApiResponse.error(res, 'æ›´æ–°è”ç³»äººå¤±è´¥', 'ERROR')
    }
  }

  async deleteContact(req: Request, res: Response) {
    try {
      const { id } = req.params

      // è¿™é‡Œå¯ä»¥æ·»åŠ åˆ é™¤è”ç³»äººçš„é€»è¾‘
      console.log(`ğŸ—‘ï¸ åˆ é™¤è”ç³»äºº: ${id}`)

      return ApiResponse.success(res, null, 'åˆ é™¤è”ç³»äººæˆåŠŸ')
    } catch (error) {
      console.error('âŒ åˆ é™¤è”ç³»äººå¤±è´¥:', error)
      return ApiResponse.error(res, 'åˆ é™¤è”ç³»äººå¤±è´¥', 'ERROR')
    }
  }

  async searchContacts(req: Request, res: Response) {
    try {
      const { q } = req.query

      // è¿™é‡Œå¯ä»¥æ·»åŠ æœç´¢è”ç³»äººçš„é€»è¾‘
      const contacts = []

      return ApiResponse.success(res, contacts, 'æœç´¢è”ç³»äººæˆåŠŸ')
    } catch (error) {
      console.error('âŒ æœç´¢è”ç³»äººå¤±è´¥:', error)
      return ApiResponse.error(res, 'æœç´¢è”ç³»äººå¤±è´¥', 'ERROR')
    }
  }

  /**
   * å®æ—¶çŠ¶æ€
   */
  async getRealTimeStatus(req: Request, res: Response) {
    try {
      // è¿™é‡Œå¯ä»¥æ·»åŠ è·å–å®æ—¶çŠ¶æ€çš„é€»è¾‘
      const realTimeData = {
        activeCalls: 3,
        availableExtensions: 5,
        queueLength: 0,
        averageWaitTime: 0,
        systemLoad: 0.3
      }

      return ApiResponse.success(res, realTimeData, 'è·å–å®æ—¶çŠ¶æ€æˆåŠŸ')
    } catch (error) {
      console.error('âŒ è·å–å®æ—¶çŠ¶æ€å¤±è´¥:', error)
      return ApiResponse.error(res, 'è·å–å®æ—¶çŠ¶æ€å¤±è´¥', 'ERROR')
    }
  }
}

export default new CallCenterController()