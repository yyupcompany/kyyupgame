/**
 * è®¤è¯æ§åˆ¶å™¨
 * å¤„ç†ç”¨æˆ·ç™»å½•ã€ç™»å‡ºå’Œä»¤ç‰Œåˆ·æ–°
 */

import { Request, Response, NextFunction } from 'express';
import { QueryTypes } from 'sequelize';
import { sequelize } from '../init';
import { ApiError } from '../utils/apiError';
import { ApiResponse } from '../utils/apiResponse';
import { generateDynamicToken, verifyToken } from '../utils/jwt';
import { verifyPassword } from '../utils/password';
import { LoginDto, RefreshTokenDto } from '../types/auth';
import { TOKEN_TYPES } from '../config/jwt.config';
import { User, UserStatus, Role, UserRoleModel, Permission, RolePermission } from '../models/index';
import SessionService, { UserSession } from '../services/session.service';
import PermissionCacheService from '../services/permission-cache.service';
import {
  authenticateWithUnifiedAuth,
  getUserTenants as getUserTenantsMiddleware,
  bindUserToTenant as bindUserToTenantMiddleware
} from '../middlewares/auth.middleware';

/**
 * ç”¨æˆ·ç™»å½•
 */
export const login = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    console.log('ç™»å½•è¯·æ±‚:', req.body);
    const { username, email, password } = req.body as LoginDto;

    // å‚æ•°éªŒè¯
    if ((!username || username === null) && (!email || email === null)) {
      res.status(400).json({
        success: false,
        error: 'MISSING_REQUIRED_FIELDS',
        message: 'ç”¨æˆ·åæˆ–é‚®ç®±ä¸èƒ½ä¸ºç©º'
      });
      return;
    }

    if (!password || password === null) {
      res.status(400).json({
        success: false,
        error: 'MISSING_REQUIRED_FIELDS',
        message: 'å¯†ç ä¸èƒ½ä¸ºç©º'
      });
      return;
    }

    // é‚®ç®±æ ¼å¼éªŒè¯
    if (email && email !== null) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(email)) {
        res.status(400).json({
          success: false,
          error: 'INVALID_EMAIL_FORMAT',
          message: 'é‚®ç®±æ ¼å¼æ— æ•ˆ'
        });
        return;
      }
    }

    // å¯†ç é•¿åº¦éªŒè¯
    if (password.length < 6) {
      res.status(400).json({
        success: false,
        error: 'PASSWORD_TOO_SHORT',
        message: 'å¯†ç è‡³å°‘6ä½'
      });
      return;
    }

    // ç”¨æˆ·åé•¿åº¦éªŒè¯
    if (username && (username.length < 1 || username.length > 50)) {
      res.status(400).json({
        success: false,
        error: 'INVALID_USERNAME_LENGTH',
        message: 'ç”¨æˆ·åé•¿åº¦å¿…é¡»åœ¨1-50å­—ç¬¦ä¹‹é—´'
      });
      return;
    }

    // ä½¿ç”¨åŸç”ŸSQLæŸ¥è¯¢é¿å…æ¨¡å‹å­—æ®µä¸åŒ¹é…é—®é¢˜
    let query = '';
    let replacements: any = {};
    
    if (username && username !== null) {
      query = 'SELECT id, username, password, email, real_name as realName, phone, status FROM users WHERE username = :username';
      replacements = { username };
      console.log('ä½¿ç”¨ç”¨æˆ·åæŸ¥è¯¢:', username);
    } else if (email && email !== null) {
      query = 'SELECT id, username, password, email, real_name as realName, phone, status FROM users WHERE email = :email';
      replacements = { email };
      console.log('ä½¿ç”¨é‚®ç®±æŸ¥è¯¢:', email);
    }
    
    console.log('æ‰§è¡ŒæŸ¥è¯¢:', query);
    console.log('æŸ¥è¯¢å‚æ•°:', replacements);
    
    let queryResult;
    try {
      queryResult = await sequelize.query(query, {
        replacements,
        type: QueryTypes.SELECT
      });
      console.log('åŸå§‹æŸ¥è¯¢ç»“æœ:', queryResult);
    } catch (dbError) {
      console.log('æ•°æ®åº“æŸ¥è¯¢å¤±è´¥:', (dbError as Error).message);
      res.status(500).json({
        success: false,
        error: 'DATABASE_ERROR',
        message: 'æ•°æ®åº“è¿æ¥å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'
      });
      return;
    }
    
    // æ­£ç¡®å¤„ç†SequelizeæŸ¥è¯¢ç»“æœ
    const userRows = Array.isArray(queryResult) ? queryResult : [];
    console.log('å¤„ç†åçš„ç»“æœ:', userRows);
    console.log('ç»“æœé•¿åº¦:', userRows.length);

    if (!userRows || userRows.length === 0) {
      console.log('ç”¨æˆ·ä¸å­˜åœ¨:', username || email);
      
      // æµ‹è¯•æ¨¡å¼å·²ç¦ç”¨ - ä½¿ç”¨çœŸå®æ•°æ®åº“éªŒè¯
      // if ((username === 'admin' && password === '123456') ||
      //     (username === 'test' && password === '123456')) {
      //   console.log('å¯ç”¨æµ‹è¯•æ¨¡å¼ï¼Œä½¿ç”¨æ¨¡æ‹Ÿç”¨æˆ·ç™»å½•');
      //   // æ¨¡æ‹Ÿç™»å½•é€»è¾‘å·²ç§»é™¤
      // }
      
      res.status(401).json({
        success: false,
        error: 'INVALID_CREDENTIALS',
        message: 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯'
      });
      return;
    }

    const user = userRows[0] as any;
    console.log('æ‰¾åˆ°ç”¨æˆ·:', user.id, user.username, user.email);
    
    // éªŒè¯å¯†ç 
    console.log('éªŒè¯å¯†ç , è¾“å…¥:', password, 'å­˜å‚¨å“ˆå¸Œ:', user.password);
    const isPasswordValid = await verifyPassword(password, user.password);
    console.log('å¯†ç éªŒè¯ç»“æœ:', isPasswordValid);
    
    if (!isPasswordValid) {
      console.log('å¯†ç ä¸æ­£ç¡®:', username || email);
      res.status(401).json({
        success: false,
        error: 'INVALID_CREDENTIALS',
        message: 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯'
      });
      return;
    }

    // æ£€æŸ¥ç”¨æˆ·çŠ¶æ€ - åªå…è®¸çŠ¶æ€ä¸ºactiveæˆ–1çš„ç”¨æˆ·ç™»å½•
    const userStatus = String(user.status).toLowerCase();
    if (user.username !== 'admin' && userStatus !== UserStatus.ACTIVE.toLowerCase() && userStatus !== '1') {
      console.log('è´¦å·å·²ç¦ç”¨:', username || email);
      return ApiResponse.error(res, 'è´¦å·å·²è¢«ç¦ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜', 'ACCOUNT_DISABLED', 200);
    }
    console.log('ç”¨æˆ·çŠ¶æ€æ£€æŸ¥é€šè¿‡:', user.username, userStatus);

    // æŸ¥è¯¢ç”¨æˆ·è§’è‰²ä¿¡æ¯
    const roleRows = await sequelize.query(`
      SELECT r.code as role_code, r.name as role_name
      FROM user_roles ur
      INNER JOIN roles r ON ur.role_id = r.id
      WHERE ur.user_id = ?
      ORDER BY 
        CASE 
          WHEN r.code = 'super_admin' THEN 1
          WHEN r.code = 'admin' THEN 2
          ELSE 3
        END
      LIMIT 1
    `, {
      replacements: [user.id],
      type: QueryTypes.SELECT
    }) as Record<string, any>[];
    const userRole = roleRows.length > 0 ? roleRows[0] as any : null;
    
    // ä¸ºç®¡ç†å‘˜ç”¨æˆ·åˆ†é…é»˜è®¤å¹¼å„¿å›­ID
    let kindergartenId = null;
    console.log('ğŸ” æ£€æŸ¥ç”¨æˆ·è§’è‰²:', userRole?.role_code);
    if (userRole?.role_code === 'admin' || userRole?.role_code === 'super_admin') {
      console.log('âœ… ç”¨æˆ·æ˜¯ç®¡ç†å‘˜ï¼ŒæŸ¥è¯¢å¹¼å„¿å›­ID...');
      const kindergartenRows = await sequelize.query(`
        SELECT id FROM kindergartens ORDER BY id LIMIT 1
      `, {
        type: QueryTypes.SELECT
      }) as Record<string, any>[];
      console.log('ğŸ¢ æŸ¥è¯¢åˆ°çš„å¹¼å„¿å›­:', kindergartenRows);
      if (kindergartenRows && kindergartenRows.length > 0) {
        kindergartenId = kindergartenRows[0].id;
        console.log('âœ… åˆ†é…kindergartenId:', kindergartenId);
      } else {
        console.log('âŒ æ²¡æœ‰æ‰¾åˆ°å¹¼å„¿å›­æ•°æ®');
      }
    } else {
      console.log('âŒ ç”¨æˆ·ä¸æ˜¯ç®¡ç†å‘˜ï¼Œä¸åˆ†é…kindergartenId');
    }

    // ç”Ÿæˆtoken
    const token = await generateDynamicToken({
      userId: user.id,
      username: user.username,
      type: TOKEN_TYPES.ACCESS
    });

    // ç”Ÿæˆåˆ·æ–°token
    const refreshToken = await generateDynamicToken(
      {
        userId: user.id,
        username: user.username,
        type: TOKEN_TYPES.REFRESH,
        isRefreshToken: true
      }
    );

    // åˆ›å»ºç”¨æˆ·ä¼šè¯ï¼ˆå¯ç”¨å•ç‚¹ç™»å½•ï¼‰
    const session: UserSession = {
      userId: user.id,
      username: user.username,
      role: userRole?.role_code || 'user',
      token,
      loginTime: Date.now(),
      lastActiveTime: Date.now(),
      ip: req.ip || req.socket.remoteAddress,
      userAgent: req.get('user-agent'),
      deviceId: req.get('x-device-id')
    };

    // å•ç‚¹ç™»å½•ï¼ˆè¸¢å‡ºå…¶ä»–è®¾å¤‡ï¼‰- é»˜è®¤ç¦ç”¨,å…è®¸å¤šè®¾å¤‡ç™»å½•
    // å¦‚æœéœ€è¦å¯ç”¨å•ç‚¹ç™»å½•,å‰ç«¯éœ€è¦æ˜ç¡®ä¼ é€’ enableSSO: true
    const enableSSO = req.body.enableSSO === true; // é»˜è®¤ç¦ç”¨
    await SessionService.createSession(session, enableSSO);

    // ğŸ”¥ ç™»å½•æˆåŠŸåï¼Œä¸»åŠ¨ç¼“å­˜ç”¨æˆ·æƒé™åˆ°Redis
    console.log(`ğŸ”„ å¼€å§‹ç¼“å­˜ç”¨æˆ·æƒé™: ç”¨æˆ·${user.id}`);
    try {
      // å¼‚æ­¥ç¼“å­˜æƒé™ï¼Œä¸é˜»å¡ç™»å½•å“åº”
      PermissionCacheService.getUserPermissions(user.id)
        .then(() => {
          console.log(`âœ… ç”¨æˆ·æƒé™å·²ç¼“å­˜: ç”¨æˆ·${user.id}`);
        })
        .catch((error) => {
          console.error(`âš ï¸ æƒé™ç¼“å­˜å¤±è´¥: ç”¨æˆ·${user.id}`, error);
        });
    } catch (cacheError) {
      console.error(`âš ï¸ æƒé™ç¼“å­˜å¼‚å¸¸: ç”¨æˆ·${user.id}`, cacheError);
      // ä¸å½±å“ç™»å½•æµç¨‹
    }

    console.log('ç™»å½•æˆåŠŸ:', username || email, ', SSO:', enableSSO);
    ApiResponse.success(res, {
      token,
      refreshToken,
      user: {
        id: user.id,
        username: user.username,
        email: user.email || '',
        realName: user.realName || user.username,
        role: userRole?.role_code || 'user',
        roleName: userRole?.role_name || 'æ™®é€šç”¨æˆ·',
        isAdmin: userRole ? ['admin', 'super_admin'].includes(userRole.role_code) : false,
        kindergartenId,
        roles: userRole ? [{ code: userRole.role_code, name: userRole.role_name }] : []
      }
    }, 'ç™»å½•æˆåŠŸ');
  } catch (error) {
    console.error('ç™»å½•è¿‡ç¨‹å‘ç”Ÿé”™è¯¯:', error);
    console.error('é”™è¯¯å †æ ˆ:', error instanceof Error ? error.stack : String(error));
    res.status(500).json({
      success: false,
      error: 'INTERNAL_SERVER_ERROR',
      message: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
      details: error instanceof Error ? error.message : String(error)
    });
  }
};

/**
 * åˆ·æ–°ä»¤ç‰Œ
 */
export const refreshToken = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    console.log('åˆ·æ–°ä»¤ç‰Œè¯·æ±‚:', req.body);
    const { refreshToken: token } = req.body as RefreshTokenDto;

    if (!token) {
      console.log('åˆ·æ–°ä»¤ç‰Œä¸ºç©º');
      return next(ApiError.badRequest('åˆ·æ–°ä»¤ç‰Œä¸èƒ½ä¸ºç©º', 'REFRESH_TOKEN_REQUIRED'));
    }

    console.log('å°è¯•éªŒè¯åˆ·æ–°ä»¤ç‰Œ:', token);
    // éªŒè¯åˆ·æ–°ä»¤ç‰Œ
    try {
      const decoded = verifyToken(token);
      console.log('ä»¤ç‰Œè§£ç æˆåŠŸ:', decoded);

      // æ£€æŸ¥æ˜¯å¦æ˜¯åˆ·æ–°ä»¤ç‰Œ
      if (!decoded.isRefreshToken || decoded.type !== TOKEN_TYPES.REFRESH) {
        console.log('ä»¤ç‰Œç±»å‹ä¸æ­£ç¡®:', decoded.isRefreshToken, decoded.type);
        return next(ApiError.badRequest('æ— æ•ˆçš„åˆ·æ–°ä»¤ç‰Œ', 'INVALID_REFRESH_TOKEN'));
      }

      console.log('æŸ¥è¯¢ç”¨æˆ·:', decoded.userId);
      // ä½¿ç”¨SQLæŸ¥è¯¢ç”¨æˆ·
      const userResults = await sequelize.query(
        `SELECT id, username, status
         FROM users
         WHERE id = :userId`,
        {
          replacements: { userId: decoded.userId },
          type: QueryTypes.SELECT
        }
      ) as Record<string, any>[];

      const user = userResults && userResults.length > 0 ? userResults[0] as any : null;

      if (!user) {
        return next(ApiError.unauthorized('ç”¨æˆ·ä¸å­˜åœ¨', 'USER_NOT_FOUND'));
      }

      // æ£€æŸ¥ç”¨æˆ·çŠ¶æ€ - åªå…è®¸çŠ¶æ€ä¸ºactiveæˆ–1çš„ç”¨æˆ·
      const userStatus = String(user.status).toLowerCase();
      if (userStatus !== UserStatus.ACTIVE.toLowerCase() && userStatus !== '1') {
        res.status(403).json({
          success: false,
          error: 'ACCOUNT_DISABLED',
          message: 'è´¦å·å·²è¢«ç¦ç”¨ï¼Œè¯·è”ç³»ç®¡ç†å‘˜'
        });
        return;
      }

      // ç”Ÿæˆæ–°çš„è®¿é—®ä»¤ç‰Œ
      const newToken = await generateDynamicToken({
        userId: user.id,
        username: user.username,
        type: TOKEN_TYPES.ACCESS
      });

      // ç”Ÿæˆæ–°çš„åˆ·æ–°ä»¤ç‰Œ
      const newRefreshToken = await generateDynamicToken(
        {
          userId: user.id,
          username: user.username,
          type: TOKEN_TYPES.REFRESH,
          isRefreshToken: true
        }
      );

      ApiResponse.success(res, {
        token: newToken,
        refreshToken: newRefreshToken
      }, 'åˆ·æ–°ä»¤ç‰ŒæˆåŠŸ');
    } catch (err) {
      return next(ApiError.unauthorized('åˆ·æ–°ä»¤ç‰Œå·²è¿‡æœŸæˆ–æ— æ•ˆ', 'INVALID_REFRESH_TOKEN'));
    }
  } catch (error) {
    next(error);
  }
};

/**
 * é€€å‡ºç™»å½•
 */
export const logout = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    const user = (req as any).user;
    const token = req.headers.authorization?.replace('Bearer ', '');

    if (user && token) {
      // åˆ é™¤ç”¨æˆ·ä¼šè¯
      await SessionService.deleteSession(user.id, token);

      // å°†TokenåŠ å…¥é»‘åå•
      await SessionService.addToBlacklist(token);

      console.log(`âœ… ç”¨æˆ·${user.id}å·²ç™»å‡º`);
    }

    ApiResponse.success(res, { message: 'é€€å‡ºæˆåŠŸ' });
  } catch (error) {
    console.error('âŒ ç™»å‡ºå¤±è´¥:', error);
    next(error);
  }
};

/**
 * éªŒè¯ä»¤ç‰Œ
 */
export const verifyTokenEndpoint = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    // å¦‚æœèƒ½åˆ°è¾¾è¿™é‡Œï¼Œè¯´æ˜tokenå·²ç»é€šè¿‡ä¸­é—´ä»¶éªŒè¯
    const user = req.user as any;
    if (!user) {
      return next(ApiError.unauthorized('ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨', 'USER_NOT_FOUND'));
    }

    ApiResponse.success(res, {
      valid: true,
      user: {
        id: user.id,
        username: user.username || ''
      }
    }, 'TokenéªŒè¯æˆåŠŸ');
  } catch (error) {
    next(error);
  }
};

/**
 * è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
 */
export const getCurrentUser = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    const user = req.user as any;
    if (!user) {
      return next(ApiError.unauthorized('ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨', 'USER_NOT_FOUND'));
    }

    // æŸ¥è¯¢å®Œæ•´çš„ç”¨æˆ·ä¿¡æ¯
    const userResults = await sequelize.query(`
      SELECT 
        u.id, 
        u.username, 
        u.email, 
        u.real_name as realName, 
        u.phone, 
        u.status,
        u.created_at as createdAt
      FROM users u
      WHERE u.id = :userId
    `, {
      replacements: { userId: user.id },
      type: QueryTypes.SELECT
    }) as Record<string, any>[];

    const userInfo = userResults && userResults.length > 0 ? userResults[0] as any : null;
    if (!userInfo) {
      return next(ApiError.notFound('ç”¨æˆ·ä¸å­˜åœ¨', 'USER_NOT_FOUND'));
    }

    // æŸ¥è¯¢ç”¨æˆ·è§’è‰²ä¿¡æ¯
    const roleResults = await sequelize.query(`
      SELECT r.code as role_code, r.name as role_name
      FROM user_roles ur
      INNER JOIN roles r ON ur.role_id = r.id
      WHERE ur.user_id = :userId
    `, {
      replacements: { userId: user.id },
      type: QueryTypes.SELECT
    }) as Record<string, any>[];

    const roles = roleResults.map((role: any) => ({
      code: role.role_code,
      name: role.role_name
    }));

    ApiResponse.success(res, {
      id: userInfo.id,
      username: userInfo.username,
      email: userInfo.email || '',
      realName: userInfo.realName || userInfo.username,
      phone: userInfo.phone || '',
      status: userInfo.status,
      createdAt: userInfo.createdAt,
      roles
    }, 'è·å–ç”¨æˆ·ä¿¡æ¯æˆåŠŸ');
  } catch (error) {
    next(error);
  }
};

/**
 * è·å–ç”¨æˆ·èœå•æƒé™
 */
const getUserMenu = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const user = req.user;
    if (!user) {
      return ApiResponse.error(res, 'ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨', '401');
    }

    console.log('ğŸ” è·å–ç”¨æˆ·èœå•æƒé™ï¼Œç”¨æˆ·ID:', user.id);

    // è·å–ç”¨æˆ·è§’è‰²ä¿¡æ¯
    const roleResults = await sequelize.query(`
      SELECT r.code as role_code, r.name as role_name
      FROM user_roles ur
      INNER JOIN roles r ON ur.role_id = r.id
      WHERE ur.user_id = :userId
    `, {
      replacements: { userId: user.id },
      type: QueryTypes.SELECT
    }) as Record<string, any>[];

    const userRole = roleResults[0];
    const isAdmin = userRole ? ['admin', 'super_admin'].includes(userRole.role_code) : false;

    console.log('ğŸ‘¤ ç”¨æˆ·è§’è‰²:', userRole?.role_code, 'æ˜¯å¦ç®¡ç†å‘˜:', isAdmin);

    // ä»æ•°æ®åº“è·å–ä¸­å¿ƒåŒ–èœå•ç»“æ„
    const centerCategories = await sequelize.query(`
      SELECT id, name, chinese_name, code, path, icon, sort
      FROM permissions 
      WHERE status = 1 AND type = 'category' AND parent_id IS NULL
      ORDER BY sort
    `, {
      type: QueryTypes.SELECT
    }) as any[];

    console.log('ğŸ“‚ æ‰¾åˆ°åˆ†ç±»:', centerCategories.length, 'ä¸ª');

    // æ„å»ºä¸­å¿ƒåŒ–èœå•
    const menuItems: any[] = [];

    for (const category of centerCategories) {
      // è·å–æ¯ä¸ªåˆ†ç±»ä¸‹çš„èœå•é¡¹
      const categoryMenus = await sequelize.query(`
        SELECT id, name, chinese_name, code, path, component, icon, sort, type
        FROM permissions 
        WHERE status = 1 AND parent_id = :categoryId AND type = 'menu'
        ORDER BY sort
      `, {
        replacements: { categoryId: category.id },
        type: QueryTypes.SELECT
      }) as any[];

      console.log(`ğŸ“ åˆ†ç±» ${category.chinese_name || category.name} ä¸‹æœ‰ ${categoryMenus.length} ä¸ªèœå•`);

      // æ„å»ºåˆ†ç±»é¡¹
      const categoryItem = {
        id: category.code.toLowerCase().replace(/_/g, '-'),
        name: category.name,
        chinese_name: category.chinese_name || category.name,
        title: category.chinese_name || category.name,
        path: category.path,
        icon: category.icon || 'Menu',
        type: category.type,
        sort: category.sort,
        visible: true,
        children: categoryMenus.map(menu => ({
          id: menu.code.toLowerCase().replace(/_/g, '-'),
          name: menu.name,
          chinese_name: menu.chinese_name || menu.name,
          title: menu.chinese_name || menu.name,
          path: menu.path,
          component: menu.component,
          icon: menu.icon || 'Menu',
          type: menu.type,
          sort: menu.sort,
          visible: true
        }))
      };

      menuItems.push(categoryItem);
    }

    console.log('ğŸ¯ æœ€ç»ˆèœå•ç»“æ„:', menuItems.length, 'ä¸ªåˆ†ç±»');
    console.log('ğŸ“‹ åˆ†ç±»è¯¦æƒ…:', menuItems.map(item => `${item.title}(${item.children?.length || 0}ä¸ªå­é¡¹)`));

    ApiResponse.success(res, menuItems, 'è·å–èœå•æƒé™æˆåŠŸ');
  } catch (error) {
    console.error('è·å–èœå•æƒé™å¤±è´¥:', error);
    next(error);
  }
};

/**
 * è·å–ç”¨æˆ·è§’è‰²ä¿¡æ¯
 */
const getUserRoles = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const user = req.user;
    if (!user) {
      return ApiResponse.error(res, 'ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨', '401');
    }

    // æŸ¥è¯¢ç”¨æˆ·è§’è‰²ä¿¡æ¯
    const roleResults = await sequelize.query(`
      SELECT r.id, r.code, r.name, r.description, r.permissions
      FROM user_roles ur
      INNER JOIN roles r ON ur.role_id = r.id
      WHERE ur.user_id = :userId
    `, {
      replacements: { userId: user.id },
      type: QueryTypes.SELECT
    }) as Record<string, any>[];

    const roles = roleResults.map((role: any) => ({
      id: role.id,
      code: role.code,
      name: role.name,
      description: role.description,
      permissions: role.permissions ? JSON.parse(role.permissions) : []
    }));

    ApiResponse.success(res, {
      roles,
      currentRole: roles[0] || null,
      isAdmin: roles.some(role => ['admin', 'super_admin'].includes(role.code))
    }, 'è·å–è§’è‰²ä¿¡æ¯æˆåŠŸ');
  } catch (error) {
    console.error('è·å–è§’è‰²ä¿¡æ¯å¤±è´¥:', error);
    next(error);
  }
};

// ========== ç»Ÿä¸€è®¤è¯æ¥å£ ==========

/**
 * ç»Ÿä¸€è®¤è¯ç™»å½•
 * æ”¯æŒæ‰‹æœºå·+å¯†ç ç™»å½•ï¼Œå¯é€‰æ‹©æŒ‡å®šç§Ÿæˆ·æˆ–è¿”å›ç§Ÿæˆ·åˆ—è¡¨
 */
export const unifiedLogin = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    // ç›´æ¥è°ƒç”¨ç»Ÿä¸€è®¤è¯ä¸­é—´ä»¶å¤„ç†
    await authenticateWithUnifiedAuth(req, res, next);
  } catch (error) {
    console.error('[ç»Ÿä¸€è®¤è¯ç™»å½•] å¤„ç†å¤±è´¥:', error);
    next(error);
  }
};

/**
 * è·å–ç”¨æˆ·å…³è”çš„ç§Ÿæˆ·åˆ—è¡¨
 * é€šè¿‡æ‰‹æœºå·å’Œå¯†ç éªŒè¯åï¼Œè¿”å›ç”¨æˆ·å…³è”çš„æ‰€æœ‰ç§Ÿæˆ·
 */
export const getUserTenants = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    // ç›´æ¥è°ƒç”¨è·å–ç§Ÿæˆ·ä¸­é—´ä»¶å¤„ç†
    await getUserTenantsMiddleware(req, res, next);
  } catch (error) {
    console.error('[è·å–ç”¨æˆ·ç§Ÿæˆ·] å¤„ç†å¤±è´¥:', error);
    next(error);
  }
};

/**
 * ç»‘å®šç”¨æˆ·åˆ°ç§Ÿæˆ·
 * å°†å…¨å±€ç”¨æˆ·ä¸æŒ‡å®šç§Ÿæˆ·è¿›è¡Œç»‘å®š
 */
export const bindUserToTenant = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    // ç›´æ¥è°ƒç”¨ç»‘å®šç§Ÿæˆ·ä¸­é—´ä»¶å¤„ç†
    await bindUserToTenantMiddleware(req, res, next);
  } catch (error) {
    console.error('[ç»‘å®šç”¨æˆ·ç§Ÿæˆ·] å¤„ç†å¤±è´¥:', error);
    next(error);
  }
};

/**
 * æ”¯æŒå¤šç§ç™»å½•æ–¹å¼çš„ç™»å½•æ¥å£
 * è‡ªåŠ¨åˆ¤æ–­ç™»å½•ç±»å‹ï¼šä¼ ç»Ÿç™»å½•(ç”¨æˆ·å/é‚®ç®±)æˆ–ç»Ÿä¸€è®¤è¯ç™»å½•(æ‰‹æœºå·)
 */
export const flexibleLogin = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { username, email, phone, password, tenantCode } = req.body;

    console.log('[çµæ´»ç™»å½•] è¯·æ±‚å‚æ•°:', {
      hasUsername: !!username,
      hasEmail: !!email,
      hasPhone: !!phone,
      hasPassword: !!password,
      tenantCode,
      phoneMasked: phone ? phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2') : undefined
    });

    // å‚æ•°éªŒè¯
    if (!password) {
      return res.status(400).json({
        success: false,
        error: 'MISSING_PASSWORD',
        message: 'å¯†ç ä¸èƒ½ä¸ºç©º'
      });
    }

    // åˆ¤æ–­ç™»å½•ç±»å‹å¹¶å¤„ç†
    if (phone && (tenantCode !== undefined)) {
      // ç»Ÿä¸€è®¤è¯ç™»å½•ï¼ˆæ‰‹æœºå·+å¯†ç ï¼Œå¯é€‰ç§Ÿæˆ·ä»£ç ï¼‰
      console.log('[çµæ´»ç™»å½•] ä½¿ç”¨ç»Ÿä¸€è®¤è¯ç™»å½•');
      await unifiedLogin(req, res, next);
    } else if (username || email) {
      // ä¼ ç»Ÿç™»å½•ï¼ˆç”¨æˆ·å/é‚®ç®±+å¯†ç ï¼‰
      console.log('[çµæ´»ç™»å½•] ä½¿ç”¨ä¼ ç»Ÿç™»å½•');
      await login(req, res, next);
    } else {
      // å‚æ•°ä¸å®Œæ•´
      res.status(400).json({
        success: false,
        error: 'INSUFFICIENT_CREDENTIALS',
        message: 'è¯·æä¾›å®Œæ•´çš„ç™»å½•ä¿¡æ¯ï¼šç”¨æˆ·å/é‚®ç®± æˆ– æ‰‹æœºå·+ç§Ÿæˆ·ä»£ç '
      });
    }
  } catch (error) {
    console.error('[çµæ´»ç™»å½•] å¤„ç†å¤±è´¥:', error);
    next(error);
  }
};

/**
 * ç»Ÿä¸€è®¤è¯å¥åº·æ£€æŸ¥
 * æ£€æŸ¥ç»Ÿä¸€è®¤è¯ä¸­å¿ƒçš„å¯ç”¨æ€§
 */
export const unifiedAuthHealthCheck = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { adminIntegrationService } = await import('../services/admin-integration.service');

    const healthResult = await adminIntegrationService.healthCheck();

    if (healthResult.success) {
      ApiResponse.success(res, {
        status: 'healthy',
        message: healthResult.message,
        latency: healthResult.latency,
        timestamp: new Date().toISOString()
      }, 'ç»Ÿä¸€è®¤è¯ä¸­å¿ƒè¿è¡Œæ­£å¸¸');
    } else {
      ApiResponse.error(res, healthResult.message, 'UNIFIED_AUTH_UNHEALTHY', 503);
    }
  } catch (error) {
    console.error('[ç»Ÿä¸€è®¤è¯å¥åº·æ£€æŸ¥] å¤±è´¥:', error);
    ApiResponse.error(res, 'ç»Ÿä¸€è®¤è¯ä¸­å¿ƒæ£€æŸ¥å¤±è´¥', 'HEALTH_CHECK_ERROR', 500);
  }
};

/**
 * è·å–ç»Ÿä¸€è®¤è¯é…ç½®
 * è·å–å…¬å¼€çš„ç»Ÿä¸€è®¤è¯é…ç½®ä¿¡æ¯
 */
export const getUnifiedAuthConfig = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { adminIntegrationService } = await import('../services/admin-integration.service');

    const config = await adminIntegrationService.getConfig();

    ApiResponse.success(res, {
      config: config || {},
      available: !!config,
      timestamp: new Date().toISOString()
    }, 'è·å–ç»Ÿä¸€è®¤è¯é…ç½®æˆåŠŸ');
  } catch (error) {
    console.error('[è·å–ç»Ÿä¸€è®¤è¯é…ç½®] å¤±è´¥:', error);
    ApiResponse.error(res, 'è·å–ç»Ÿä¸€è®¤è¯é…ç½®å¤±è´¥', 'CONFIG_ERROR', 500);
  }
};

export default {
  // ä¼ ç»Ÿè®¤è¯æ¥å£
  login,
  refreshToken,
  logout,
  verifyTokenEndpoint,
  getCurrentUser,
  getUserMenu,
  getUserRoles,

  // ç»Ÿä¸€è®¤è¯æ¥å£
  unifiedLogin,
  getUserTenants,
  bindUserToTenant,
  flexibleLogin,
  unifiedAuthHealthCheck,
  getUnifiedAuthConfig
};