/**
 * çœŸå®SIPå®¢æˆ·ç«¯æœåŠ¡
 * 
 * ä½¿ç”¨SIP.jså®ç°çœŸå®çš„SIPè¿æ¥å’Œé€šè¯åŠŸèƒ½
 */

import { EventEmitter } from 'events';
import { UserAgent, Inviter, Session, SessionState, URI, Invitation } from 'sip.js';
import { sipConfigService, SIPConfig } from './sip-config.service';

export interface CallSession {
  callId: string;
  phoneNumber: string;
  session: Session;
  startTime: Date;
  status: 'connecting' | 'ringing' | 'answered' | 'ended' | 'failed';
}

export class SIPClientService extends EventEmitter {
  private static instance: SIPClientService;
  private userAgent: UserAgent | null = null;
  private config: SIPConfig | null = null;
  private activeCalls: Map<string, CallSession> = new Map();
  private isConnected: boolean = false;

  private constructor() {
    super();
  }

  static getInstance(): SIPClientService {
    if (!SIPClientService.instance) {
      SIPClientService.instance = new SIPClientService();
    }
    return SIPClientService.instance;
  }

  /**
   * åˆå§‹åŒ–å¹¶è¿æ¥åˆ°SIPæœåŠ¡å™¨
   */
  async connect(): Promise<boolean> {
    try {
      // åŠ è½½SIPé…ç½®
      await sipConfigService.loadConfig();
      this.config = sipConfigService.getConfig();

      if (!this.config) {
        throw new Error('SIPé…ç½®æœªåŠ è½½');
      }

      console.log('ğŸ“ åˆå§‹åŒ–SIPå®¢æˆ·ç«¯...');
      console.log(`   æœåŠ¡å™¨: ${this.config.server_host}:${this.config.server_port}`);
      console.log(`   è´¦å·: ${this.config.username}`);

      // æ„å»ºSIP URI
      const uriString = `sip:${this.config.username}@${this.config.server_host}`;
      const uri = UserAgent.makeURI(uriString);

      if (!uri) {
        throw new Error('æ— æ•ˆçš„SIP URI');
      }

      // åˆ›å»ºUserAgenté…ç½®
      const userAgentOptions = {
        uri,
        transportOptions: {
          server: `ws://${this.config.server_host}:${this.config.server_port}`
        },
        authorizationUsername: this.config.username,
        authorizationPassword: this.config.password,
        sessionDescriptionHandlerFactoryOptions: {
          constraints: {
            audio: true,
            video: false
          }
        },
        delegate: {
          onInvite: (invitation: Invitation) => {
            console.log('ğŸ“ æ”¶åˆ°æ¥ç”µ');
            this.handleIncomingCall(invitation);
          }
        }
      };

      // åˆ›å»ºUserAgent
      this.userAgent = new UserAgent(userAgentOptions);

      // å¯åŠ¨UserAgent
      await this.userAgent.start();

      this.isConnected = true;
      console.log('âœ… SIPå®¢æˆ·ç«¯è¿æ¥æˆåŠŸ');

      // æ›´æ–°æ³¨å†Œæ—¶é—´
      await sipConfigService.updateLastRegisterTime();

      return true;
    } catch (error) {
      console.error('âŒ SIPå®¢æˆ·ç«¯è¿æ¥å¤±è´¥:', error);
      this.isConnected = false;
      throw error;
    }
  }

  /**
   * æ‹¨æ‰“ç”µè¯
   */
  async makeCall(phoneNumber: string): Promise<string> {
    if (!this.userAgent || !this.config) {
      throw new Error('SIPå®¢æˆ·ç«¯æœªåˆå§‹åŒ–');
    }

    if (!this.isConnected) {
      throw new Error('SIPå®¢æˆ·ç«¯æœªè¿æ¥');
    }

    try {
      const callId = `call_${Date.now()}`;
      console.log(`ğŸ“ æ‹¨æ‰“ç”µè¯: ${phoneNumber}`);
      console.log(`   Call ID: ${callId}`);

      // æ„å»ºç›®æ ‡URI
      const targetString = `sip:${phoneNumber}@${this.config.server_host}`;
      const target = UserAgent.makeURI(targetString);
      if (!target) {
        throw new Error('æ— æ•ˆçš„ç”µè¯å·ç ');
      }

      // åˆ›å»ºInviter
      const inviter = new Inviter(this.userAgent, target);

      // åˆ›å»ºé€šè¯ä¼šè¯
      const callSession: CallSession = {
        callId,
        phoneNumber,
        session: inviter,
        startTime: new Date(),
        status: 'connecting'
      };

      this.activeCalls.set(callId, callSession);

      // è®¾ç½®ä¼šè¯çŠ¶æ€ç›‘å¬
      this.setupSessionListeners(callSession);

      // å‘èµ·å‘¼å«
      await inviter.invite();

      console.log('âœ… å‘¼å«å·²å‘èµ·');
      this.emit('call-initiated', { callId, phoneNumber });

      return callId;
    } catch (error) {
      console.error('âŒ æ‹¨æ‰“ç”µè¯å¤±è´¥:', error);
      throw error;
    }
  }

  /**
   * è®¾ç½®ä¼šè¯ç›‘å¬å™¨
   */
  private setupSessionListeners(callSession: CallSession): void {
    const { session, callId, phoneNumber } = callSession;

    // ç›‘å¬ä¼šè¯çŠ¶æ€å˜åŒ–
    session.stateChange.addListener((state: SessionState) => {
      console.log(`ğŸ“ é€šè¯çŠ¶æ€å˜åŒ– (${callId}): ${state}`);

      switch (state) {
        case SessionState.Establishing:
          callSession.status = 'ringing';
          console.log('ğŸ“ æŒ¯é“ƒä¸­...');
          this.emit('call-ringing', { callId, phoneNumber });
          break;

        case SessionState.Established:
          callSession.status = 'answered';
          console.log('âœ… é€šè¯å·²æ¥é€š');
          this.emit('call-answered', { callId, phoneNumber });
          
          // è®¾ç½®éŸ³é¢‘æµå¤„ç†
          this.setupAudioStream(callSession);
          break;

        case SessionState.Terminated:
          callSession.status = 'ended';
          console.log('ğŸ“ é€šè¯å·²ç»“æŸ');
          this.emit('call-ended', { callId, phoneNumber });
          this.activeCalls.delete(callId);
          break;
      }
    });

    // ç›‘å¬ä¼šè¯é”™è¯¯
    session.delegate = {
      onBye: () => {
        console.log('ğŸ“ å¯¹æ–¹æŒ‚æ–­');
        this.emit('call-hangup', { callId, phoneNumber });
      }
    };
  }

  /**
   * è®¾ç½®éŸ³é¢‘æµå¤„ç†
   */
  private setupAudioStream(callSession: CallSession): void {
    const { session, callId } = callSession;

    try {
      // è·å–SessionDescriptionHandler
      const sessionDescriptionHandler = session.sessionDescriptionHandler;
      if (!sessionDescriptionHandler) {
        console.warn('âš ï¸  æ— æ³•è·å–SessionDescriptionHandler');
        return;
      }

      // è·å–PeerConnection
      const peerConnection = (sessionDescriptionHandler as any).peerConnection;
      if (!peerConnection) {
        console.warn('âš ï¸  æ— æ³•è·å–PeerConnection');
        return;
      }

      // ç›‘å¬è¿œç¨‹éŸ³é¢‘æµ
      peerConnection.ontrack = (event: RTCTrackEvent) => {
        console.log('ğŸ¤ æ¥æ”¶åˆ°è¿œç¨‹éŸ³é¢‘æµ');
        const remoteStream = event.streams[0];
        
        // è§¦å‘éŸ³é¢‘æµäº‹ä»¶
        this.emit('audio-stream', {
          callId,
          stream: remoteStream
        });
      };

      console.log('âœ… éŸ³é¢‘æµå¤„ç†å·²è®¾ç½®');
    } catch (error) {
      console.error('âŒ è®¾ç½®éŸ³é¢‘æµå¤±è´¥:', error);
    }
  }

  /**
   * å¤„ç†æ¥ç”µ
   */
  private handleIncomingCall(invitation: Invitation): void {
    const callId = `call_${Date.now()}`;
    const phoneNumber = invitation.remoteIdentity.uri.user || 'unknown';

    console.log(`ğŸ“ æ”¶åˆ°æ¥ç”µ: ${phoneNumber}`);

    const callSession: CallSession = {
      callId,
      phoneNumber,
      session: invitation,
      startTime: new Date(),
      status: 'ringing'
    };

    this.activeCalls.set(callId, callSession);
    this.setupSessionListeners(callSession);

    this.emit('incoming-call', { callId, phoneNumber, invitation });
  }

  /**
   * æ¥å¬æ¥ç”µ
   */
  async answerCall(callId: string): Promise<void> {
    const callSession = this.activeCalls.get(callId);
    if (!callSession) {
      throw new Error('é€šè¯ä¼šè¯ä¸å­˜åœ¨');
    }

    try {
      const invitation = callSession.session as Invitation;
      await invitation.accept();
      console.log('âœ… å·²æ¥å¬æ¥ç”µ');
    } catch (error) {
      console.error('âŒ æ¥å¬æ¥ç”µå¤±è´¥:', error);
      throw error;
    }
  }

  /**
   * æŒ‚æ–­ç”µè¯
   */
  async hangup(callId: string): Promise<void> {
    const callSession = this.activeCalls.get(callId);
    if (!callSession) {
      throw new Error('é€šè¯ä¼šè¯ä¸å­˜åœ¨');
    }

    try {
      await callSession.session.bye();
      console.log('âœ… å·²æŒ‚æ–­ç”µè¯');
      this.activeCalls.delete(callId);
    } catch (error) {
      console.error('âŒ æŒ‚æ–­ç”µè¯å¤±è´¥:', error);
      throw error;
    }
  }

  /**
   * æ–­å¼€SIPè¿æ¥
   */
  async disconnect(): Promise<void> {
    if (this.userAgent) {
      await this.userAgent.stop();
      this.userAgent = null;
      this.isConnected = false;
      console.log('âœ… SIPå®¢æˆ·ç«¯å·²æ–­å¼€');
    }
  }

  /**
   * è·å–è¿æ¥çŠ¶æ€
   */
  isClientConnected(): boolean {
    return this.isConnected;
  }

  /**
   * è·å–æ´»è·ƒé€šè¯
   */
  getActiveCalls(): CallSession[] {
    return Array.from(this.activeCalls.values());
  }

  /**
   * è·å–é€šè¯ä¼šè¯
   */
  getCallSession(callId: string): CallSession | undefined {
    return this.activeCalls.get(callId);
  }
}

// å¯¼å‡ºå•ä¾‹
export const sipClientService = SIPClientService.getInstance();

