/**
 * SIPåè®®æœåŠ¡
 * å¤„ç†SIPè¿æ¥ã€é€šè¯å’Œä¿¡ä»¤
 */

import { EventEmitter } from 'events'
import * as SIP from 'sip.js'

export interface SIPConfig {
  server: string
  port: number
  username: string
  password: string
  extension: string
  domain?: string
}

export interface SIPCall {
  id: string
  direction: 'incoming' | 'outgoing'
  remoteNumber: string
  remoteName?: string
  status: 'ringing' | 'answered' | 'ended' | 'held' | 'transferring'
  startTime: Date
  answerTime?: Date
  endTime?: Date
  session?: any
}

export interface SIPRegistrationStatus {
  registered: boolean
  expires?: number
  server?: string
  reason?: string
}

class SIPService extends EventEmitter {
  private userAgent: any = null
  private config: SIPConfig | null = null
  private sessions: Map<string, any> = new Map()
  private calls: Map<string, SIPCall> = new Map()
  private registrationStatus: SIPRegistrationStatus = {
    registered: false
  }

  /**
   * åˆå§‹åŒ–SIPç”¨æˆ·ä»£ç†
   */
  async initialize(config: SIPConfig): Promise<boolean> {
    try {
      this.config = config
      const domain = config.domain || `${config.server}:${config.port}`

      // åˆ›å»ºSIPç”¨æˆ·ä»£ç†é…ç½®
      const uri = `sip:${config.username}@${domain}`
      const wsServers = [`wss://${config.server}:${config.port + 1}`] // WebSocketç«¯å£é€šå¸¸æ˜¯SIPç«¯å£+1

      const userAgentConfig = {
        uri,
        wsServers,
        authorizationUser: config.username,
        password: config.password,
        displayName: config.extension,
        register: true,
        registerExpires: 600,
        userAgentString: 'Kindergarten-CallCenter/1.0.0',
        sessionDescriptionHandlerFactoryOptions: {
          constraints: {
            audio: true,
            video: false
          },
          iceGatheringTimeout: 2000
        }
      }

      // åˆ›å»ºSIPç”¨æˆ·ä»£ç†
      this.userAgent = new SIP.SimpleUser(new SIP.WebSocketInterface(`wss://${config.server}:${config.port + 1}`), userAgentConfig)

      // ç»‘å®šäº‹ä»¶å¤„ç†å™¨
      this.bindEventHandlers()

      // è¿æ¥åˆ°SIPæœåŠ¡å™¨
      await this.userAgent.connect()

      console.log('ğŸ”— SIPç”¨æˆ·ä»£ç†åˆå§‹åŒ–æˆåŠŸ')
      return true
    } catch (error) {
      console.error('âŒ SIPç”¨æˆ·ä»£ç†åˆå§‹åŒ–å¤±è´¥:', error)
      this.emit('error', { type: 'initialization_failed', error })
      return false
    }
  }

  /**
   * ç»‘å®šSIPäº‹ä»¶å¤„ç†å™¨
   */
  private bindEventHandlers(): void {
    if (!this.userAgent) return

    // æ³¨å†Œäº‹ä»¶
    this.userAgent.delegate = {
      onConnect: () => {
        console.log('ğŸ“ SIPæœåŠ¡å™¨è¿æ¥æˆåŠŸ')
        this.registrationStatus.registered = true
        this.emit('registered', this.registrationStatus)
      },

      onDisconnect: (error?: Error) => {
        console.log('ğŸ“ SIPæœåŠ¡å™¨è¿æ¥æ–­å¼€:', error?.message)
        this.registrationStatus.registered = false
        this.registrationStatus.reason = error?.message
        this.emit('unregistered', this.registrationStatus)
      },

      onRegistered: () => {
        console.log('âœ… SIPæ³¨å†ŒæˆåŠŸ')
        this.registrationStatus.registered = true
        this.emit('registered', this.registrationStatus)
      },

      onUnregistered: (response?: any) => {
        console.log('âŒ SIPæ³¨å†Œå¤±è´¥:', response?.message)
        this.registrationStatus.registered = false
        this.registrationStatus.reason = response?.message
        this.emit('unregistered', this.registrationStatus)
      },

      onInvite: (invitation: any) => {
        console.log('ğŸ”” æ”¶åˆ°æ¥ç”µé‚€è¯·:', invitation.remoteIdentity.uri)
        this.handleIncomingCall(invitation)
      }
    }
  }

  /**
   * å¤„ç†æ¥ç”µé‚€è¯·
   */
  private async handleIncomingCall(invitation: any): Promise<void> {
    try {
      const callId = invitation.request.callId
      const remoteNumber = invitation.remoteIdentity.uri.user
      const remoteName = invitation.remoteIdentity.displayName || remoteNumber

      const call: SIPCall = {
        id: callId,
        direction: 'incoming',
        remoteNumber,
        remoteName,
        status: 'ringing',
        startTime: new Date(),
        session: invitation
      }

      this.calls.set(callId, call)
      this.sessions.set(callId, invitation)

      // å‘å‡ºæ¥ç”µäº‹ä»¶
      this.emit('incoming_call', call)

      // è®¾ç½®é€šè¯äº‹ä»¶å¤„ç†å™¨
      this.setupCallHandlers(invitation, callId)

      console.log('ğŸ“ æ¥ç”µå¤„ç†å®Œæˆ:', callId)
    } catch (error) {
      console.error('âŒ æ¥ç”µå¤„ç†å¤±è´¥:', error)
      invitation.reject()
    }
  }

  /**
   * è®¾ç½®é€šè¯äº‹ä»¶å¤„ç†å™¨
   */
  private setupCallHandlers(session: any, callId: string): void {
    // é€šè¯çŠ¶æ€å˜åŒ–
    session.stateChange.addListener((state: any) => {
      const call = this.calls.get(callId)
      if (!call) return

      switch (state) {
        case 'initial':
          call.status = 'ringing'
          break
        case 'inviting':
        case 'provisional':
          call.status = 'ringing'
          break
        case 'accepted':
          call.status = 'answered'
          call.answerTime = new Date()
          this.emit('call_answered', call)
          break
        case 'terminated':
          call.status = 'ended'
          call.endTime = new Date()
          this.emit('call_ended', call)
          this.calls.delete(callId)
          this.sessions.delete(callId)
          break
      }

      this.emit('call_state_changed', { callId, state, call })
    })

    // DTMFäº‹ä»¶
    session.on('dtmf', (tone: string) => {
      this.emit('dtmf', { callId, tone })
    })

    // éŸ³é¢‘è½¨é“
    session.on('track', (track: MediaStreamTrack) => {
      if (track.kind === 'audio') {
        this.emit('audio_track', { callId, track })
      }
    })
  }

  /**
   * å‘èµ·é€šè¯
   */
  async makeCall(targetNumber: string, options: any = {}): Promise<SIPCall | null> {
    try {
      if (!this.userAgent || !this.config) {
        throw new Error('SIPç”¨æˆ·ä»£ç†æœªåˆå§‹åŒ–')
      }

      if (!this.registrationStatus.registered) {
        throw new Error('SIPæœªæ³¨å†Œåˆ°æœåŠ¡å™¨')
      }

      const targetUri = `sip:${targetNumber}@${this.config.server}`
      const callId = `outgoing_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`

      const call: SIPCall = {
        id: callId,
        direction: 'outgoing',
        remoteNumber: targetNumber,
        status: 'ringing',
        startTime: new Date()
      }

      this.calls.set(callId, call)

      // å‘èµ·é€šè¯
      const session = await this.userAgent.call(targetUri, {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: false
          }
        }
      })

      call.session = session
      this.sessions.set(callId, session)

      // è®¾ç½®äº‹ä»¶å¤„ç†å™¨
      this.setupCallHandlers(session, callId)

      this.emit('outgoing_call', call)
      console.log('ğŸ“ å‘èµ·é€šè¯æˆåŠŸ:', targetNumber)

      return call
    } catch (error) {
      console.error('âŒ å‘èµ·é€šè¯å¤±è´¥:', error)
      this.emit('error', { type: 'call_failed', targetNumber, error })
      return null
    }
  }

  /**
   * æ¥å¬é€šè¯
   */
  async answerCall(callId: string): Promise<boolean> {
    try {
      const session = this.sessions.get(callId)
      if (!session) {
        throw new Error('é€šè¯ä¼šè¯ä¸å­˜åœ¨')
      }

      await session.accept()

      const call = this.calls.get(callId)
      if (call) {
        call.status = 'answered'
        call.answerTime = new Date()
      }

      this.emit('call_answered', this.calls.get(callId))
      console.log('âœ… æ¥å¬é€šè¯æˆåŠŸ:', callId)

      return true
    } catch (error) {
      console.error('âŒ æ¥å¬é€šè¯å¤±è´¥:', error)
      this.emit('error', { type: 'answer_failed', callId, error })
      return false
    }
  }

  /**
   * æŒ‚æ–­é€šè¯
   */
  async hangupCall(callId: string): Promise<boolean> {
    try {
      const session = this.sessions.get(callId)
      if (!session) {
        throw new Error('é€šè¯ä¼šè¯ä¸å­˜åœ¨')
      }

      await session.hangup()

      const call = this.calls.get(callId)
      if (call) {
        call.status = 'ended'
        call.endTime = new Date()
      }

      this.emit('call_ended', this.calls.get(callId))
      console.log('ğŸ“ æŒ‚æ–­é€šè¯æˆåŠŸ:', callId)

      // æ¸…ç†ä¼šè¯
      this.sessions.delete(callId)
      this.calls.delete(callId)

      return true
    } catch (error) {
      console.error('âŒ æŒ‚æ–­é€šè¯å¤±è´¥:', error)
      this.emit('error', { type: 'hangup_failed', callId, error })
      return false
    }
  }

  /**
   * ä¿æŒé€šè¯
   */
  async holdCall(callId: string): Promise<boolean> {
    try {
      const session = this.sessions.get(callId)
      if (!session) {
        throw new Error('é€šè¯ä¼šè¯ä¸å­˜åœ¨')
      }

      // SIPä¿æŒé€šè¯çš„å®ç°
      await session.hold()

      const call = this.calls.get(callId)
      if (call) {
        call.status = 'held'
      }

      this.emit('call_held', this.calls.get(callId))
      console.log('â¸ï¸ ä¿æŒé€šè¯æˆåŠŸ:', callId)

      return true
    } catch (error) {
      console.error('âŒ ä¿æŒé€šè¯å¤±è´¥:', error)
      this.emit('error', { type: 'hold_failed', callId, error })
      return false
    }
  }

  /**
   * æ¢å¤é€šè¯
   */
  async unholdCall(callId: string): Promise<boolean> {
    try {
      const session = this.sessions.get(callId)
      if (!session) {
        throw new Error('é€šè¯ä¼šè¯ä¸å­˜åœ¨')
      }

      await session.unhold()

      const call = this.calls.get(callId)
      if (call) {
        call.status = 'answered'
      }

      this.emit('call_unheld', this.calls.get(callId))
      console.log('â–¶ï¸ æ¢å¤é€šè¯æˆåŠŸ:', callId)

      return true
    } catch (error) {
      console.error('âŒ æ¢å¤é€šè¯å¤±è´¥:', error)
      this.emit('error', { type: 'unhold_failed', callId, error })
      return false
    }
  }

  /**
   * è½¬ç§»é€šè¯
   */
  async transferCall(callId: string, targetNumber: string): Promise<boolean> {
    try {
      const session = this.sessions.get(callId)
      if (!session) {
        throw new Error('é€šè¯ä¼šè¯ä¸å­˜åœ¨')
      }

      const call = this.calls.get(callId)
      if (call) {
        call.status = 'transferring'
      }

      // æ‰§è¡Œè½¬ç§»
      await session.refer(`sip:${targetNumber}@${this.config?.server}`)

      this.emit('call_transferred', { callId, targetNumber })
      console.log('ğŸ”„ è½¬ç§»é€šè¯æˆåŠŸ:', callId, '->', targetNumber)

      return true
    } catch (error) {
      console.error('âŒ è½¬ç§»é€šè¯å¤±è´¥:', error)
      this.emit('error', { type: 'transfer_failed', callId, targetNumber, error })
      return false
    }
  }

  /**
   * å‘é€DTMF
   */
  async sendDTMF(callId: string, digits: string): Promise<boolean> {
    try {
      const session = this.sessions.get(callId)
      if (!session) {
        throw new Error('é€šè¯ä¼šè¯ä¸å­˜åœ¨')
      }

      // å‘é€DTMFæŒ‰é”®
      for (const digit of digits) {
        await session.dtmf(digit)
      }

      this.emit('dtmf_sent', { callId, digits })
      console.log('ğŸ”¢ DTMFå‘é€æˆåŠŸ:', callId, digits)

      return true
    } catch (error) {
      console.error('âŒ DTMFå‘é€å¤±è´¥:', error)
      this.emit('error', { type: 'dtmf_failed', callId, digits, error })
      return false
    }
  }

  /**
   * æ–­å¼€SIPè¿æ¥
   */
  async disconnect(): Promise<void> {
    try {
      // æŒ‚æ–­æ‰€æœ‰é€šè¯
      const activeCalls = Array.from(this.calls.keys())
      for (const callId of activeCalls) {
        await this.hangupCall(callId)
      }

      // æ–­å¼€SIPè¿æ¥
      if (this.userAgent) {
        await this.userAgent.disconnect()
        this.userAgent = null
      }

      this.config = null
      this.registrationStatus = { registered: false }

      this.emit('disconnected')
      console.log('ğŸ“ SIPè¿æ¥å·²æ–­å¼€')
    } catch (error) {
      console.error('âŒ æ–­å¼€SIPè¿æ¥å¤±è´¥:', error)
      this.emit('error', { type: 'disconnect_failed', error })
    }
  }

  /**
   * è·å–å½“å‰çŠ¶æ€
   */
  getStatus(): any {
    return {
      connected: this.userAgent !== null,
      registered: this.registrationStatus.registered,
      activeCalls: Array.from(this.calls.values()),
      callCount: this.calls.size,
      config: this.config ? {
        server: this.config.server,
        extension: this.config.extension,
        username: this.config.username
      } : null
    }
  }

  /**
   * è·å–é€šè¯ä¿¡æ¯
   */
  getCall(callId: string): SIPCall | null {
    return this.calls.get(callId) || null
  }

  /**
   * è·å–æ‰€æœ‰æ´»è·ƒé€šè¯
   */
  getActiveCalls(): SIPCall[] {
    return Array.from(this.calls.values()).filter(call =>
      call.status !== 'ended' && call.status !== 'terminated'
    )
  }
}

export default new SIPService()