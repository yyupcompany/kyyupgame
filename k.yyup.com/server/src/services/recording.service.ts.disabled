/**
 * å½•éŸ³æœåŠ¡
 * å¤„ç†é€šè¯å½•éŸ³çš„å½•åˆ¶ã€å­˜å‚¨å’Œè½¬å†™
 */

import fs from 'fs'
import path from 'path'
import { EventEmitter } from 'events'

export interface RecordingConfig {
  enabled: boolean
  format: 'mp3' | 'wav' | 'ogg'
  quality: 'low' | 'medium' | 'high'
  maxDuration: number // æœ€å¤§å½•éŸ³æ—¶é•¿ï¼ˆç§’ï¼‰
  storagePath: string
  autoTranscribe: boolean
  transcribeLanguage: string
}

export interface Recording {
  id: string
  callId: string
  filename: string
  filePath: string
  startTime: Date
  endTime?: Date
  duration: number
  fileSize: number
  status: 'recording' | 'completed' | 'processing' | 'failed'
  format: string
  transcript?: string
  transcriptConfidence?: number
}

class RecordingService extends EventEmitter {
  private recordings: Map<string, Recording> = new Map()
  private config: RecordingConfig
  private activeRecorders: Map<string, any> = new Map()

  constructor() {
    super()

    // é»˜è®¤é…ç½®
    this.config = {
      enabled: true,
      format: 'mp3',
      quality: 'medium',
      maxDuration: 3600, // 1å°æ—¶
      storagePath: path.join(process.cwd(), 'recordings'),
      autoTranscribe: true,
      transcribeLanguage: 'zh-CN'
    }

    // ç¡®ä¿å½•éŸ³ç›®å½•å­˜åœ¨
    this.ensureStorageDirectory()
  }

  /**
   * ç¡®ä¿å½•éŸ³ç›®å½•å­˜åœ¨
   */
  private ensureStorageDirectory(): void {
    try {
      if (!fs.existsSync(this.config.storagePath)) {
        fs.mkdirSync(this.config.storagePath, { recursive: true })
      }
    } catch (error) {
      console.error('âŒ åˆ›å»ºå½•éŸ³ç›®å½•å¤±è´¥:', error)
    }
  }

  /**
   * æ›´æ–°å½•éŸ³é…ç½®
   */
  updateConfig(newConfig: Partial<RecordingConfig>): void {
    this.config = { ...this.config, ...newConfig }
    this.ensureStorageDirectory()
  }

  /**
   * å¼€å§‹å½•éŸ³
   */
  async startRecording(callId: string, audioStream?: any): Promise<Recording | null> {
    try {
      if (!this.config.enabled) {
        throw new Error('å½•éŸ³åŠŸèƒ½æœªå¯ç”¨')
      }

      // æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨å½•éŸ³
      if (this.recordings.has(callId)) {
        throw new Error('é€šè¯å·²åœ¨å½•éŸ³ä¸­')
      }

      const recordingId = `rec_${callId}_${Date.now()}`
      const filename = `${recordingId}.${this.config.format}`
      const filePath = path.join(this.config.storagePath, filename)

      const recording: Recording = {
        id: recordingId,
        callId,
        filename,
        filePath,
        startTime: new Date(),
        duration: 0,
        fileSize: 0,
        status: 'recording',
        format: this.config.format
      }

      this.recordings.set(callId, recording)

      // å¦‚æœæœ‰éŸ³é¢‘æµï¼Œå¼€å§‹å½•éŸ³
      if (audioStream) {
        await this.startAudioCapture(callId, audioStream, filePath)
      } else {
        // æ¨¡æ‹Ÿå½•éŸ³ï¼ˆå®é™…é¡¹ç›®ä¸­éœ€è¦çœŸå®çš„éŸ³é¢‘æµå¤„ç†ï¼‰
        this.startMockRecording(callId)
      }

      this.emit('recording_started', recording)
      console.log('ğŸ™ï¸ å¼€å§‹å½•éŸ³:', callId)

      return recording
    } catch (error) {
      console.error('âŒ å¼€å§‹å½•éŸ³å¤±è´¥:', error)
      this.emit('error', { type: 'recording_start_failed', callId, error })
      return null
    }
  }

  /**
   * å¼€å§‹éŸ³é¢‘æ•è·
   */
  private async startAudioCapture(callId: string, audioStream: any, filePath: string): Promise<void> {
    try {
      // è¿™é‡Œéœ€è¦å®ç°å®é™…çš„éŸ³é¢‘å½•åˆ¶é€»è¾‘
      // ä½¿ç”¨Node.jsçš„éŸ³é¢‘å¤„ç†åº“å¦‚node-record-lpcm16, speakerç­‰

      // æ¨¡æ‹Ÿå½•éŸ³è¿‡ç¨‹
      const writeStream = fs.createWriteStream(filePath)
      const recorder = {
        stream: writeStream,
        interval: setInterval(() => {
          this.updateRecordingDuration(callId)
        }, 1000),
        stop: () => {
          clearInterval(recorder.interval)
          writeStream.end()
        }
      }

      this.activeRecorders.set(callId, recorder)

      // å¤„ç†éŸ³é¢‘æ•°æ®
      audioStream.on('data', (chunk: Buffer) => {
        writeStream.write(chunk)
      })

      audioStream.on('end', () => {
        this.stopRecording(callId)
      })

    } catch (error) {
      console.error('âŒ éŸ³é¢‘æ•è·å¤±è´¥:', error)
      throw error
    }
  }

  /**
   * æ¨¡æ‹Ÿå½•éŸ³ï¼ˆç”¨äºæ¼”ç¤ºï¼‰
   */
  private startMockRecording(callId: string): void {
    const interval = setInterval(() => {
      this.updateRecordingDuration(callId)
    }, 1000)

    this.activeRecorders.set(callId, { interval, mock: true })
  }

  /**
   * æ›´æ–°å½•éŸ³æ—¶é•¿
   */
  private updateRecordingDuration(callId: string): void {
    const recording = this.recordings.get(callId)
    if (!recording || recording.status !== 'recording') return

    const now = new Date()
    recording.duration = Math.floor((now.getTime() - recording.startTime.getTime()) / 1000)

    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§æ—¶é•¿
    if (recording.duration >= this.config.maxDuration) {
      this.stopRecording(callId)
    }

    this.emit('recording_updated', recording)
  }

  /**
   * åœæ­¢å½•éŸ³
   */
  async stopRecording(callId: string): Promise<Recording | null> {
    try {
      const recording = this.recordings.get(callId)
      if (!recording) {
        throw new Error('å½•éŸ³è®°å½•ä¸å­˜åœ¨')
      }

      if (recording.status !== 'recording') {
        return recording
      }

      // åœæ­¢å½•éŸ³å™¨
      const recorder = this.activeRecorders.get(callId)
      if (recorder) {
        if (recorder.mock) {
          clearInterval(recorder.interval)
        } else {
          recorder.stop?.()
        }
        this.activeRecorders.delete(callId)
      }

      recording.endTime = new Date()
      recording.duration = Math.floor((recording.endTime.getTime() - recording.startTime.getTime()) / 1000)
      recording.status = 'completed'

      // è·å–æ–‡ä»¶å¤§å°
      try {
        const stats = fs.statSync(recording.filePath)
        recording.fileSize = stats.size
      } catch (error) {
        console.warn('âš ï¸ è·å–å½•éŸ³æ–‡ä»¶å¤§å°å¤±è´¥:', error)
      }

      // è‡ªåŠ¨è½¬å†™
      if (this.config.autoTranscribe) {
        this.startTranscription(recording)
      }

      this.emit('recording_stopped', recording)
      console.log('â¹ï¸ åœæ­¢å½•éŸ³:', callId, `æ—¶é•¿: ${recording.duration}ç§’`)

      return recording
    } catch (error) {
      console.error('âŒ åœæ­¢å½•éŸ³å¤±è´¥:', error)
      this.emit('error', { type: 'recording_stop_failed', callId, error })
      return null
    }
  }

  /**
   * å¼€å§‹è½¬å†™
   */
  private async startTranscription(recording: Recording): Promise<void> {
    try {
      recording.status = 'processing'
      this.emit('transcription_started', recording)

      // æ¨¡æ‹Ÿè½¬å†™è¿‡ç¨‹
      setTimeout(() => {
        this.mockTranscription(recording)
      }, 2000 + Math.random() * 3000) // 2-5ç§’çš„æ¨¡æ‹Ÿè½¬å†™æ—¶é—´

    } catch (error) {
      console.error('âŒ å¼€å§‹è½¬å†™å¤±è´¥:', error)
      recording.status = 'completed'
      this.emit('error', { type: 'transcription_failed', recording, error })
    }
  }

  /**
   * æ¨¡æ‹Ÿè½¬å†™ç»“æœ
   */
  private mockTranscription(recording: Recording): void {
    // æ¨¡æ‹Ÿè½¬å†™æ–‡æœ¬
    const mockTranscripts = [
      'æ‚¨å¥½ï¼Œè¿™é‡Œæ˜¯å¹¼å„¿å›­å‘¼å«ä¸­å¿ƒï¼Œè¯·é—®æœ‰ä»€ä¹ˆå¯ä»¥å¸®åŠ©æ‚¨çš„å—ï¼Ÿ',
      'æˆ‘æƒ³å’¨è¯¢ä¸€ä¸‹ä½ ä»¬å¹¼å„¿å›­çš„æ‹›ç”Ÿæƒ…å†µã€‚',
      'æˆ‘ä»¬ç›®å‰è¿˜æœ‰å°‘é‡åé¢ï¼Œè¯·é—®æ‚¨çš„å­©å­å¤šå¤§äº†ï¼Ÿ',
      'æˆ‘çš„å­©å­ä»Šå¹´ä¸‰å²ï¼Œæƒ³äº†è§£ä¸‹ä½ ä»¬çš„æ•™å­¦ç¯å¢ƒã€‚',
      'æˆ‘ä»¬å¹¼å„¿å›­æœ‰ä¸“ä¸šçš„å¸ˆèµ„å›¢é˜Ÿå’Œä¼˜è´¨çš„æ•™å­¦ç¯å¢ƒï¼Œæ¬¢è¿æ‚¨éšæ—¶æ¥å›­å‚è§‚ã€‚',
      'å¥½çš„ï¼Œæˆ‘ä»€ä¹ˆæ—¶å€™æ–¹ä¾¿å¸¦å­©å­è¿‡å»çœ‹çœ‹å‘¢ï¼Ÿ',
      'æˆ‘ä»¬å‘¨æœ«éƒ½æœ‰è€å¸ˆåœ¨ï¼Œæ‚¨å¯ä»¥éšæ—¶è¿‡æ¥ã€‚'
    ]

    const randomTranscript = mockTranscripts[Math.floor(Math.random() * mockTranscripts.length)]
    const confidence = 0.85 + Math.random() * 0.1 // 85%-95%çš„ç½®ä¿¡åº¦

    recording.transcript = randomTranscript
    recording.transcriptConfidence = confidence
    recording.status = 'completed'

    this.emit('transcription_completed', recording)
    console.log('ğŸ“ è½¬å†™å®Œæˆ:', recording.callId)
  }

  /**
   * æ‰‹åŠ¨è¯·æ±‚è½¬å†™
   */
  async requestTranscription(recordingId: string, language: string = 'zh-CN'): Promise<boolean> {
    try {
      const recording = Array.from(this.recordings.values()).find(r => r.id === recordingId)
      if (!recording) {
        throw new Error('å½•éŸ³è®°å½•ä¸å­˜åœ¨')
      }

      if (recording.status !== 'completed') {
        throw new Error('å½•éŸ³æœªå®Œæˆï¼Œæ— æ³•è½¬å†™')
      }

      // å¼€å§‹è½¬å†™
      await this.startTranscription(recording)
      return true

    } catch (error) {
      console.error('âŒ è¯·æ±‚è½¬å†™å¤±è´¥:', error)
      this.emit('error', { type: 'transcription_request_failed', recordingId, error })
      return false
    }
  }

  /**
   * æ›´æ–°è½¬å†™æ–‡æœ¬
   */
  async updateTranscript(recordingId: string, transcript: string): Promise<boolean> {
    try {
      const recording = Array.from(this.recordings.values()).find(r => r.id === recordingId)
      if (!recording) {
        throw new Error('å½•éŸ³è®°å½•ä¸å­˜åœ¨')
      }

      recording.transcript = transcript
      this.emit('transcript_updated', recording)
      console.log('ğŸ“ è½¬å†™æ–‡æœ¬å·²æ›´æ–°:', recordingId)

      return true
    } catch (error) {
      console.error('âŒ æ›´æ–°è½¬å†™æ–‡æœ¬å¤±è´¥:', error)
      this.emit('error', { type: 'transcript_update_failed', recordingId, error })
      return false
    }
  }

  /**
   * åˆ é™¤å½•éŸ³
   */
  async deleteRecording(recordingId: string): Promise<boolean> {
    try {
      const recording = Array.from(this.recordings.values()).find(r => r.id === recordingId)
      if (!recording) {
        throw new Error('å½•éŸ³è®°å½•ä¸å­˜åœ¨')
      }

      // åˆ é™¤æ–‡ä»¶
      if (fs.existsSync(recording.filePath)) {
        fs.unlinkSync(recording.filePath)
      }

      // ä»å†…å­˜ä¸­åˆ é™¤
      for (const [callId, rec] of this.recordings.entries()) {
        if (rec.id === recordingId) {
          this.recordings.delete(callId)
          break
        }
      }

      this.emit('recording_deleted', recording)
      console.log('ğŸ—‘ï¸ å½•éŸ³å·²åˆ é™¤:', recordingId)

      return true
    } catch (error) {
      console.error('âŒ åˆ é™¤å½•éŸ³å¤±è´¥:', error)
      this.emit('error', { type: 'recording_delete_failed', recordingId, error })
      return false
    }
  }

  /**
   * è·å–å½•éŸ³ä¿¡æ¯
   */
  getRecording(recordingId: string): Recording | null {
    return Array.from(this.recordings.values()).find(r => r.id === recordingId) || null
  }

  /**
   * è·å–é€šè¯å½•éŸ³
   */
  getCallRecording(callId: string): Recording | null {
    return this.recordings.get(callId) || null
  }

  /**
   * è·å–æ‰€æœ‰å½•éŸ³
   */
  getAllRecordings(): Recording[] {
    return Array.from(this.recordings.values())
  }

  /**
   * è·å–å½•éŸ³æ–‡ä»¶URL
   */
  getRecordingUrl(recordingId: string): string | null {
    const recording = this.getRecording(recordingId)
    if (!recording || recording.status !== 'completed') {
      return null
    }

    return `/api/call-center/recordings/${recording.id}/download`
  }

  /**
   * æ¸…ç†è¿‡æœŸå½•éŸ³
   */
  async cleanupExpiredRecordings(maxAge: number = 30 * 24 * 60 * 60 * 1000): Promise<number> {
    try {
      const now = Date.now()
      const expiredRecordings: Recording[] = []

      for (const recording of this.recordings.values()) {
        if (recording.endTime && (now - recording.endTime.getTime()) > maxAge) {
          expiredRecordings.push(recording)
        }
      }

      let deletedCount = 0
      for (const recording of expiredRecordings) {
        if (await this.deleteRecording(recording.id)) {
          deletedCount++
        }
      }

      console.log(`ğŸ§¹ æ¸…ç†äº† ${deletedCount} ä¸ªè¿‡æœŸå½•éŸ³`)
      return deletedCount
    } catch (error) {
      console.error('âŒ æ¸…ç†è¿‡æœŸå½•éŸ³å¤±è´¥:', error)
      return 0
    }
  }

  /**
   * è·å–æœåŠ¡çŠ¶æ€
   */
  getStatus(): any {
    return {
      config: this.config,
      activeRecordings: Array.from(this.recordings.values()).filter(r => r.status === 'recording'),
      totalRecordings: this.recordings.size,
      activeRecorders: this.activeRecorders.size
    }
  }
}

export default new RecordingService()