/**
 * SIP UDPå®¢æˆ·ç«¯æœåŠ¡
 * 
 * ä½¿ç”¨UDPåè®®å‘é€SIPæ¶ˆæ¯åˆ°KamailioæœåŠ¡å™¨
 * åŸºäºæˆåŠŸçš„Pythonæµ‹è¯•è„šæœ¬æ”¹å†™
 */

import dgram from 'dgram';
import { EventEmitter } from 'events';
import { aiBridgeService } from './ai/bridge/ai-bridge.service';
import { AIModelConfig } from '../models/ai-model-config.model';
import { sipConfigService, SIPConfig as DBSIPConfig } from './sip-config.service';
import { rtpAudioHandlerService } from './rtp-audio-handler.service';

interface SIPConfig {
  serverHost: string;
  serverPort: number;
  localHost: string;
  localPort: number;
  publicHost?: string; // å…¬ç½‘IPï¼Œç”¨äºSDP
  username: string;
  displayName: string;
  protocol: 'UDP' | 'TCP';
}

interface CallSession {
  callId: string;
  phoneNumber: string;
  startTime: Date;
  status: 'connecting' | 'ringing' | 'answered' | 'ended' | 'failed';
  socket?: dgram.Socket;
  customerId?: number;
  systemPrompt?: string;
  rtpLocalPort?: number;
  rtpRemoteHost?: string;
  rtpRemotePort?: number;
  voiceSessionId?: string;
}

export class SIPUDPService extends EventEmitter {
  private static instance: SIPUDPService;
  private config: SIPConfig | null = null;
  private activeCalls: Map<string, CallSession> = new Map();
  private isInitialized: boolean = false;
  private globalSocket: dgram.Socket | null = null; // å…¨å±€å…±äº«socket

  private constructor() {
    super();
  }

  static getInstance(): SIPUDPService {
    if (!SIPUDPService.instance) {
      SIPUDPService.instance = new SIPUDPService();
    }
    return SIPUDPService.instance;
  }

  /**
   * åˆå§‹åŒ–æœåŠ¡ï¼Œä»æ•°æ®åº“åŠ è½½é…ç½®
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      console.log('ğŸ“ åˆå§‹åŒ–SIP UDPæœåŠ¡...');

      // ä¼˜å…ˆä½¿ç”¨ç¯å¢ƒå˜é‡é…ç½®ï¼ˆç”¨äºæµ‹è¯•ï¼‰
      // å¦‚æœç¯å¢ƒå˜é‡ä¸­é…ç½®äº†SIP_USERNAMEï¼Œåˆ™ä½¿ç”¨ç¯å¢ƒå˜é‡é…ç½®
      const useEnvConfig = process.env.SIP_USERNAME || process.env.SIP_USE_ENV_CONFIG === 'true';

      if (useEnvConfig) {
        console.log('âœ… ä½¿ç”¨ç¯å¢ƒå˜é‡SIPé…ç½®');
        this.config = {
          serverHost: process.env.SIP_SERVER_HOST || '47.94.82.59',
          serverPort: parseInt(process.env.SIP_SERVER_PORT || '5060'),
          localHost: process.env.SIP_LOCAL_HOST || '192.168.1.243',
          localPort: parseInt(process.env.SIP_LOCAL_PORT || '5061'),
          publicHost: process.env.SIP_PUBLIC_HOST, // å…¬ç½‘IPï¼ˆå¯é€‰ï¼‰
          username: process.env.SIP_USERNAME || 'test',
          displayName: process.env.SIP_DISPLAY_NAME || 'Test Caller',
          protocol: 'UDP'
        };
      } else {
        // ä»æ•°æ®åº“åŠ è½½SIPé…ç½®
        await sipConfigService.loadConfig();
        const dbConfig = sipConfigService.getConfig();

        if (!dbConfig) {
          console.warn('âš ï¸  æœªæ‰¾åˆ°SIPé…ç½®ï¼Œä½¿ç”¨é»˜è®¤é…ç½®');
          // é™çº§åˆ°é»˜è®¤é…ç½®
          this.config = {
            serverHost: '47.94.82.59',
            serverPort: 5060,
            localHost: '192.168.1.243',
            localPort: 5061,
            publicHost: undefined,
            username: 'test',
            displayName: 'Test Caller',
            protocol: 'UDP'
          };
        } else {
          // ä½¿ç”¨æ•°æ®åº“é…ç½®
          this.config = {
            serverHost: dbConfig.server_host,
            serverPort: dbConfig.server_port,
            localHost: process.env.SIP_LOCAL_HOST || '192.168.1.243',
            localPort: parseInt(process.env.SIP_LOCAL_PORT || '5061'),
            publicHost: process.env.SIP_PUBLIC_HOST, // å…¬ç½‘IPï¼ˆå¯é€‰ï¼‰
            username: dbConfig.username,
            displayName: process.env.SIP_DISPLAY_NAME || 'å¹¼å„¿å›­æ‹›ç”Ÿé¡¾é—®',
            protocol: dbConfig.protocol
          };
          console.log('âœ… ä½¿ç”¨æ•°æ®åº“SIPé…ç½®');
        }
      }

      console.log(`   æœåŠ¡å™¨: ${this.config.serverHost}:${this.config.serverPort}`);
      console.log(`   åè®®: ${this.config.protocol}`);
      console.log(`   ç”¨æˆ·å: ${this.config.username}`);
      console.log(`   æœ¬åœ°: ${this.config.localHost}:${this.config.localPort}`);

      // åˆ›å»ºå…¨å±€socket
      await this.ensureGlobalSocket();

      // å‘é€SIP REGISTERæ³¨å†Œ
      await this.registerSIP();

      this.isInitialized = true;
    } catch (error) {
      console.error('âŒ åˆå§‹åŒ–SIP UDPæœåŠ¡å¤±è´¥:', error);
      throw error;
    }
  }

  /**
   * ç¡®ä¿æœåŠ¡å·²åˆå§‹åŒ–
   */
  private async ensureInitialized(): Promise<void> {
    console.log(`ğŸ” æ£€æŸ¥SIPæœåŠ¡åˆå§‹åŒ–çŠ¶æ€: isInitialized=${this.isInitialized}, config=${this.config ? 'å·²åŠ è½½' : 'null'}`);

    if (!this.isInitialized) {
      console.log('âš ï¸  SIPæœåŠ¡æœªåˆå§‹åŒ–ï¼Œå¼€å§‹åˆå§‹åŒ–...');
      await this.initialize();
    }

    if (!this.config) {
      console.error('âŒ SIPé…ç½®ä¸ºnullï¼ŒisInitialized=' + this.isInitialized);
      throw new Error('é…ç½®æœªåŠ è½½');
    }

    console.log('âœ… SIPæœåŠ¡å·²å°±ç»ª');
  }

  /**
   * å‘é€SIP REGISTERæ³¨å†Œ
   * è®©SIPæœåŠ¡å™¨çŸ¥é“æˆ‘ä»¬çš„å­˜åœ¨ï¼Œå¹¶è®°å½•æˆ‘ä»¬çš„NATæ˜ å°„åœ°å€
   */
  private async registerSIP(): Promise<void> {
    const timestamp = Date.now();
    const branch = `z9hG4bK-reg${timestamp}`;
    const tag = `tag-reg${timestamp}`;
    const callId = `register-${timestamp}@${this.config.localHost}`;

    const registerMessage = `REGISTER sip:${this.config.serverHost} SIP/2.0\r
Via: SIP/2.0/UDP ${this.config.localHost}:${this.config.localPort};branch=${branch}\r
Max-Forwards: 70\r
From: <sip:${this.config.username}@${this.config.serverHost}>;tag=${tag}\r
To: <sip:${this.config.username}@${this.config.serverHost}>\r
Call-ID: ${callId}\r
CSeq: 1 REGISTER\r
Contact: <sip:${this.config.username}@${this.config.localHost}:${this.config.localPort}>\r
Expires: 3600\r
Content-Length: 0\r
\r
`;

    console.log('ğŸ“ å‘é€SIP REGISTER:');
    console.log('â”€'.repeat(60));
    console.log(registerMessage);
    console.log('â”€'.repeat(60));

    // å‘é€REGISTERæ¶ˆæ¯
    const message = Buffer.from(registerMessage);
    await new Promise<void>((resolve, reject) => {
      this.globalSocket!.send(
        message,
        0,
        message.length,
        this.config.serverPort,
        this.config.serverHost,
        (err) => {
          if (err) {
            console.error('âŒ å‘é€REGISTERå¤±è´¥:', err);
            reject(err);
          } else {
            console.log('âœ… SIP REGISTERå·²å‘é€ï¼Œç­‰å¾…å“åº”...');
            // ç­‰å¾…2ç§’æ¥æ”¶å“åº”
            setTimeout(() => resolve(), 2000);
          }
        }
      );
    });
  }

  /**
   * ç”ŸæˆSIP INVITEæ¶ˆæ¯ï¼ˆå¸¦SDPï¼‰
   * åŸºäºPythonè„šæœ¬çš„æ ¼å¼ï¼Œæ·»åŠ SDPæ”¯æŒ
   * è¿”å›: { invite: string, sipCallId: string }
   */
  private generateSIPInvite(phoneNumber: string, callId: string, rtpPort: number): { invite: string; sipCallId: string } {
    const timestamp = Math.floor(Date.now() / 1000);
    const branch = `z9hG4bK-${callId}`;
    const tag = `tag-${callId}`;
    const sipCallId = `${callId}-${timestamp}@${this.config.localHost}`;

    // ç”ŸæˆSDPå†…å®¹
    const sdp = this.generateSDP(rtpPort);
    const sdpLength = Buffer.byteLength(sdp, 'utf8');

    const sipInvite = `INVITE sip:${phoneNumber}@${this.config.serverHost} SIP/2.0
Via: SIP/2.0/UDP ${this.config.localHost}:${this.config.localPort};branch=${branch}
Max-Forwards: 70
From: "${this.config.displayName}" <sip:${this.config.username}@${this.config.localHost}>;tag=${tag}
To: <sip:${phoneNumber}@${this.config.serverHost}>
Call-ID: ${sipCallId}
CSeq: 100 INVITE
Contact: <sip:${this.config.username}@${this.config.localHost}:${this.config.localPort}>
Content-Type: application/sdp
Content-Length: ${sdpLength}

${sdp}`;

    return { invite: sipInvite, sipCallId };
  }

  /**
   * ç”ŸæˆSDPï¼ˆä¼šè¯æè¿°åè®®ï¼‰
   * å¦‚æœé…ç½®äº†å…¬ç½‘IPï¼Œåˆ™åœ¨SDPä¸­ä½¿ç”¨å…¬ç½‘IPï¼Œè¿™æ ·SIPæœåŠ¡å™¨æ‰èƒ½å°†RTPæµå‘é€åˆ°æ­£ç¡®çš„åœ°å€
   */
  private generateSDP(rtpPort: number): string {
    const sessionId = Date.now();
    const sessionVersion = sessionId;

    // ä¼˜å…ˆä½¿ç”¨å…¬ç½‘IPï¼Œå¦‚æœæ²¡æœ‰é…ç½®åˆ™ä½¿ç”¨æœ¬åœ°IP
    const sdpHost = this.config.publicHost || this.config.localHost;

    console.log(`ğŸ“ ç”ŸæˆSDP - ä½¿ç”¨IP: ${sdpHost} (${this.config.publicHost ? 'å…¬ç½‘' : 'å†…ç½‘'})`);

    return `v=0
o=- ${sessionId} ${sessionVersion} IN IP4 ${sdpHost}
s=Call
c=IN IP4 ${sdpHost}
t=0 0
m=audio ${rtpPort} RTP/AVP 0 8 101
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:101 telephone-event/8000
a=fmtp:101 0-15
a=sendrecv
a=ptime:20
`;
  }

  /**
   * æ ¼å¼åŒ–ç”µè¯å·ç  - å»æ‰+86å‰ç¼€ï¼Œåªä¿ç•™çº¯æ•°å­—
   */
  private formatPhoneNumber(phoneNumber: string): string {
    // å»æ‰æ‰€æœ‰éæ•°å­—å­—ç¬¦
    let cleaned = phoneNumber.replace(/\D/g, '');

    // å¦‚æœä»¥86å¼€å¤´ä¸”é•¿åº¦ä¸º13ä½ï¼Œå»æ‰86å‰ç¼€
    if (cleaned.startsWith('86') && cleaned.length === 13) {
      cleaned = cleaned.substring(2);
    }

    console.log(`ğŸ“± å·ç æ ¼å¼åŒ–: ${phoneNumber} -> ${cleaned}`);
    return cleaned;
  }

  /**
   * ç¡®ä¿å…¨å±€socketå·²åˆ›å»ºå¹¶ç»‘å®š
   */
  private async ensureGlobalSocket(): Promise<dgram.Socket> {
    if (this.globalSocket) {
      console.log(`âœ… ä½¿ç”¨å·²å­˜åœ¨çš„å…¨å±€Socket (${this.config.localHost}:${this.config.localPort})`);
      console.log(`   ç›‘å¬å™¨æ•°é‡: message=${this.globalSocket.listenerCount('message')}, error=${this.globalSocket.listenerCount('error')}`);
      return this.globalSocket;
    }

    return new Promise((resolve, reject) => {
      const socket = dgram.createSocket('udp4');

      // è®¾ç½®é”™è¯¯å¤„ç†å™¨ï¼ˆç»‘å®šå‰åéƒ½éœ€è¦ï¼‰
      const errorHandler = (err: Error) => {
        console.error('âŒ Socketé”™è¯¯:', err);
        this.emit('socket-error', { error: err.message });
        reject(err);
      };

      socket.once('error', errorHandler);

      // å…ˆè®¾ç½®æ¶ˆæ¯ç›‘å¬å™¨ï¼Œå†ç»‘å®šç«¯å£ï¼Œé¿å…ä¸¢å¤±æ¶ˆæ¯
      socket.on('message', (msg, rinfo) => {
        this.handleSIPResponse(msg, rinfo);
      });

      // ç»‘å®šæœ¬åœ°ç«¯å£
      socket.bind(this.config.localPort, this.config.localHost, () => {
        console.log(`âœ… å…¨å±€Socketå·²ç»‘å®šåˆ° ${this.config.localHost}:${this.config.localPort}`);
        console.log(`   SocketçŠ¶æ€: å·²ç»‘å®š`);
        console.log(`   ç›‘å¬å™¨æ•°é‡: message=${socket.listenerCount('message')}, error=${socket.listenerCount('error')}`);

        // ç§»é™¤ä¸´æ—¶é”™è¯¯å¤„ç†å™¨ï¼Œæ·»åŠ æ°¸ä¹…é”™è¯¯å¤„ç†å™¨
        socket.removeListener('error', errorHandler);
        socket.on('error', (err) => {
          console.error('âŒ Socketè¿è¡Œæ—¶é”™è¯¯:', err);
          this.emit('socket-error', { error: err.message });
        });

        this.globalSocket = socket;
        resolve(socket);
      });
    });
  }

  /**
   * å¤„ç†SIPå“åº”ï¼ˆå…¨å±€å¤„ç†å™¨ï¼‰
   */
  private async handleSIPResponse(msg: Buffer, rinfo: dgram.RemoteInfo): Promise<void> {
    const response = msg.toString();
    console.log(`\n${'='.repeat(60)}`);
    console.log(`ğŸ“¥ æ”¶åˆ°SIPå“åº” (${rinfo.address}:${rinfo.port})`);
    console.log(`   å¤§å°: ${msg.length} å­—èŠ‚`);
    console.log(`   æ—¶é—´: ${new Date().toISOString()}`);
    console.log(`${'='.repeat(60)}`);
    console.log(response);
    console.log(`${'='.repeat(60)}\n`);

    // ä»å“åº”ä¸­æå–Call-ID
    const callIdMatch = response.match(/Call-ID:\s*([^\r\n]+)/i);
    if (!callIdMatch) {
      console.warn('âš ï¸  æ— æ³•ä»SIPå“åº”ä¸­æå–Call-ID');
      return;
    }

    const callId = callIdMatch[1].trim();

    // æ£€æŸ¥æ˜¯å¦æ˜¯REGISTERå“åº”
    if (callId.startsWith('register-')) {
      const statusMatch = response.match(/SIP\/2\.0 (\d+)/);
      if (statusMatch) {
        const statusCode = parseInt(statusMatch[1]);
        if (statusCode === 200) {
          console.log('âœ… SIPæ³¨å†ŒæˆåŠŸï¼æœåŠ¡å™¨å·²è®°å½•æˆ‘ä»¬çš„NATæ˜ å°„åœ°å€');
        } else if (statusCode === 401 || statusCode === 407) {
          console.log('ğŸ” éœ€è¦è®¤è¯ï¼Œä½†å½“å‰é…ç½®ä¸ºæ— è®¤è¯æ¨¡å¼');
        } else {
          console.log(`âš ï¸  æ³¨å†Œå“åº”: ${statusCode}`);
        }
      }
      return;
    }

    const callSession = this.activeCalls.get(callId);

    if (!callSession) {
      console.warn(`âš ï¸  æœªæ‰¾åˆ°å‘¼å«ä¼šè¯: ${callId}`);
      return;
    }

    // è§£æSIPå“åº”çŠ¶æ€ç 
    const statusMatch = response.match(/SIP\/2\.0 (\d+)/);
    if (statusMatch) {
      const statusCode = parseInt(statusMatch[1]);

      if (statusCode === 100) {
        // 100 Trying
        console.log('ğŸ“ å‘¼å«å°è¯•ä¸­...');
        this.emit('call-trying', { callId });
      } else if (statusCode === 180 || statusCode === 183) {
        // 180 Ringing / 183 Session Progress
        console.log('ğŸ“ å¯¹æ–¹æŒ¯é“ƒä¸­...');
        callSession.status = 'ringing';
        this.emit('call-ringing', { callId });
      } else if (statusCode === 200) {
        // 200 OK - å‘¼å«æ¥é€š
        console.log('âœ… å‘¼å«å·²æ¥é€šï¼');
        callSession.status = 'answered';

        // è§£æSDPï¼Œè·å–è¿œç¨‹RTPç«¯å£
        const sdpMatch = response.match(/m=audio\s+(\d+)/);
        if (sdpMatch) {
          const remoteRTPPort = parseInt(sdpMatch[1]);
          callSession.rtpRemotePort = remoteRTPPort;

          // è§£æè¿œç¨‹IPåœ°å€
          const connectionMatch = response.match(/c=IN\s+IP4\s+([\d.]+)/);
          if (connectionMatch) {
            callSession.rtpRemoteHost = connectionMatch[1];
            console.log(`ğŸµ è¿œç¨‹RTP: ${callSession.rtpRemoteHost}:${remoteRTPPort}`);

            // æ›´æ–°RTPä¼šè¯çš„è¿œç¨‹åœ°å€
            const rtpSession = rtpAudioHandlerService.getSessionInfo(callId);
            if (rtpSession) {
              rtpSession.remoteHost = callSession.rtpRemoteHost;
              rtpSession.remotePort = remoteRTPPort;
            }
          }
        }

        this.emit('call-answered', { callId });
      } else if (statusCode >= 400) {
        // 4xx/5xx/6xx - å‘¼å«å¤±è´¥
        console.error(`âŒ SIPé”™è¯¯: ${statusCode}`);
        callSession.status = 'failed';
        this.emit('call-failed', { callId, statusCode });
      }
    }
  }

  /**
   * å‘èµ·å‘¼å«
   */
  async makeCall(
    phoneNumber: string,
    customerId?: number,
    systemPrompt?: string
  ): Promise<string> {
    // ç¡®ä¿æœåŠ¡å·²åˆå§‹åŒ–
    await this.ensureInitialized();

    // ç¡®ä¿å…¨å±€socketå·²åˆ›å»º
    const socket = await this.ensureGlobalSocket();

    // æ ¼å¼åŒ–ç”µè¯å·ç  - å»æ‰+86å‰ç¼€
    const formattedPhone = this.formatPhoneNumber(phoneNumber);

    const callId = `call_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;

    console.log(`ğŸ“ å‘èµ·å‘¼å«: ${formattedPhone} (åŸå§‹: ${phoneNumber})`);
    console.log(`   Call ID: ${callId}`);
    console.log(`   ç›®æ ‡æœåŠ¡å™¨: ${this.config.serverHost}:${this.config.serverPort}`);
    console.log(`   æœ¬åœ°åœ°å€: ${this.config.localHost}:${this.config.localPort}`);

    return new Promise(async (resolve, reject) => {
      try {
        // åˆ›å»ºRTPä¼šè¯ï¼Œè·å–æœ¬åœ°RTPç«¯å£
        const { localPort: rtpPort, sessionId: voiceSessionId } = await rtpAudioHandlerService.createSession(
          callId,
          this.config.serverHost,
          0, // è¿œç¨‹ç«¯å£å°†ä»SDPå“åº”ä¸­è·å–
          customerId,
          systemPrompt
        );

        console.log(`ğŸµ RTPä¼šè¯å·²åˆ›å»º: æœ¬åœ°ç«¯å£ ${rtpPort}, è¯­éŸ³ä¼šè¯ ${voiceSessionId}`);

        // ç”ŸæˆSIP INVITEæ¶ˆæ¯ï¼ˆä½¿ç”¨æ ¼å¼åŒ–åçš„å·ç å’ŒRTPç«¯å£ï¼‰
        const { invite: sipInvite, sipCallId } = this.generateSIPInvite(formattedPhone, callId, rtpPort);

        const callSession: CallSession = {
          callId: sipCallId,  // ä½¿ç”¨å®Œæ•´çš„SIP Call-ID
          phoneNumber: formattedPhone,
          startTime: new Date(),
          status: 'connecting',
          customerId,
          systemPrompt,
          rtpLocalPort: rtpPort,
          voiceSessionId
        };

        // ä½¿ç”¨å®Œæ•´çš„SIP Call-IDä½œä¸ºkey
        this.activeCalls.set(sipCallId, callSession);

      console.log('\n' + '='.repeat(60));
      console.log('ğŸ“¤ å‘é€SIP INVITE');
      console.log('   ç›®æ ‡: ' + this.config.serverHost + ':' + this.config.serverPort);
      console.log('   Call-ID: ' + sipCallId);
      console.log('   ç”µè¯: ' + formattedPhone);
      console.log('='.repeat(60));
      console.log(sipInvite);
      console.log('='.repeat(60) + '\n');

      // å‘é€SIP INVITEï¼ˆä½¿ç”¨å…¨å±€socketï¼‰
      const inviteBuffer = Buffer.from(sipInvite);
      socket.send(
        inviteBuffer,
        0,
        inviteBuffer.length,
        this.config.serverPort,
        this.config.serverHost,
        (err) => {
          if (err) {
            console.error('âŒ å‘é€SIP INVITEå¤±è´¥:', err);
            this.activeCalls.delete(sipCallId);
            callSession.status = 'failed';
            this.emit('call-failed', { callId: sipCallId, error: err.message });
            reject(err);
            return;
          }

          console.log('âœ… SIP INVITEå·²å‘é€ï¼Œç­‰å¾…å“åº”...');
          console.log(`   ç›‘å¬åœ°å€: ${this.config.localHost}:${this.config.localPort}`);
          console.log(`   æ´»åŠ¨å‘¼å«æ•°: ${this.activeCalls.size}`);
          callSession.status = 'ringing';
          this.emit('call-initiated', { callId: sipCallId, phoneNumber });
        }
      );

      // è®¾ç½®è¶…æ—¶ï¼ˆ30ç§’æ— å“åº”åˆ™å¤±è´¥ï¼‰
      setTimeout(() => {
        if (callSession.status === 'connecting' || callSession.status === 'ringing') {
          console.warn(`â±ï¸  å‘¼å«è¶…æ—¶: ${sipCallId}`);
          callSession.status = 'failed';
          this.activeCalls.delete(sipCallId);
          this.emit('call-timeout', { callId: sipCallId });
          reject(new Error('å‘¼å«è¶…æ—¶'));
        }
      }, 30000); // 30ç§’è¶…æ—¶

      // ç›‘å¬å‘¼å«æ¥é€šäº‹ä»¶
      this.once('call-answered', async (event) => {
        if (event.callId === sipCallId) {
          // ğŸš€ ä½¿ç”¨AIBridgeæœåŠ¡å¯åŠ¨è±†åŒ…å®æ—¶è¯­éŸ³ä¼šè¯
          try {
            console.log('ğŸ¤– é€šè¿‡AIBridgeå¯åŠ¨è±†åŒ…å®æ—¶è¯­éŸ³ä¼šè¯...');

            // ä»æ•°æ®åº“åŠ è½½è±†åŒ…æ¨¡å‹é…ç½®ï¼ˆç”¨äºåç»­çš„å¯¹è¯ï¼‰
            const { Op } = require('sequelize');
            const doubaoModel = await AIModelConfig.findOne({
              where: {
                modelType: 'text',
                status: 'active',
                name: { [Op.like]: '%doubao%' }
              }
            });

            if (!doubaoModel) {
              console.warn('âš ï¸  æœªæ‰¾åˆ°è±†åŒ…æ¨¡å‹é…ç½®');
            } else {
              console.log(`âœ… æ‰¾åˆ°è±†åŒ…æ¨¡å‹: ${doubaoModel.name}`);
            }

            // åˆå§‹åŒ–AIä¼šè¯æç¤ºè¯
            const initialPrompt = systemPrompt || `ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„å¹¼å„¿å›­æ‹›ç”Ÿé¡¾é—®ï¼Œè´Ÿè´£é€šè¿‡ç”µè¯ä¸å®¶é•¿æ²Ÿé€šã€‚
è¯·ä¿æŒå‹å¥½ã€ä¸“ä¸šçš„æ€åº¦ï¼Œäº†è§£å®¶é•¿éœ€æ±‚ï¼Œä»‹ç»å¹¼å„¿å›­ç‰¹è‰²ï¼Œå¹¶å¼•å¯¼å®¶é•¿é¢„çº¦å‚è§‚ã€‚`;

            console.log('âœ… è±†åŒ…å®æ—¶è¯­éŸ³ä¼šè¯å·²å‡†å¤‡å°±ç»ª');
            console.log(`   Call ID: ${sipCallId}`);
            console.log(`   Customer ID: ${customerId || 'æœªæŒ‡å®š'}`);

            // å­˜å‚¨AIä¼šè¯ä¿¡æ¯åˆ°callSession
            callSession.systemPrompt = initialPrompt;

            // å‘å‡ºä¼šè¯å°±ç»ªäº‹ä»¶
            this.emit('ai-session-ready', {
              callId: sipCallId,
              customerId,
              systemPrompt: initialPrompt,
              modelConfig: doubaoModel
            });

          } catch (error) {
            console.error('âŒ å¯åŠ¨è±†åŒ…å®æ—¶è¯­éŸ³ä¼šè¯å¤±è´¥:', error);
          }

          resolve(sipCallId);
        }
      });

      // ç›‘å¬å‘¼å«å¤±è´¥äº‹ä»¶
      this.once('call-failed', async (event) => {
        if (event.callId === sipCallId) {
          const statusCode = event.statusCode || 0;
          if (statusCode >= 400) {
            // 4xx/5xx/6xx - å‘¼å«å¤±è´¥
            console.error(`âŒ å‘¼å«å¤±è´¥: ${statusCode}`);
            callSession.status = 'failed';
            this.activeCalls.delete(sipCallId);

            // æ¸…ç†RTPä¼šè¯
            await rtpAudioHandlerService.endSession(callId);

            reject(new Error(`SIPé”™è¯¯: ${statusCode}`));
          }
        }
      });
      } catch (error) {
        console.error('âŒ åˆ›å»ºå‘¼å«å¤±è´¥:', error);
        reject(error);
      }
    });
  }

  /**
   * å¤„ç†æ¥è‡ªSIPçš„éŸ³é¢‘æ•°æ®
   * è½¬å‘ç»™è±†åŒ…å®æ—¶è¯­éŸ³æœåŠ¡
   */
  async processAudio(callId: string, audioData: Buffer): Promise<void> {
    const callSession = this.activeCalls.get(callId);
    if (!callSession) {
      console.warn(`âš ï¸  é€šè¯ä¼šè¯ä¸å­˜åœ¨: ${callId}`);
      return;
    }

    if (callSession.status !== 'answered') {
      console.warn(`âš ï¸  é€šè¯æœªæ¥é€šï¼Œæ— æ³•å¤„ç†éŸ³é¢‘: ${callId}`);
      return;
    }

    try {
      // ğŸš€ ä½¿ç”¨AIBridgeå¤„ç†éŸ³é¢‘
      console.log(`ğŸ¤ å¤„ç†éŸ³é¢‘æ•°æ®: ${callId}, å¤§å°: ${audioData.length} å­—èŠ‚`);

      // 1. è¯­éŸ³è½¬æ–‡å­— (ASR)
      const transcription = await aiBridgeService.speechToText({
        model: 'whisper-1',
        file: audioData,
        filename: `audio_${callId}.wav`,
        language: 'zh'
      });

      if (transcription && transcription.text) {
        console.log(`ğŸ¤ ç”¨æˆ·è¯´: ${transcription.text}`);

        // 2. AIå¯¹è¯ (LLM)
        const { Op } = require('sequelize');
        const doubaoModel = await AIModelConfig.findOne({
          where: {
            modelType: 'text',
            status: 'active',
            name: { [Op.like]: '%doubao%' }
          }
        });

        if (doubaoModel) {
          const response = await aiBridgeService.generateChatCompletion({
            model: doubaoModel.name,
            messages: [
              {
                role: 'system',
                content: callSession.systemPrompt || 'ä½ æ˜¯ä¸€ä½ä¸“ä¸šçš„å¹¼å„¿å›­æ‹›ç”Ÿé¡¾é—®'
              },
              {
                role: 'user',
                content: transcription.text
              }
            ],
            temperature: 0.7,
            max_tokens: 500
          }, {
            endpointUrl: doubaoModel.endpointUrl,
            apiKey: doubaoModel.apiKey
          });

          if (response && response.choices && response.choices[0]) {
            const aiReply = response.choices[0].message.content;
            console.log(`ğŸ¤– AIå›å¤: ${aiReply}`);

            // 3. æ–‡å­—è½¬è¯­éŸ³ (TTS)
            const ttsResult = await aiBridgeService.textToSpeech({
              model: 'tts-1',
              input: aiReply,
              voice: 'zh_female_cancan_mars_bigtts',
              speed: 1.0
            });

            if (ttsResult && ttsResult.audioData) {
              console.log(`ğŸ”Š è¯­éŸ³åˆæˆæˆåŠŸï¼Œå¤§å°: ${ttsResult.audioData.length} å­—èŠ‚`);

              // å‘å‡ºéŸ³é¢‘å“åº”äº‹ä»¶ï¼ˆç”±SIPæœåŠ¡å‘é€å›å®¢æˆ·ï¼‰
              this.emit('audio-response', {
                callId,
                audioData: ttsResult.audioData,
                text: aiReply
              });
            }
          }
        }
      }

    } catch (error) {
      console.error(`âŒ å¤„ç†éŸ³é¢‘å¤±è´¥ (${callId}):`, error);
      this.emit('audio-error', {
        callId,
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }

  /**
   * æŒ‚æ–­é€šè¯
   */
  async hangupCall(callId: string): Promise<void> {
    const callSession = this.activeCalls.get(callId);
    if (!callSession) {
      console.warn(`âš ï¸  é€šè¯ä¼šè¯ä¸å­˜åœ¨: ${callId}`);
      return;
    }

    console.log(`ğŸ“ æŒ‚æ–­é€šè¯: ${callId}`);

    try {
      // å‘é€SIP BYEæ¶ˆæ¯
      if (callSession.socket && callSession.status === 'answered') {
        const sipBye = this.generateSIPBye(callSession.phoneNumber, callId);
        callSession.socket.send(
          sipBye,
          this.config.serverPort,
          this.config.serverHost,
          (err) => {
            if (err) {
              console.error('âŒ å‘é€SIP BYEå¤±è´¥:', err);
            } else {
              console.log('âœ… SIP BYEå·²å‘é€');
            }
          }
        );
      }

      // å…³é—­socket
      if (callSession.socket) {
        callSession.socket.close();
      }

      // ğŸš€ ç»“æŸRTPä¼šè¯å’ŒAIä¼šè¯
      console.log(`ğŸ¤– ç»“æŸRTPå’ŒAIä¼šè¯: ${callId}`);
      await rtpAudioHandlerService.endSession(callId);

      // æ›´æ–°çŠ¶æ€
      callSession.status = 'ended';
      
      // è®¡ç®—é€šè¯æ—¶é•¿
      const duration = Math.floor((Date.now() - callSession.startTime.getTime()) / 1000);
      
      // åˆ é™¤ä¼šè¯
      this.activeCalls.delete(callId);

      console.log(`âœ… é€šè¯å·²ç»“æŸï¼Œæ—¶é•¿: ${duration}ç§’`);
      this.emit('call-ended', { callId, duration });
    } catch (error) {
      console.error(`âŒ æŒ‚æ–­é€šè¯å¤±è´¥ (${callId}):`, error);
      throw error;
    }
  }

  /**
   * ç”ŸæˆSIP BYEæ¶ˆæ¯
   */
  private generateSIPBye(phoneNumber: string, callId: string): string {
    const timestamp = Math.floor(Date.now() / 1000);
    const branch = `z9hG4bK-bye-${callId}`;
    const tag = `tag-${callId}`;
    const sipCallId = `${callId}-${timestamp}@${this.config.localHost}`;

    const sipBye = `BYE sip:${phoneNumber}@${this.config.serverHost} SIP/2.0
Via: SIP/2.0/UDP ${this.config.localHost}:${this.config.localPort};branch=${branch}
Max-Forwards: 70
From: "${this.config.displayName}" <sip:${this.config.username}@${this.config.localHost}>;tag=${tag}
To: <sip:${phoneNumber}@${this.config.serverHost}>
Call-ID: ${sipCallId}
CSeq: 101 BYE
Content-Length: 0

`;

    return sipBye;
  }

  /**
   * è·å–æ´»è·ƒé€šè¯åˆ—è¡¨
   */
  getActiveCalls(): CallSession[] {
    return Array.from(this.activeCalls.values());
  }

  /**
   * è·å–é€šè¯ä¿¡æ¯
   */
  getCallInfo(callId: string): CallSession | undefined {
    return this.activeCalls.get(callId);
  }

  /**
   * è·å–æ´»è·ƒé€šè¯æ•°
   */
  getActiveCallCount(): number {
    return this.activeCalls.size;
  }
}

// å¯¼å‡ºå•ä¾‹
export const sipUDPService = SIPUDPService.getInstance();

