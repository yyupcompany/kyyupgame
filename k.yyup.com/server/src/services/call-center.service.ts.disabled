/**
 * å‘¼å«ä¸­å¿ƒæœåŠ¡å±‚
 * å¤„ç†SIPè¿æ¥ã€é€šè¯ç®¡ç†ã€å½•éŸ³å¤„ç†ã€AIåˆ†æç­‰ä¸šåŠ¡é€»è¾‘
 */

import { Op } from 'sequelize'
import {
  SIPConfig,
  CallRecord,
  CallRecording,
  CallAnalysis,
  Extension,
  Contact
} from '../models/CallCenter'
import { User } from '../models'
import { AIBridgeService } from './ai-bridge.service'
import { WebSocketManager } from '../utils/websocket'
import fs from 'fs/promises'
import path from 'path'
import { v4 as uuidv4 } from 'uuid'

// å®šä¹‰æœåŠ¡æ¥å£
export interface SIPConnectionStatus {
  connected: boolean
  server: string
  extension: string
  registeredTime?: Date
  lastHeartbeat?: Date
}

export interface CallStatistics {
  totalCalls: number
  connectedCalls: number
  missedCalls: number
  averageDuration: number
  totalDuration: number
  todayCalls: number
  weekCalls: number
  monthCalls: number
}

export interface VoiceSynthesisRequest {
  text: string
  model: 'doubao' | 'azure' | 'google'
  voice: 'male' | 'female' | 'child'
  speed?: number
  pitch?: number
  volume?: number
  format?: 'mp3' | 'wav'
}

export interface VoiceSynthesisResponse {
  id: string
  audioUrl: string
  duration: number
  fileSize: number
  model: string
  voice: string
}

class CallCenterService {
  private wsManager: WebSocketManager
  private sipConnections: Map<string, any> = new Map()
  private activeCalls: Map<string, any> = new Map()

  constructor() {
    this.wsManager = new WebSocketManager()
    this.initializeWebSocket()
  }

  /**
   * åˆå§‹åŒ–WebSocketè¿æ¥
   */
  private initializeWebSocket() {
    this.wsManager.on('connection', (ws: any, userId: number) => {
      console.log(`âœ… å‘¼å«ä¸­å¿ƒWebSocketè¿æ¥å»ºç«‹: ç”¨æˆ·${userId}`)
    })

    this.wsManager.on('disconnect', (userId: number) => {
      console.log(`âŒ å‘¼å«ä¸­å¿ƒWebSocketè¿æ¥æ–­å¼€: ç”¨æˆ·${userId}`)
    })
  }

  /**
   * SIPè¿æ¥ç®¡ç†
   */
  async getSIPStatus(userId: number): Promise<SIPConnectionStatus> {
    try {
      const config = await SIPConfig.findOne({
        where: { createdBy: userId, status: 'active' },
        order: [['lastConnected', 'DESC']]
      })

      if (!config) {
        return {
          connected: false,
          server: '',
          extension: ''
        }
      }

      const connection = this.sipConnections.get(config.extension)
      return {
        connected: !!connection?.connected,
        server: `${config.server}:${config.port}`,
        extension: config.extension,
        registeredTime: config.lastConnected || undefined,
        lastHeartbeat: connection?.lastHeartbeat
      }
    } catch (error) {
      console.error('âŒ è·å–SIPçŠ¶æ€å¤±è´¥:', error)
      throw error
    }
  }

  async connectSIP(config: any, userId: number): Promise<SIPConnectionStatus> {
    try {
      // æŸ¥æ‰¾æˆ–åˆ›å»ºSIPé…ç½®
      let sipConfig = await SIPConfig.findOne({
        where: {
          extension: config.extension,
          createdBy: userId
        }
      })

      if (sipConfig) {
        await sipConfig.update({
          ...config,
          status: 'active',
          lastConnected: new Date()
        })
      } else {
        sipConfig = await SIPConfig.create({
          ...config,
          name: `SIPé…ç½®-${config.extension}`,
          createdBy: userId,
          status: 'active',
          lastConnected: new Date()
        })
      }

      // æ¨¡æ‹ŸSIPè¿æ¥
      const connection = {
        connected: true,
        server: `${config.server}:${config.port}`,
        extension: config.extension,
        lastHeartbeat: new Date(),
        config: sipConfig
      }

      this.sipConnections.set(config.extension, connection)

      // æ›´æ–°åˆ†æœºçŠ¶æ€
      await this.updateExtensionStatus(config.extension, 'online')

      console.log(`âœ… SIPè¿æ¥æˆåŠŸ: ${config.extension}@${config.server}`)

      return {
        connected: true,
        server: connection.server,
        extension: connection.extension,
        registeredTime: sipConfig.lastConnected,
        lastHeartbeat: connection.lastHeartbeat
      }
    } catch (error) {
      console.error('âŒ SIPè¿æ¥å¤±è´¥:', error)
      throw error
    }
  }

  async disconnectSIP(extension: string): Promise<void> {
    try {
      const connection = this.sipConnections.get(extension)
      if (connection) {
        connection.connected = false
        this.sipConnections.delete(extension)
      }

      // æ›´æ–°SIPé…ç½®çŠ¶æ€
      await SIPConfig.update(
        { status: 'inactive' },
        { where: { extension } }
      )

      // æ›´æ–°åˆ†æœºçŠ¶æ€
      await this.updateExtensionStatus(extension, 'offline')

      console.log(`âœ… SIPè¿æ¥æ–­å¼€: ${extension}`)
    } catch (error) {
      console.error('âŒ SIPæ–­å¼€å¤±è´¥:', error)
      throw error
    }
  }

  async testSIPConnection(config: any): Promise<{ success: boolean; message: string; latency: number }> {
    try {
      const startTime = Date.now()

      // æ¨¡æ‹Ÿè¿æ¥æµ‹è¯•
      await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 200))

      const latency = Date.now() - startTime
      const success = Math.random() > 0.1 // 90%æˆåŠŸç‡

      return {
        success,
        message: success ? 'è¿æ¥æµ‹è¯•æˆåŠŸ' : 'è¿æ¥æµ‹è¯•å¤±è´¥',
        latency
      }
    } catch (error) {
      console.error('âŒ SIPè¿æ¥æµ‹è¯•å¤±è´¥:', error)
      return {
        success: false,
        message: 'è¿æ¥æµ‹è¯•å¤±è´¥',
        latency: 0
      }
    }
  }

  /**
   * é€šè¯ç®¡ç†
   */
  async makeCall(data: {
    phoneNumber: string
    contactName?: string
    extension: string
    countryCode?: string
    userId: number
  }) {
    try {
      const callId = uuidv4()
      const startTime = new Date()

      // åˆ›å»ºé€šè¯è®°å½•
      const callRecord = await CallRecord.create({
        callId,
        phoneNumber: data.phoneNumber,
        contactName: data.contactName,
        direction: 'outbound',
        status: 'ringing',
        startTime,
        extension: data.extension,
        recordingEnabled: true,
        createdBy: data.userId
      })

      // æ›´æ–°åˆ†æœºçŠ¶æ€ä¸ºå¿™ç¢Œ
      await this.updateExtensionStatus(data.extension, 'busy', callRecord.id)

      // æ·»åŠ åˆ°æ´»è·ƒé€šè¯åˆ—è¡¨
      this.activeCalls.set(callId, {
        ...callRecord.toJSON(),
        connection: this.sipConnections.get(data.extension)
      })

      // é€šè¿‡WebSocketé€šçŸ¥
      this.wsManager.broadcast('call:initiated', {
        callId,
        phoneNumber: data.phoneNumber,
        contactName: data.contactName,
        extension: data.extension,
        status: 'ringing'
      })

      console.log(`ğŸ“ å‘èµ·é€šè¯: ${data.phoneNumber} (åˆ†æœº: ${data.extension})`)

      return callRecord
    } catch (error) {
      console.error('âŒ å‘èµ·é€šè¯å¤±è´¥:', error)
      throw error
    }
  }

  async answerCall(callId: string): Promise<void> {
    try {
      const call = await CallRecord.findOne({ where: { callId } })
      if (!call) {
        throw new Error('é€šè¯è®°å½•ä¸å­˜åœ¨')
      }

      await call.update({ status: 'connected' })

      // æ›´æ–°æ´»è·ƒé€šè¯çŠ¶æ€
      const activeCall = this.activeCalls.get(callId)
      if (activeCall) {
        activeCall.status = 'connected'
      }

      // WebSocketé€šçŸ¥
      this.wsManager.broadcast('call:answered', { callId, status: 'connected' })

      console.log(`âœ… é€šè¯æ¥å¬: ${callId}`)
    } catch (error) {
      console.error('âŒ æ¥å¬é€šè¯å¤±è´¥:', error)
      throw error
    }
  }

  async hangupCall(callId: string): Promise<void> {
    try {
      const call = await CallRecord.findOne({ where: { callId } })
      if (!call) {
        throw new Error('é€šè¯è®°å½•ä¸å­˜åœ¨')
      }

      const endTime = new Date()
      const duration = Math.floor((endTime.getTime() - call.startTime.getTime()) / 1000)

      await call.update({
        status: 'ended',
        endTime,
        duration
      })

      // æ›´æ–°åˆ†æœºçŠ¶æ€
      await this.updateExtensionStatus(call.extension, 'online')

      // ä»æ´»è·ƒé€šè¯åˆ—è¡¨ç§»é™¤
      this.activeCalls.delete(callId)

      // WebSocketé€šçŸ¥
      this.wsManager.broadcast('call:ended', {
        callId,
        status: 'ended',
        duration
      })

      console.log(`ğŸ“ é€šè¯ç»“æŸ: ${callId}, æ—¶é•¿: ${duration}ç§’`)
    } catch (error) {
      console.error('âŒ æŒ‚æ–­é€šè¯å¤±è´¥:', error)
      throw error
    }
  }

  async holdCall(callId: string): Promise<void> {
    try {
      const call = await CallRecord.findOne({ where: { callId } })
      if (!call) {
        throw new Error('é€šè¯è®°å½•ä¸å­˜åœ¨')
      }

      await call.update({ status: 'held' })

      // æ›´æ–°æ´»è·ƒé€šè¯çŠ¶æ€
      const activeCall = this.activeCalls.get(callId)
      if (activeCall) {
        activeCall.status = 'held'
      }

      // WebSocketé€šçŸ¥
      this.wsManager.broadcast('call:held', { callId, status: 'held' })

      console.log(`â¸ï¸ é€šè¯ä¿æŒ: ${callId}`)
    } catch (error) {
      console.error('âŒ ä¿æŒé€šè¯å¤±è´¥:', error)
      throw error
    }
  }

  async unholdCall(callId: string): Promise<void> {
    try {
      const call = await CallRecord.findOne({ where: { callId } })
      if (!call) {
        throw new Error('é€šè¯è®°å½•ä¸å­˜åœ¨')
      }

      await call.update({ status: 'connected' })

      // æ›´æ–°æ´»è·ƒé€šè¯çŠ¶æ€
      const activeCall = this.activeCalls.get(callId)
      if (activeCall) {
        activeCall.status = 'connected'
      }

      // WebSocketé€šçŸ¥
      this.wsManager.broadcast('call:unheld', { callId, status: 'connected' })

      console.log(`â–¶ï¸ é€šè¯æ¢å¤: ${callId}`)
    } catch (error) {
      console.error('âŒ æ¢å¤é€šè¯å¤±è´¥:', error)
      throw error
    }
  }

  async transferCall(callId: string, targetExtension: string): Promise<void> {
    try {
      const call = await CallRecord.findOne({ where: { callId } })
      if (!call) {
        throw new Error('é€šè¯è®°å½•ä¸å­˜åœ¨')
      }

      await call.update({
        status: 'transferred',
        transferTarget: targetExtension
      })

      // æ›´æ–°åˆ†æœºçŠ¶æ€
      await this.updateExtensionStatus(targetExtension, 'busy', call.id)

      // WebSocketé€šçŸ¥
      this.wsManager.broadcast('call:transferred', {
        callId,
        targetExtension,
        status: 'transferred'
      })

      console.log(`ğŸ”„ é€šè¯è½¬ç§»: ${callId} -> ${targetExtension}`)
    } catch (error) {
      console.error('âŒ è½¬ç§»é€šè¯å¤±è´¥:', error)
      throw error
    }
  }

  /**
   * å½•éŸ³ç®¡ç†
   */
  async startRecording(callId: string): Promise<void> {
    try {
      const call = await CallRecord.findOne({ where: { callId } })
      if (!call) {
        throw new Error('é€šè¯è®°å½•ä¸å­˜åœ¨')
      }

      await call.update({ recordingEnabled: true })

      // WebSocketé€šçŸ¥
      this.wsManager.broadcast('recording:started', { callId })

      console.log(`ğŸ™ï¸ å¼€å§‹å½•éŸ³: ${callId}`)
    } catch (error) {
      console.error('âŒ å¼€å§‹å½•éŸ³å¤±è´¥:', error)
      throw error
    }
  }

  async stopRecording(callId: string): Promise<CallRecording> {
    try {
      const call = await CallRecord.findOne({ where: { callId } })
      if (!call) {
        throw new Error('é€šè¯è®°å½•ä¸å­˜åœ¨')
      }

      // æ¨¡æ‹Ÿå½•éŸ³æ–‡ä»¶åˆ›å»º
      const recordingId = uuidv4()
      const filename = `recording_${recordingId}.mp3`
      const filePath = path.join(process.env.RECORDING_PATH || './recordings', filename)

      // ç¡®ä¿ç›®å½•å­˜åœ¨
      await fs.mkdir(path.dirname(filePath), { recursive: true })

      // åˆ›å»ºç©ºæ–‡ä»¶ï¼ˆå®é™…åº”ç”¨ä¸­è¿™é‡Œä¼šä¿å­˜çœŸå®çš„å½•éŸ³æ•°æ®ï¼‰
      await fs.writeFile(filePath, Buffer.alloc(0))

      const recording = await CallRecording.create({
        callId: call.id,
        filename,
        originalFilename: `é€šè¯å½•éŸ³_${call.phoneNumber}_${new Date().toISOString()}.mp3`,
        filePath,
        fileSize: 1024 * 100, // æ¨¡æ‹Ÿ100KB
        duration: call.duration || 0,
        format: 'mp3',
        quality: 'standard',
        status: 'completed',
        createdBy: call.createdBy
      })

      // æ›´æ–°é€šè¯è®°å½•
      await call.update({ recordingId: recording.id })

      // WebSocketé€šçŸ¥
      this.wsManager.broadcast('recording:stopped', {
        callId,
        recordingId: recording.id,
        duration: recording.duration
      })

      console.log(`â¹ï¸ åœæ­¢å½•éŸ³: ${callId}, å½•éŸ³ID: ${recording.id}`)

      return recording
    } catch (error) {
      console.error('âŒ åœæ­¢å½•éŸ³å¤±è´¥:', error)
      throw error
    }
  }

  async getRecordings(params: {
    page?: number
    pageSize?: number
    phoneNumber?: string
    contactName?: string
    startDate?: Date
    endDate?: Date
    status?: string
    userId: number
  }) {
    try {
      const { page = 1, pageSize = 20, userId, ...filters } = params
      const offset = (page - 1) * pageSize

      const whereClause: any = { createdBy: userId }

      if (filters.phoneNumber) {
        whereClause.phoneNumber = { [Op.like]: `%${filters.phoneNumber}%` }
      }

      if (filters.contactName) {
        whereClause.contactName = { [Op.like]: `%${filters.contactName}%` }
      }

      if (filters.startDate || filters.endDate) {
        whereClause.startTime = {}
        if (filters.startDate) {
          whereClause.startTime[Op.gte] = filters.startDate
        }
        if (filters.endDate) {
          whereClause.startTime[Op.lte] = filters.endDate
        }
      }

      if (filters.status && filters.status !== 'all') {
        whereClause.status = filters.status
      }

      const { count, rows } = await CallRecord.findAndCountAll({
        where: whereClause,
        include: [
          {
            model: CallRecording,
            as: 'recording',
            required: false
          }
        ],
        order: [['startTime', 'DESC']],
        limit: pageSize,
        offset
      })

      return {
        list: rows,
        total: count,
        page,
        pageSize,
        totalPages: Math.ceil(count / pageSize)
      }
    } catch (error) {
      console.error('âŒ è·å–å½•éŸ³åˆ—è¡¨å¤±è´¥:', error)
      throw error
    }
  }

  /**
   * AIåˆ†æåŠŸèƒ½
   */
  async analyzeCall(callId: string): Promise<any> {
    try {
      const call = await CallRecord.findOne({
        where: { callId },
        include: [
          {
            model: CallRecording,
            as: 'recording'
          }
        ]
      })

      const recording = (call as any).recording;
      if (!call || !recording) {
        throw new Error('é€šè¯å½•éŸ³ä¸å­˜åœ¨')
      }

      // ä½¿ç”¨AIBridgeè¿›è¡ŒAIåˆ†æ
      const aiBridge = new AIBridgeService()

      // æ¨¡æ‹Ÿåˆ†æè¿‡ç¨‹
      const analysisData = {
        sentiment: (Math.random() > 0.5 ? 'positive' : 'neutral') as 'positive' | 'neutral' | 'negative',
        sentimentScore: Math.random() * 0.8 + 0.2,
        keywords: ['å’¨è¯¢', 'æŠ¥å', 'è¯¾ç¨‹', 'æ—¶é—´', 'è´¹ç”¨'],
        summary: 'å®¢æˆ·å’¨è¯¢äº†å¹¼å„¿å›­çš„è¯¾ç¨‹ä¿¡æ¯å’Œè´¹ç”¨æƒ…å†µï¼Œå¯¹æ•™å­¦è´¨é‡æ¯”è¾ƒå…³æ³¨ï¼Œè¡¨ç¤ºä¼šè¿›ä¸€æ­¥è€ƒè™‘ã€‚',
        actionItems: [
          'å‘é€è¯¦ç»†è¯¾ç¨‹èµ„æ–™',
          'é¢„çº¦å®åœ°å‚è§‚',
          'æä¾›è¯•å¬è¯¾ç¨‹å®‰æ’'
        ],
        customerSatisfaction: Math.floor(Math.random() * 30 + 70), // 70-100
        agentPerformance: {
          tone: 'professional' as 'professional' | 'friendly' | 'rushed' | 'unclear',
          clarity: Math.floor(Math.random() * 30 + 70),
          empathy: Math.floor(Math.random() * 30 + 70),
          efficiency: Math.floor(Math.random() * 30 + 70)
        },
        businessInsights: {
          category: 'æ‹›ç”Ÿå’¨è¯¢',
          priority: 'high' as 'high' | 'medium' | 'low',
          followUpRequired: true
        },
        processingTime: Math.floor(Math.random() * 2000 + 1000),
        modelVersion: '1.0.0'
      }

      const analysis = await CallAnalysis.create({
        callId: call.id,
        recordingId: recording.id,
        ...analysisData
      })

      // æ›´æ–°å½•éŸ³è®°å½•çš„åˆ†æID
      await recording.update({ aiAnalysisId: analysis.id })

      console.log(`ğŸ§  AIåˆ†æå®Œæˆ: ${callId}`)

      return analysis
    } catch (error) {
      console.error('âŒ AIåˆ†æå¤±è´¥:', error)
      throw error
    }
  }

  async synthesizeVoice(request: VoiceSynthesisRequest): Promise<VoiceSynthesisResponse> {
    try {
      // ä½¿ç”¨AIBridgeè¿›è¡Œè¯­éŸ³åˆæˆ
      const aiBridge = new AIBridgeService()

      // æ¨¡æ‹Ÿè¯­éŸ³åˆæˆ
      const synthesisId = uuidv4()
      const audioData = await aiBridge.textToSpeech(request.text, {
        voice: request.voice,
        model: request.model,
        speed: request.speed || 1.0,
        pitch: request.pitch || 1.0
      })

      const response: VoiceSynthesisResponse = {
        id: synthesisId,
        audioUrl: `/api/call-center/ai/audio/${synthesisId}`,
        duration: Math.floor(request.text.length * 0.1), // ä¼°ç®—æ—¶é•¿
        fileSize: audioData.length,
        model: request.model,
        voice: request.voice
      }

      console.log(`ğŸ”Š è¯­éŸ³åˆæˆå®Œæˆ: ${synthesisId}`)

      return response
    } catch (error) {
      console.error('âŒ è¯­éŸ³åˆæˆå¤±è´¥:', error)
      throw error
    }
  }

  /**
   * åˆ†æœºç®¡ç†
   */
  async getExtensions(userId: number): Promise<Extension[]> {
    try {
      const extensions = await Extension.findAll({
        where: { isActive: true },
        order: [['extension', 'ASC']]
      })

      return extensions
    } catch (error) {
      console.error('âŒ è·å–åˆ†æœºåˆ—è¡¨å¤±è´¥:', error)
      throw error
    }
  }

  async updateExtensionStatus(
    extension: string,
    status: 'online' | 'offline' | 'busy' | 'away',
    currentCallId?: number
  ): Promise<void> {
    try {
      const updateData: any = {
        status,
        lastActiveTime: new Date()
      }

      if (currentCallId) {
        updateData.currentCallId = currentCallId
      } else if (status === 'online') {
        updateData.currentCallId = null
      }

      await Extension.update(updateData, {
        where: { extension }
      })

      // WebSocketé€šçŸ¥åˆ†æœºçŠ¶æ€æ›´æ–°
      this.wsManager.broadcast('extension:status', {
        extension,
        status,
        currentCallId
      })

      console.log(`ğŸ“± åˆ†æœºçŠ¶æ€æ›´æ–°: ${extension} -> ${status}`)
    } catch (error) {
      console.error('âŒ æ›´æ–°åˆ†æœºçŠ¶æ€å¤±è´¥:', error)
      throw error
    }
  }

  /**
   * è”ç³»äººç®¡ç†
   */
  async getContacts(params: {
    page?: number
    pageSize?: number
    search?: string
    tags?: string[]
    userId: number
  }) {
    try {
      const { page = 1, pageSize = 20, userId, search, tags } = params
      const offset = (page - 1) * pageSize

      const whereClause: any = { createdBy: userId, isActive: true }

      if (search) {
        whereClause[Op.or] = [
          { name: { [Op.like]: `%${search}%` } },
          { phone: { [Op.like]: `%${search}%` } },
          { company: { [Op.like]: `%${search}%` } }
        ]
      }

      if (tags && tags.length > 0) {
        whereClause.tags = { [Op.overlap]: tags }
      }

      const { count, rows } = await Contact.findAndCountAll({
        where: whereClause,
        order: [['lastCallTime', 'DESC']],
        limit: pageSize,
        offset
      })

      return {
        list: rows,
        total: count,
        page,
        pageSize,
        totalPages: Math.ceil(count / pageSize)
      }
    } catch (error) {
      console.error('âŒ è·å–è”ç³»äººåˆ—è¡¨å¤±è´¥:', error)
      throw error
    }
  }

  /**
   * ç»Ÿè®¡æ•°æ®
   */
  async getStatistics(period: 'today' | 'week' | 'month' = 'today'): Promise<CallStatistics> {
    try {
      const now = new Date()
      let startDate: Date

      switch (period) {
        case 'today':
          startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate())
          break
        case 'week':
          startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
          break
        case 'month':
          startDate = new Date(now.getFullYear(), now.getMonth(), 1)
          break
      }

      const records = await CallRecord.findAll({
        where: {
          startTime: { [Op.gte]: startDate }
        }
      })

      const totalCalls = records.length
      const connectedCalls = records.filter(r => r.status === 'connected' || r.status === 'ended').length
      const missedCalls = records.filter(r => r.status === 'missed').length
      const totalDuration = records.reduce((sum, r) => sum + (r.duration || 0), 0)
      const averageDuration = connectedCalls > 0 ? Math.floor(totalDuration / connectedCalls) : 0

      return {
        totalCalls,
        connectedCalls,
        missedCalls,
        averageDuration,
        totalDuration,
        todayCalls: period === 'today' ? totalCalls : await this.getTodayCalls(),
        weekCalls: period === 'week' ? totalCalls : await this.getWeekCalls(),
        monthCalls: period === 'month' ? totalCalls : await this.getMonthCalls()
      }
    } catch (error) {
      console.error('âŒ è·å–ç»Ÿè®¡æ•°æ®å¤±è´¥:', error)
      throw error
    }
  }

  private async getTodayCalls(): Promise<number> {
    const today = new Date()
    today.setHours(0, 0, 0, 0)

    return await CallRecord.count({
      where: {
        startTime: { [Op.gte]: today }
      }
    })
  }

  private async getWeekCalls(): Promise<number> {
    const weekAgo = new Date()
    weekAgo.setDate(weekAgo.getDate() - 7)

    return await CallRecord.count({
      where: {
        startTime: { [Op.gte]: weekAgo }
      }
    })
  }

  private async getMonthCalls(): Promise<number> {
    const monthAgo = new Date()
    monthAgo.setMonth(monthAgo.getMonth() - 1)

    return await CallRecord.count({
      where: {
        startTime: { [Op.gte]: monthAgo }
      }
    })
  }

  /**
   * æ¦‚è§ˆæ•°æ®
   */
  async getOverview(userId: number) {
    try {
      const [
        sipStatus,
        activeCallsData,
        callHistoryData,
        statistics,
        extensionsData,
        recentRecordings
      ] = await Promise.all([
        this.getSIPStatus(userId),
        this.getActiveCalls(),
        this.getCallHistory(userId),
        this.getStatistics('today'),
        this.getExtensions(userId),
        this.getRecentRecordings(userId)
      ])

      return {
        sipStatus,
        activeCalls: activeCallsData,
        callHistory: callHistoryData,
        statistics,
        extensions: extensionsData,
        recentRecordings
      }
    } catch (error) {
      console.error('âŒ è·å–æ¦‚è§ˆæ•°æ®å¤±è´¥:', error)
      throw error
    }
  }

  async getActiveCalls(): Promise<any[]> {
    return Array.from(this.activeCalls.values()).map(call => ({
      id: call.callId,
      phoneNumber: call.phoneNumber,
      contactName: call.contactName,
      status: call.status,
      startTime: call.startTime,
      duration: call.duration || 0,
      recording: call.recordingEnabled,
      extension: call.extension,
      direction: call.direction
    }))
  }

  private async getCallHistory(userId: number): Promise<any[]> {
    const records = await CallRecord.findAll({
      where: { createdBy: userId },
      include: [
        {
          model: CallRecording,
          as: 'recording',
          required: false
        }
      ],
      order: [['startTime', 'DESC']],
      limit: 10
    })

    return records.map(record => ({
      id: record.callId,
      phoneNumber: record.phoneNumber,
      contactName: record.contactName,
      status: record.status,
      startTime: record.startTime,
      duration: record.duration,
      recording: !!(record as any).recording,
      extension: record.extension,
      direction: record.direction
    }))
  }

  private async getRecentRecordings(userId: number): Promise<any[]> {
    const recordings = await CallRecording.findAll({
      where: { createdBy: userId },
      include: [
        {
          model: CallRecord,
          as: 'callRecord',
          required: true
        }
      ],
      order: [['createdAt', 'DESC']],
      limit: 5
    })

    return recordings.map(recording => {
      const callRecord = (recording as any).callRecord;
      return {
        id: recording.id,
        callId: callRecord?.callId || '',
        phoneNumber: callRecord?.phoneNumber || '',
        contactName: callRecord?.contactName || '',
        startTime: callRecord?.startTime || new Date(),
        duration: recording.duration,
        fileSize: recording.fileSize,
        transcript: recording.transcript,
        analysisId: recording.aiAnalysisId
      };
    })
  }
}

export default new CallCenterService()