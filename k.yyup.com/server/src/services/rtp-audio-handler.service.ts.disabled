/**
 * RTPéŸ³é¢‘æµå¤„ç†æœåŠ¡
 * 
 * åŠŸèƒ½ï¼š
 * 1. æ¥æ”¶æ¥è‡ªSIPæœåŠ¡å™¨çš„RTPéŸ³é¢‘æµ
 * 2. å°†éŸ³é¢‘æµå‘é€ç»™è±†åŒ…å®æ—¶è¯­éŸ³æœåŠ¡è¿›è¡ŒASR+LLM+TTSå¤„ç†
 * 3. å°†åˆæˆçš„è¯­éŸ³é€šè¿‡RTPå‘é€å›SIPæœåŠ¡å™¨
 * 
 * RTPåè®®ï¼š
 * - ç«¯å£èŒƒå›´ï¼š10000-20000
 * - ç¼–ç æ ¼å¼ï¼šPCM 16kHz 16bit mono
 * - ä¼ è¾“åè®®ï¼šUDP
 */

import dgram from 'dgram';
import { EventEmitter } from 'events';
import { doubaoRealtimeVoiceService } from './doubao-realtime-voice.service';

interface RTPSession {
  callId: string;
  localPort: number;
  remoteHost: string;
  remotePort: number;
  socket: dgram.Socket;
  voiceSessionId?: string;
  audioBuffer: Buffer[];
  lastPacketTime: number;
  sequenceNumber: number;
  timestamp: number;
  ssrc: number;
}

interface RTPHeader {
  version: number;
  padding: boolean;
  extension: boolean;
  csrcCount: number;
  marker: boolean;
  payloadType: number;
  sequenceNumber: number;
  timestamp: number;
  ssrc: number;
}

export class RTPAudioHandlerService extends EventEmitter {
  private static instance: RTPAudioHandlerService;
  private activeSessions: Map<string, RTPSession> = new Map();
  private portPool: Set<number> = new Set();
  private readonly PORT_RANGE_START = 10000;
  private readonly PORT_RANGE_END = 20000;
  private readonly AUDIO_BUFFER_SIZE = 48000; // 1.5ç§’çš„PCMæ•°æ® (16kHz * 2 bytes * 1.5)

  private constructor() {
    super();
    this.initializePortPool();
    this.setupVoiceServiceListeners();
  }

  static getInstance(): RTPAudioHandlerService {
    if (!RTPAudioHandlerService.instance) {
      RTPAudioHandlerService.instance = new RTPAudioHandlerService();
    }
    return RTPAudioHandlerService.instance;
  }

  /**
   * åˆå§‹åŒ–ç«¯å£æ± 
   */
  private initializePortPool(): void {
    for (let port = this.PORT_RANGE_START; port <= this.PORT_RANGE_END; port += 2) {
      this.portPool.add(port);
    }
    console.log(`ğŸ“Š RTPç«¯å£æ± åˆå§‹åŒ–å®Œæˆ: ${this.portPool.size} ä¸ªå¯ç”¨ç«¯å£`);
  }

  /**
   * åˆ†é…RTPç«¯å£
   */
  private allocatePort(): number | null {
    const availablePorts = Array.from(this.portPool);
    if (availablePorts.length === 0) {
      console.error('âŒ æ²¡æœ‰å¯ç”¨çš„RTPç«¯å£');
      return null;
    }
    const port = availablePorts[0];
    this.portPool.delete(port);
    return port;
  }

  /**
   * é‡Šæ”¾RTPç«¯å£
   */
  private releasePort(port: number): void {
    this.portPool.add(port);
  }

  /**
   * è®¾ç½®è¯­éŸ³æœåŠ¡ç›‘å¬å™¨
   */
  private setupVoiceServiceListeners(): void {
    // ç›‘å¬AIè¯­éŸ³å›å¤
    doubaoRealtimeVoiceService.on('ai-response', (data: any) => {
      this.handleAIResponse(data);
    });

    // ç›‘å¬ä¼šè¯é”™è¯¯
    doubaoRealtimeVoiceService.on('session-error', (data: any) => {
      console.error(`âŒ è¯­éŸ³æœåŠ¡é”™è¯¯ (${data.callId}):`, data.error);
      this.emit('session-error', data);
    });
  }

  /**
   * åˆ›å»ºRTPä¼šè¯
   */
  public async createSession(
    callId: string,
    remoteHost: string,
    remotePort: number,
    customerId?: number,
    systemPrompt?: string
  ): Promise<{ localPort: number; sessionId: string }> {
    const localPort = this.allocatePort();
    if (!localPort) {
      throw new Error('æ— æ³•åˆ†é…RTPç«¯å£');
    }

    // åˆ›å»ºUDP socket
    const socket = dgram.createSocket('udp4');

    // ç»‘å®šæœ¬åœ°ç«¯å£
    await new Promise<void>((resolve, reject) => {
      socket.bind(localPort, () => {
        console.log(`âœ… RTP Socketç»‘å®šåˆ°ç«¯å£: ${localPort}`);
        resolve();
      });
      socket.on('error', reject);
    });

    // åˆ›å»ºè±†åŒ…å®æ—¶è¯­éŸ³ä¼šè¯
    const voiceSessionId = await doubaoRealtimeVoiceService.createSession(
      callId,
      customerId,
      systemPrompt
    );

    // åˆ›å»ºRTPä¼šè¯
    const session: RTPSession = {
      callId,
      localPort,
      remoteHost,
      remotePort,
      socket,
      voiceSessionId,
      audioBuffer: [],
      lastPacketTime: Date.now(),
      sequenceNumber: Math.floor(Math.random() * 65536),
      timestamp: 0,
      ssrc: Math.floor(Math.random() * 0xFFFFFFFF)
    };

    // è®¾ç½®socketç›‘å¬å™¨
    socket.on('message', (msg: Buffer, rinfo: dgram.RemoteInfo) => {
      this.handleRTPPacket(callId, msg, rinfo);
    });

    socket.on('error', (error: Error) => {
      console.error(`âŒ RTP Socketé”™è¯¯ (${callId}):`, error.message);
      this.emit('rtp-error', { callId, error: error.message });
    });

    this.activeSessions.set(callId, session);
    console.log(`ğŸ“ åˆ›å»ºRTPä¼šè¯: ${callId}, æœ¬åœ°ç«¯å£: ${localPort}, è¿œç¨‹: ${remoteHost}:${remotePort}`);

    return { localPort, sessionId: voiceSessionId };
  }

  /**
   * å¤„ç†æ¥æ”¶åˆ°çš„RTPæ•°æ®åŒ…
   */
  private handleRTPPacket(callId: string, packet: Buffer, rinfo: dgram.RemoteInfo): void {
    const session = this.activeSessions.get(callId);
    if (!session) {
      console.warn(`âš ï¸  æœªæ‰¾åˆ°RTPä¼šè¯: ${callId}`);
      return;
    }

    // è§£æRTPå¤´éƒ¨
    const header = this.parseRTPHeader(packet);
    if (!header) {
      console.error(`âŒ æ— æ•ˆçš„RTPæ•°æ®åŒ… (${callId})`);
      return;
    }

    // æå–éŸ³é¢‘æ•°æ®ï¼ˆè·³è¿‡RTPå¤´éƒ¨ï¼Œé€šå¸¸æ˜¯12å­—èŠ‚ï¼‰
    const audioData = packet.slice(12);
    
    // æ·»åŠ åˆ°ç¼“å†²åŒº
    session.audioBuffer.push(audioData);
    session.lastPacketTime = Date.now();

    // è®¡ç®—ç¼“å†²åŒºå¤§å°
    const totalBufferSize = session.audioBuffer.reduce((sum, buf) => sum + buf.length, 0);

    // å½“ç¼“å†²åŒºè¾¾åˆ°1ç§’æ•°æ®æ—¶ï¼Œå‘é€ç»™è¯­éŸ³æœåŠ¡
    if (totalBufferSize >= this.AUDIO_BUFFER_SIZE) {
      this.flushAudioBuffer(callId);
    }
  }

  /**
   * è§£æRTPå¤´éƒ¨
   */
  private parseRTPHeader(packet: Buffer): RTPHeader | null {
    if (packet.length < 12) {
      return null;
    }

    const byte0 = packet[0];
    const byte1 = packet[1];

    return {
      version: (byte0 >> 6) & 0x03,
      padding: ((byte0 >> 5) & 0x01) === 1,
      extension: ((byte0 >> 4) & 0x01) === 1,
      csrcCount: byte0 & 0x0F,
      marker: ((byte1 >> 7) & 0x01) === 1,
      payloadType: byte1 & 0x7F,
      sequenceNumber: packet.readUInt16BE(2),
      timestamp: packet.readUInt32BE(4),
      ssrc: packet.readUInt32BE(8)
    };
  }

  /**
   * åˆ·æ–°éŸ³é¢‘ç¼“å†²åŒº
   */
  private async flushAudioBuffer(callId: string): Promise<void> {
    const session = this.activeSessions.get(callId);
    if (!session || session.audioBuffer.length === 0) {
      return;
    }

    // åˆå¹¶éŸ³é¢‘æ•°æ®
    const audioData = Buffer.concat(session.audioBuffer);
    session.audioBuffer = [];

    console.log(`ğŸ“¤ [RTPâ†’ASR] å‘é€éŸ³é¢‘åˆ°è¯­éŸ³æœåŠ¡: ${audioData.length} bytes (${callId})`);
    console.log(`   VoiceSessionId: ${session.voiceSessionId}`);

    // å‘é€ç»™è±†åŒ…å®æ—¶è¯­éŸ³æœåŠ¡
    if (session.voiceSessionId) {
      try {
        await doubaoRealtimeVoiceService.sendAudio(session.voiceSessionId, audioData);
        console.log(`âœ… [RTPâ†’ASR] éŸ³é¢‘å‘é€æˆåŠŸ (${callId})`);
      } catch (error) {
        console.error(`âŒ [RTPâ†’ASR] å‘é€éŸ³é¢‘å¤±è´¥ (${callId}):`, error);
      }
    } else {
      console.error(`âŒ [RTPâ†’ASR] VoiceSessionIdä¸ºç©º (${callId})`);
    }
  }

  /**
   * å¤„ç†AIè¯­éŸ³å›å¤
   */
  private handleAIResponse(data: any): void {
    const { sessionId, callId, audioData, text } = data;

    // ä¼˜å…ˆä½¿ç”¨callIdï¼Œå¦‚æœæ²¡æœ‰åˆ™é€šè¿‡sessionIdæŸ¥æ‰¾
    let targetCallId = callId;
    if (!targetCallId) {
      // é€šè¿‡sessionIdæŸ¥æ‰¾callId
      for (const [cid, session] of this.activeSessions.entries()) {
        if (session.voiceSessionId === sessionId) {
          targetCallId = cid;
          break;
        }
      }
    }

    const session = this.activeSessions.get(targetCallId);

    if (!session) {
      console.warn(`âš ï¸  æœªæ‰¾åˆ°RTPä¼šè¯: ${targetCallId || sessionId}`);
      return;
    }

    console.log(`ğŸ”Š å‘é€AIè¯­éŸ³å›å¤ (${targetCallId}): ${text}, éŸ³é¢‘å¤§å°: ${audioData?.length || 0} bytes`);

    if (!audioData || audioData.length === 0) {
      console.error(`âŒ AIå›å¤éŸ³é¢‘æ•°æ®ä¸ºç©º (${targetCallId})`);
      return;
    }

    // å°†éŸ³é¢‘æ•°æ®å°è£…æˆRTPåŒ…å¹¶å‘é€
    this.sendRTPAudio(targetCallId, audioData);
  }

  /**
   * å‘é€RTPéŸ³é¢‘æ•°æ®
   */
  private sendRTPAudio(callId: string, audioData: Buffer): void {
    const session = this.activeSessions.get(callId);
    if (!session) {
      return;
    }

    // å°†éŸ³é¢‘æ•°æ®åˆ†å‰²æˆRTPåŒ…ï¼ˆæ¯åŒ…160å­—èŠ‚ï¼Œå¯¹åº”10mséŸ³é¢‘ï¼‰
    const PACKET_SIZE = 160;
    const packets = [];

    for (let offset = 0; offset < audioData.length; offset += PACKET_SIZE) {
      const chunk = audioData.slice(offset, Math.min(offset + PACKET_SIZE, audioData.length));
      const rtpPacket = this.buildRTPPacket(session, chunk);
      packets.push(rtpPacket);
      
      session.sequenceNumber = (session.sequenceNumber + 1) % 65536;
      session.timestamp += 160; // 10ms @ 16kHz
    }

    // å‘é€æ‰€æœ‰RTPåŒ…
    packets.forEach((packet, index) => {
      setTimeout(() => {
        session.socket.send(packet, session.remotePort, session.remoteHost, (error) => {
          if (error) {
            console.error(`âŒ å‘é€RTPåŒ…å¤±è´¥ (${callId}):`, error.message);
          }
        });
      }, index * 10); // æ¯10mså‘é€ä¸€ä¸ªåŒ…
    });

    console.log(`ğŸ“¤ å‘é€RTPéŸ³é¢‘: ${packets.length} ä¸ªåŒ… (${callId})`);
  }

  /**
   * æ„å»ºRTPæ•°æ®åŒ…
   */
  private buildRTPPacket(session: RTPSession, audioData: Buffer): Buffer {
    const header = Buffer.alloc(12);
    
    // Byte 0: V(2) P(1) X(1) CC(4)
    header[0] = 0x80; // Version 2, no padding, no extension, no CSRC
    
    // Byte 1: M(1) PT(7)
    header[1] = 0x00; // No marker, payload type 0 (PCMU)
    
    // Bytes 2-3: Sequence number
    header.writeUInt16BE(session.sequenceNumber, 2);
    
    // Bytes 4-7: Timestamp
    header.writeUInt32BE(session.timestamp, 4);
    
    // Bytes 8-11: SSRC
    header.writeUInt32BE(session.ssrc, 8);
    
    return Buffer.concat([header, audioData]);
  }

  /**
   * ç»“æŸRTPä¼šè¯
   */
  public async endSession(callId: string): Promise<void> {
    const session = this.activeSessions.get(callId);
    if (!session) {
      return;
    }

    console.log(`ğŸ“ ç»“æŸRTPä¼šè¯: ${callId}`);

    // åˆ·æ–°å‰©ä½™çš„éŸ³é¢‘ç¼“å†²åŒº
    if (session.audioBuffer.length > 0) {
      await this.flushAudioBuffer(callId);
    }

    // ç»“æŸè¯­éŸ³æœåŠ¡ä¼šè¯
    if (session.voiceSessionId) {
      await doubaoRealtimeVoiceService.endSession(session.voiceSessionId);
    }

    // å…³é—­socket
    session.socket.close();

    // é‡Šæ”¾ç«¯å£
    this.releasePort(session.localPort);

    // åˆ é™¤ä¼šè¯
    this.activeSessions.delete(callId);
  }

  /**
   * è·å–ä¼šè¯ä¿¡æ¯
   */
  public getSessionInfo(callId: string): RTPSession | undefined {
    return this.activeSessions.get(callId);
  }

  /**
   * è·å–æ´»è·ƒä¼šè¯æ•°
   */
  public getActiveSessionCount(): number {
    return this.activeSessions.size;
  }
}

// å¯¼å‡ºå•ä¾‹
export const rtpAudioHandlerService = RTPAudioHandlerService.getInstance();

