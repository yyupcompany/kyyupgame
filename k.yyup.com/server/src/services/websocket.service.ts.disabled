/**
 * WebSocketæœåŠ¡
 * å¤„ç†å‘¼å«ä¸­å¿ƒçš„å®æ—¶é€šä¿¡
 */

import { Server as SocketIOServer, Socket } from 'socket.io'
import { Server as HTTPServer } from 'http'
import jwt from 'jsonwebtoken'
import sipService from './sip.service'
import recordingService from './recording.service'

interface AuthenticatedSocket extends Socket {
  userId?: number
  userRole?: string
}

class WebSocketService {
  private io: SocketIOServer | null = null
  private connectedUsers: Map<number, Set<string>> = new Map()
  private userSockets: Map<string, number> = new Map()

  /**
   * åˆå§‹åŒ–WebSocketæœåŠ¡
   */
  initialize(server: HTTPServer): void {
    this.io = new SocketIOServer(server, {
      cors: {
        origin: process.env.FRONTEND_URL || "http://localhost:5173",
        methods: ["GET", "POST"],
        credentials: true
      },
      path: '/socket.io/call-center'
    })

    // è®¤è¯ä¸­é—´ä»¶
    this.io.use(this.authenticateSocket.bind(this))

    // è¿æ¥å¤„ç†
    this.io.on('connection', this.handleConnection.bind(this))

    console.log('ğŸ”Œ å‘¼å«ä¸­å¿ƒWebSocketæœåŠ¡å·²å¯åŠ¨')
  }

  /**
   * Socketè®¤è¯
   */
  private async authenticateSocket(socket: any, next: any): Promise<void> {
    try {
      const token = socket.handshake.auth.token || socket.handshake.headers.authorization?.replace('Bearer ', '')

      if (!token) {
        return next(new Error('è®¤è¯å¤±è´¥ï¼šç¼ºå°‘token'))
      }

      // éªŒè¯JWT token
      const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any
      socket.userId = decoded.id
      socket.userRole = decoded.role

      console.log(`ğŸ” ç”¨æˆ· ${socket.userId} (${socket.userRole}) WebSocketè®¤è¯æˆåŠŸ`)
      next()
    } catch (error) {
      console.error('âŒ WebSocketè®¤è¯å¤±è´¥:', error)
      next(new Error('è®¤è¯å¤±è´¥ï¼šæ— æ•ˆtoken'))
    }
  }

  /**
   * å¤„ç†è¿æ¥
   */
  private handleConnection(socket: AuthenticatedSocket): void {
    const userId = socket.userId!
    const socketId = socket.id

    console.log(`ğŸ‘¤ ç”¨æˆ· ${userId} å·²è¿æ¥åˆ°å‘¼å«ä¸­å¿ƒ`)

    // è®°å½•ç”¨æˆ·è¿æ¥
    if (!this.connectedUsers.has(userId)) {
      this.connectedUsers.set(userId, new Set())
    }
    this.connectedUsers.get(userId)!.add(socketId)
    this.userSockets.set(socketId, userId)

    // åŠ å…¥ç”¨æˆ·ä¸“å±æˆ¿é—´
    socket.join(`user_${userId}`)

    // æ ¹æ®è§’è‰²åŠ å…¥ç›¸åº”æˆ¿é—´
    if (socket.userRole) {
      socket.join(`role_${socket.userRole}`)
    }

    // å‘é€è¿æ¥æˆåŠŸæ¶ˆæ¯
    socket.emit('connected', {
      message: 'å·²è¿æ¥åˆ°å‘¼å«ä¸­å¿ƒ',
      userId,
      socketId,
      timestamp: new Date().toISOString()
    })

    // ç»‘å®šäº‹ä»¶å¤„ç†å™¨
    this.bindEventHandlers(socket)

    // å¤„ç†æ–­å¼€è¿æ¥
    socket.on('disconnect', () => {
      this.handleDisconnect(socket)
    })
  }

  /**
   * ç»‘å®šäº‹ä»¶å¤„ç†å™¨
   */
  private bindEventHandlers(socket: AuthenticatedSocket): void {
    const userId = socket.userId!

    // SIPç›¸å…³äº‹ä»¶
    socket.on('sip:connect', async (config) => {
      try {
        const success = await sipService.initialize(config)
        socket.emit('sip:connected', { success, config })

        if (success) {
          // é€šçŸ¥å…¶ä»–ç”¨æˆ·SIPçŠ¶æ€å˜åŒ–
          socket.to(`role_${socket.userRole}`).emit('sip:status_changed', {
            userId,
            status: 'online'
          })
        }
      } catch (error) {
        socket.emit('sip:error', { error: error.message })
      }
    })

    socket.on('sip:disconnect', async () => {
      try {
        await sipService.disconnect()
        socket.emit('sip:disconnected', { success: true })

        // é€šçŸ¥å…¶ä»–ç”¨æˆ·SIPçŠ¶æ€å˜åŒ–
        socket.to(`role_${socket.userRole}`).emit('sip:status_changed', {
          userId,
          status: 'offline'
        })
      } catch (error) {
        socket.emit('sip:error', { error: error.message })
      }
    })

    socket.on('sip:make_call', async (data) => {
      try {
        const call = await sipService.makeCall(data.targetNumber, data.options)
        socket.emit('call:initiated', { call })

        // é€šçŸ¥ç›¸å…³ç”¨æˆ·æœ‰æ–°é€šè¯
        this.broadcastToRole('call:initiated', {
          call,
          initiatedBy: userId
        }, socket.userRole!)
      } catch (error) {
        socket.emit('call:error', { error: error.message })
      }
    })

    socket.on('sip:answer_call', async (data) => {
      try {
        const success = await sipService.answerCall(data.callId)
        socket.emit('call:answered', { callId: data.callId, success })

        if (success) {
          this.broadcastToRole('call:answered', {
            callId: data.callId,
            answeredBy: userId
          }, socket.userRole!)
        }
      } catch (error) {
        socket.emit('call:error', { callId: data.callId, error: error.message })
      }
    })

    socket.on('sip:hangup_call', async (data) => {
      try {
        const success = await sipService.hangupCall(data.callId)
        socket.emit('call:ended', { callId: data.callId, success })

        if (success) {
          this.broadcastToRole('call:ended', {
            callId: data.callId,
            endedBy: userId
          }, socket.userRole!)
        }
      } catch (error) {
        socket.emit('call:error', { callId: data.callId, error: error.message })
      }
    })

    socket.on('sip:hold_call', async (data) => {
      try {
        const success = await sipService.holdCall(data.callId)
        socket.emit('call:held', { callId: data.callId, success })
      } catch (error) {
        socket.emit('call:error', { callId: data.callId, error: error.message })
      }
    })

    socket.on('sip:unhold_call', async (data) => {
      try {
        const success = await sipService.unholdCall(data.callId)
        socket.emit('call:unheld', { callId: data.callId, success })
      } catch (error) {
        socket.emit('call:error', { callId: data.callId, error: error.message })
      }
    })

    socket.on('sip:transfer_call', async (data) => {
      try {
        const success = await sipService.transferCall(data.callId, data.targetNumber)
        socket.emit('call:transferred', { callId: data.callId, targetNumber: data.targetNumber, success })
      } catch (error) {
        socket.emit('call:error', { callId: data.callId, error: error.message })
      }
    })

    socket.on('sip:send_dtmf', async (data) => {
      try {
        const success = await sipService.sendDTMF(data.callId, data.digits)
        socket.emit('dtmf:sent', { callId: data.callId, digits: data.digits, success })
      } catch (error) {
        socket.emit('dtmf:error', { callId: data.callId, error: error.message })
      }
    })

    // å½•éŸ³ç›¸å…³äº‹ä»¶
    socket.on('recording:start', async (data) => {
      try {
        const recording = await recordingService.startRecording(data.callId, data.audioStream)
        socket.emit('recording:started', { recording })
      } catch (error) {
        socket.emit('recording:error', { error: error.message })
      }
    })

    socket.on('recording:stop', async (data) => {
      try {
        const recording = await recordingService.stopRecording(data.callId)
        socket.emit('recording:stopped', { recording })
      } catch (error) {
        socket.emit('recording:error', { error: error.message })
      }
    })

    socket.on('recording:transcribe', async (data) => {
      try {
        const success = await recordingService.requestTranscription(data.recordingId, data.language)
        socket.emit('recording:transcribe_requested', { recordingId: data.recordingId, success })
      } catch (error) {
        socket.emit('recording:error', { error: error.message })
      }
    })

    socket.on('recording:update_transcript', async (data) => {
      try {
        const success = await recordingService.updateTranscript(data.recordingId, data.transcript)
        socket.emit('recording:transcript_updated', { recordingId: data.recordingId, success })
      } catch (error) {
        socket.emit('recording:error', { error: error.message })
      }
    })

    // çŠ¶æ€æŸ¥è¯¢
    socket.on('status:get_sip', () => {
      const status = sipService.getStatus()
      socket.emit('status:sip', status)
    })

    socket.on('status:get_recordings', () => {
      const status = recordingService.getStatus()
      socket.emit('status:recordings', status)
    })

    socket.on('status:get_active_calls', () => {
      const calls = sipService.getActiveCalls()
      socket.emit('status:active_calls', calls)
    })
  }

  /**
   * å¤„ç†æ–­å¼€è¿æ¥
   */
  private handleDisconnect(socket: AuthenticatedSocket): void {
    const userId = socket.userId!
    const socketId = socket.id

    console.log(`ğŸ‘¤ ç”¨æˆ· ${userId} å·²æ–­å¼€å‘¼å«ä¸­å¿ƒè¿æ¥`)

    // æ¸…ç†è¿æ¥è®°å½•
    const userSockets = this.connectedUsers.get(userId)
    if (userSockets) {
      userSockets.delete(socketId)
      if (userSockets.size === 0) {
        this.connectedUsers.delete(userId)
      }
    }

    this.userSockets.delete(socketId)

    // é€šçŸ¥å…¶ä»–ç”¨æˆ·è¯¥ç”¨æˆ·å·²ç¦»çº¿
    socket.to(`role_${socket.userRole}`).emit('user:offline', { userId })
  }

  /**
   * å‘æŒ‡å®šè§’è‰²å¹¿æ’­æ¶ˆæ¯
   */
  private broadcastToRole(event: string, data: any, role: string): void {
    this.io?.to(`role_${role}`).emit(event, data)
  }

  /**
   * å‘æŒ‡å®šç”¨æˆ·å‘é€æ¶ˆæ¯
   */
  sendToUser(userId: number, event: string, data: any): void {
    this.io?.to(`user_${userId}`).emit(event, data)
  }

  /**
   * å‘æ‰€æœ‰è¿æ¥çš„ç”¨æˆ·å¹¿æ’­æ¶ˆæ¯
   */
  broadcast(event: string, data: any): void {
    this.io?.emit(event, data)
  }

  /**
   * è·å–åœ¨çº¿ç”¨æˆ·æ•°
   */
  getOnlineUserCount(): number {
    return this.connectedUsers.size
  }

  /**
   * è·å–æŒ‡å®šè§’è‰²çš„åœ¨çº¿ç”¨æˆ·
   */
  getOnlineUsersByRole(role: string): number[] {
    const users: number[] = []
    for (const [userId, sockets] of this.connectedUsers.entries()) {
      // è¿™é‡Œéœ€è¦é€šè¿‡å…¶ä»–æ–¹å¼è·å–ç”¨æˆ·è§’è‰²ï¼Œæš‚æ—¶è¿”å›æ‰€æœ‰ç”¨æˆ·
      users.push(userId)
    }
    return users
  }

  /**
   * è·å–è¿æ¥ç»Ÿè®¡
   */
  getStats(): any {
    return {
      totalConnections: this.userSockets.size,
      uniqueUsers: this.connectedUsers.size,
      connectionsByUser: Array.from(this.connectedUsers.entries()).map(([userId, sockets]) => ({
        userId,
        connectionCount: sockets.size
      }))
    }
  }

  /**
   * å…³é—­æœåŠ¡
   */
  close(): void {
    if (this.io) {
      this.io.close()
      this.io = null
      console.log('ğŸ”Œ å‘¼å«ä¸­å¿ƒWebSocketæœåŠ¡å·²å…³é—­')
    }
  }
}

export default new WebSocketService()