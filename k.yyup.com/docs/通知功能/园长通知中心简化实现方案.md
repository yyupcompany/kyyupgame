# å›­é•¿é€šçŸ¥ä¸­å¿ƒç®€åŒ–å®ç°æ–¹æ¡ˆ

**åˆ›å»ºæ—¥æœŸ**: 2025-01-09  
**è®¾è®¡äººå‘˜**: AI Assistant

---

## ğŸ“‹ åŸºäºç°æœ‰æ•°æ®åº“çš„å®ç°æ–¹æ¡ˆ

### æ ¸å¿ƒæ€è·¯

**ä¸åˆ›å»ºæ–°è¡¨**ï¼ŒåŸºäºç°æœ‰çš„notificationsè¡¨å®ç°ç»Ÿè®¡åŠŸèƒ½ï¼š

1. ä½¿ç”¨ `source_id` + `source_type` æ¥æ ‡è¯†åŒä¸€æ‰¹é€šçŸ¥
   - `source_type = 'notification_batch'`
   - `source_id = æ‰¹æ¬¡ID`ï¼ˆä½¿ç”¨æ—¶é—´æˆ³æˆ–UUIDï¼‰

2. ä½¿ç”¨ `sender_id` + `title` + `created_at` æ¥åˆ†ç»„ç»Ÿè®¡
   - ç›¸åŒå‘é€äººã€ç›¸åŒæ ‡é¢˜ã€ç›¸åŒæ—¶é—´çš„é€šçŸ¥è§†ä¸ºä¸€æ‰¹

3. èšåˆæŸ¥è¯¢è·å–ç»Ÿè®¡æ•°æ®
   - æŒ‰åˆ†ç»„ç»Ÿè®¡æ€»äººæ•°ã€å·²è¯»äººæ•°ã€æœªè¯»äººæ•°

---

## ğŸ”Œ APIå®ç°

### 1. è·å–é€šçŸ¥ç»Ÿè®¡åˆ—è¡¨

**SQLæŸ¥è¯¢é€»è¾‘**:

```sql
SELECT 
  MIN(id) as notification_id,
  title,
  content,
  type,
  sender_id,
  send_at,
  COUNT(*) as total_recipients,
  SUM(CASE WHEN status = 'read' THEN 1 ELSE 0 END) as read_recipients,
  SUM(CASE WHEN status != 'read' THEN 1 ELSE 0 END) as unread_recipients,
  ROUND(SUM(CASE WHEN status = 'read' THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as read_rate,
  MIN(created_at) as created_at
FROM notifications
WHERE sender_id IS NOT NULL
  AND deleted_at IS NULL
GROUP BY title, content, sender_id, DATE(send_at)
ORDER BY created_at DESC
LIMIT ? OFFSET ?
```

**Sequelizeå®ç°**:

```typescript
// server/src/services/notification-center.service.ts

export class NotificationCenterService {
  async getNotificationStatistics(params: {
    page: number;
    pageSize: number;
    type?: string;
    startDate?: string;
    endDate?: string;
    keyword?: string;
  }) {
    const { page, pageSize, type, startDate, endDate, keyword } = params;
    const offset = (page - 1) * pageSize;

    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const where: any = {
      sender_id: { [Op.ne]: null },
      deleted_at: null
    };

    if (type) {
      where.type = type;
    }

    if (startDate && endDate) {
      where.send_at = {
        [Op.between]: [startDate, endDate]
      };
    }

    if (keyword) {
      where[Op.or] = [
        { title: { [Op.like]: `%${keyword}%` } },
        { content: { [Op.like]: `%${keyword}%` } }
      ];
    }

    // æŸ¥è¯¢æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„é€šçŸ¥
    const notifications = await Notification.findAll({
      where,
      attributes: [
        'title',
        'content',
        'type',
        'sender_id',
        'send_at',
        [sequelize.fn('MIN', sequelize.col('id')), 'notification_id'],
        [sequelize.fn('COUNT', sequelize.col('id')), 'total_recipients'],
        [sequelize.fn('SUM', sequelize.literal("CASE WHEN status = 'read' THEN 1 ELSE 0 END")), 'read_recipients'],
        [sequelize.fn('SUM', sequelize.literal("CASE WHEN status != 'read' THEN 1 ELSE 0 END")), 'unread_recipients'],
        [sequelize.fn('MIN', sequelize.col('created_at')), 'created_at']
      ],
      group: ['title', 'content', 'sender_id', sequelize.fn('DATE', sequelize.col('send_at'))],
      include: [
        {
          model: User,
          as: 'sender',
          attributes: ['id', 'name']
        }
      ],
      order: [[sequelize.fn('MIN', sequelize.col('created_at')), 'DESC']],
      limit: pageSize,
      offset: offset,
      raw: false,
      subQuery: false
    });

    // è®¡ç®—é˜…è¯»ç‡
    const items = notifications.map((n: any) => {
      const total = parseInt(n.getDataValue('total_recipients'));
      const read = parseInt(n.getDataValue('read_recipients'));
      const unread = parseInt(n.getDataValue('unread_recipients'));
      const readRate = total > 0 ? Math.round((read / total) * 100 * 100) / 100 : 0;

      return {
        notificationId: n.getDataValue('notification_id'),
        title: n.title,
        content: n.content,
        type: n.type,
        senderName: n.sender?.name || 'ç³»ç»Ÿ',
        sendAt: n.send_at,
        totalRecipients: total,
        readRecipients: read,
        unreadRecipients: unread,
        readRate: readRate,
        createdAt: n.getDataValue('created_at')
      };
    });

    // è·å–æ€»æ•°ï¼ˆéœ€è¦å•ç‹¬æŸ¥è¯¢ï¼‰
    const totalQuery = await Notification.findAll({
      where,
      attributes: [
        [sequelize.fn('COUNT', sequelize.fn('DISTINCT', sequelize.literal("CONCAT(title, '-', sender_id, '-', DATE(send_at))"))), 'total']
      ],
      raw: true
    });

    const total = parseInt(totalQuery[0]?.total || '0');

    return {
      items,
      total,
      page,
      pageSize
    };
  }

  async getNotificationReaders(notificationId: number, params: {
    status?: 'read' | 'unread' | 'all';
    page: number;
    pageSize: number;
  }) {
    const { status, page, pageSize } = params;
    const offset = (page - 1) * pageSize;

    // å…ˆè·å–è¿™æ¡é€šçŸ¥çš„åŸºæœ¬ä¿¡æ¯
    const baseNotification = await Notification.findByPk(notificationId);
    if (!baseNotification) {
      throw new Error('é€šçŸ¥ä¸å­˜åœ¨');
    }

    // æŸ¥è¯¢åŒä¸€æ‰¹æ¬¡çš„æ‰€æœ‰é€šçŸ¥
    const where: any = {
      title: baseNotification.title,
      content: baseNotification.content,
      sender_id: baseNotification.sender_id,
      deleted_at: null
    };

    // æ·»åŠ çŠ¶æ€ç­›é€‰
    if (status && status !== 'all') {
      where.status = status === 'read' ? 'read' : { [Op.ne]: 'read' };
    }

    // æŸ¥è¯¢é€šçŸ¥åˆ—è¡¨
    const { rows, count } = await Notification.findAndCountAll({
      where,
      include: [
        {
          model: User,
          as: 'user',
          attributes: ['id', 'name', 'role']
        }
      ],
      order: [['read_at', 'DESC'], ['created_at', 'DESC']],
      limit: pageSize,
      offset: offset
    });

    // ç»Ÿè®¡ä¿¡æ¯
    const stats = await Notification.findAll({
      where: {
        title: baseNotification.title,
        content: baseNotification.content,
        sender_id: baseNotification.sender_id,
        deleted_at: null
      },
      attributes: [
        [sequelize.fn('COUNT', sequelize.col('id')), 'total'],
        [sequelize.fn('SUM', sequelize.literal("CASE WHEN status = 'read' THEN 1 ELSE 0 END")), 'read'],
        [sequelize.fn('SUM', sequelize.literal("CASE WHEN status != 'read' THEN 1 ELSE 0 END")), 'unread']
      ],
      raw: true
    });

    const totalRecipients = parseInt(stats[0]?.total || '0');
    const readRecipients = parseInt(stats[0]?.read || '0');
    const unreadRecipients = parseInt(stats[0]?.unread || '0');
    const readRate = totalRecipients > 0 ? Math.round((readRecipients / totalRecipients) * 100 * 100) / 100 : 0;

    return {
      notification: {
        title: baseNotification.title,
        content: baseNotification.content,
        type: baseNotification.type,
        sendAt: baseNotification.send_at,
        totalRecipients,
        readRecipients,
        unreadRecipients,
        readRate
      },
      readers: rows.map(n => ({
        userId: n.user_id,
        userName: n.user?.name || 'æœªçŸ¥ç”¨æˆ·',
        userRole: n.user?.role || 'æœªçŸ¥è§’è‰²',
        status: n.status === 'read' ? 'read' : 'unread',
        readAt: n.read_at
      })),
      total: count,
      page,
      pageSize
    };
  }
}
```

---

## ğŸ¨ å‰ç«¯å®ç°è¦ç‚¹

### ç»Ÿè®¡åˆ—è¡¨é¡µé¢

```vue
<template>
  <div class="notification-center">
    <!-- ç»Ÿè®¡å¡ç‰‡ -->
    <div class="stats-cards">
      <el-row :gutter="20">
        <el-col :span="6">
          <div class="stat-card">
            <div class="stat-value">{{ stats.totalNotifications }}</div>
            <div class="stat-label">æ€»é€šçŸ¥æ•°</div>
          </div>
        </el-col>
        <el-col :span="6">
          <div class="stat-card">
            <div class="stat-value">{{ stats.todayNotifications }}</div>
            <div class="stat-label">ä»Šæ—¥é€šçŸ¥</div>
          </div>
        </el-col>
        <el-col :span="6">
          <div class="stat-card">
            <div class="stat-value">{{ stats.averageReadRate }}%</div>
            <div class="stat-label">å¹³å‡é˜…è¯»ç‡</div>
          </div>
        </el-col>
        <el-col :span="6">
          <div class="stat-card">
            <div class="stat-value">{{ stats.urgentUnread }}</div>
            <div class="stat-label">ç´§æ€¥æœªè¯»</div>
          </div>
        </el-col>
      </el-row>
    </div>

    <!-- é€šçŸ¥åˆ—è¡¨ -->
    <el-table :data="notificationList" v-loading="loading">
      <el-table-column prop="title" label="é€šçŸ¥æ ‡é¢˜" width="200" />
      <el-table-column prop="type" label="ç±»å‹" width="100" />
      <el-table-column prop="senderName" label="å‘é€äºº" width="120" />
      <el-table-column prop="sendAt" label="å‘é€æ—¶é—´" width="180" />
      <el-table-column label="æ¥æ”¶æƒ…å†µ" width="300">
        <template #default="{ row }">
          <div class="recipients-info">
            <div class="recipients-text">
              æ€»æ•°: {{ row.totalRecipients }} | 
              å·²è¯»: {{ row.readRecipients }} | 
              æœªè¯»: {{ row.unreadRecipients }}
            </div>
            <el-progress 
              :percentage="row.readRate" 
              :color="getProgressColor(row.readRate)"
            />
          </div>
        </template>
      </el-table-column>
      <el-table-column label="æ“ä½œ" width="200">
        <template #default="{ row }">
          <el-button size="small" @click="viewDetails(row)">æŸ¥çœ‹è¯¦æƒ…</el-button>
          <el-button size="small" @click="exportReport(row)">å¯¼å‡º</el-button>
        </template>
      </el-table-column>
    </el-table>
  </div>
</template>
```

---

## ğŸ“Š ä¼˜åŠ¿å’Œé™åˆ¶

### ä¼˜åŠ¿
- âœ… ä¸éœ€è¦ä¿®æ”¹æ•°æ®åº“ç»“æ„
- âœ… åŸºäºç°æœ‰æ•°æ®å®ç°ç»Ÿè®¡åŠŸèƒ½
- âœ… å®ç°ç®€å•ï¼Œå¼€å‘å¿«é€Ÿ

### é™åˆ¶
- âš ï¸ èšåˆæŸ¥è¯¢æ€§èƒ½å¯èƒ½å—å½±å“ï¼ˆå¤§æ•°æ®é‡æ—¶ï¼‰
- âš ï¸ æ— æ³•ç²¾ç¡®æ ‡è¯†"åŒä¸€æ‰¹é€šçŸ¥"ï¼ˆä¾èµ–title+content+sender_idï¼‰
- âš ï¸ å¦‚æœæ ‡é¢˜æˆ–å†…å®¹ç›¸åŒä½†ä¸æ˜¯åŒä¸€æ‰¹ï¼Œä¼šè¢«é”™è¯¯åˆ†ç»„

### ä¼˜åŒ–å»ºè®®
- æ·»åŠ ç´¢å¼•: `CREATE INDEX idx_notification_group ON notifications(title(100), sender_id, send_at);`
- è€ƒè™‘æ·»åŠ  `batch_id` å­—æ®µæ¥ç²¾ç¡®æ ‡è¯†åŒä¸€æ‰¹é€šçŸ¥
- ä½¿ç”¨Redisç¼“å­˜ç»Ÿè®¡ç»“æœ

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-01-09

