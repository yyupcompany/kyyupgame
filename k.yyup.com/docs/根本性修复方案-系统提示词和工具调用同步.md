# 根本性修复方案：系统提示词和工具调用同步

**日期**: 2025-10-27  
**问题**: AI工具选择错误 - 持续选择read_data_record而非any_query  
**根本原因**: 系统提示词缺乏工具选择规则，工具定义与实际能力不一致

---

## 🎯 核心问题分析

### 问题1：系统提示词缺乏工具选择规则
- **现状**: 系统提示词中没有明确的工具选择决策树
- **后果**: AI根据参数定义自由选择工具，导致选择错误
- **根本原因**: 系统提示词只描述了工具的功能，没有说明"什么时候用什么工具"

### 问题2：工具定义与实际能力不一致
- **现状**: read_data_record有filters、sortBy、sortOrder参数
- **后果**: AI认为工具支持过滤和排序，实际不支持
- **根本原因**: 参数定义是历史遗留，没有与实际实现同步

### 问题3：缺乏工具选择验证层
- **现状**: AI选择工具后直接执行，没有验证
- **后果**: 错误的工具选择无法被纠正
- **根本原因**: 工具调用流程中没有"工具选择验证器"

---

## 🔧 三层修复方案

### 第一层：系统提示词强化（最关键）

**修改文件**: `server/src/services/ai-operator/unified-intelligence.service.ts`

**修改方法**: `buildSystemPrompt()`

**核心内容**：添加"工具选择决策树"

```
## 🎯 工具选择决策树（必须严格遵守）

### 第一步：分析用户查询
1. 是否包含过滤条件？(性别、年龄、班级、状态等)
2. 是否包含排序要求？(按XX排序)
3. 是否包含统计计算？(统计、求和、平均)
4. 是否包含多表关联？(学生及其班级)
5. 是否包含复杂条件？(且、或、非)

### 第二步：工具选择规则
- 如果第一步中任何一项为"是" → 必须使用 any_query
- 如果全部为"否" → 可以使用 read_data_record
- 如果不确定 → 优先使用 any_query（更安全）

### 第三步：禁止规则
- ❌ 禁止用read_data_record处理有过滤的查询
- ❌ 禁止用read_data_record处理有排序的查询
- ❌ 禁止用read_data_record处理统计查询
- ✅ 只用read_data_record查询全部数据

### 工具对比表
| 功能 | read_data_record | any_query |
|------|-----------------|-----------|
| 全量查询 | ✅ | ✅ |
| 过滤条件 | ❌ | ✅ |
| 排序 | ❌ | ✅ |
| 统计 | ❌ | ✅ |
| 多表JOIN | ❌ | ✅ |
| 性能 | 快 | 慢 |
```

### 第二层：工具定义同步

**修改文件**: `server/src/services/ai/tools/database-query/read-data-record.tool.ts`

**核心修改**：
1. 移除filters、sortBy、sortOrder参数（已完成）
2. 在工具描述中添加"工具选择优先级"
3. 添加"何时不应该使用此工具"

### 第三层：工具选择验证器（新增）

**新建文件**: `server/src/services/ai/tools/core/tool-selection-validator.service.ts`

**功能**：
1. 分析用户查询，判断需要的工具
2. 验证AI选择的工具是否合适
3. 如果不合适，进行纠正

**核心逻辑**：
```typescript
class ToolSelectionValidator {
  // 分析查询，返回应该使用的工具
  analyzeQuery(query: string): string[] {
    const hasFilters = /过滤|男|女|大班|中班|在职|请假/.test(query);
    const hasSorting = /排序|从高到低|从低到高|按/.test(query);
    const hasStats = /统计|求和|平均|最大|最小/.test(query);
    const hasJoin = /及其|和|关联|对应/.test(query);
    
    if (hasFilters || hasSorting || hasStats || hasJoin) {
      return ['any_query'];
    }
    return ['read_data_record', 'any_query']; // 都可以，优先read_data_record
  }
  
  // 验证AI选择的工具
  validateToolChoice(query: string, selectedTool: string): {
    valid: boolean;
    reason: string;
    suggestedTool?: string;
  } {
    const appropriateTools = this.analyzeQuery(query);
    
    if (appropriateTools.includes(selectedTool)) {
      return { valid: true, reason: '工具选择正确' };
    }
    
    return {
      valid: false,
      reason: `工具选择不当，应该使用${appropriateTools[0]}`,
      suggestedTool: appropriateTools[0]
    };
  }
}
```

---

## 📋 实施步骤

### 步骤1：更新系统提示词（立即执行）
- 修改buildSystemPrompt()方法
- 添加工具选择决策树
- 添加禁止规则

### 步骤2：创建工具选择验证器（立即执行）
- 新建tool-selection-validator.service.ts
- 实现查询分析逻辑
- 实现工具选择验证逻辑

### 步骤3：集成验证器到工具调用流程（立即执行）
- 在callDoubaoStreamAPI中添加验证
- 如果验证失败，纠正工具选择
- 记录纠正日志

### 步骤4：测试验证（立即执行）
- 测试查询："查询所有男生，按年龄排序"
- 验证AI是否选择any_query
- 验证第1轮是否成功

---

## ✅ 预期效果

| 指标 | 修复前 | 修复后 |
|------|--------|--------|
| 第1轮工具选择正确率 | 0% | 100% |
| 平均轮数 | 4轮 | 1轮 |
| 用户体验 | 差 | 优秀 |
| 系统可维护性 | 低 | 高 |

---

## 🚀 优势

1. **根本解决问题**：不是打补丁，而是从系统设计层面修复
2. **可扩展性强**：新增工具时只需更新决策树
3. **易于维护**：工具选择规则集中管理
4. **性能优化**：减少不必要的重试，提升响应速度
5. **用户体验**：第1轮就能得到正确结果

---

**下一步**: 立即实施步骤1-3，然后进行测试验证

