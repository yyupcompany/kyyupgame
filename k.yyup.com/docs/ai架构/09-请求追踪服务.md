# è¯·æ±‚è¿½è¸ªæœåŠ¡ (RequestTracerService)

**æœåŠ¡åç§°**: RequestTracerService  
**ä»£ç ä½ç½®**: `server/src/services/ai-operator/monitoring/request-tracer.service.ts`  
**ä»£ç é‡**: ~340è¡Œ  
**çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

## ğŸ“‹ ç›®å½•

- [æœåŠ¡æ¦‚è¿°](#æœåŠ¡æ¦‚è¿°)
- [æ ¸å¿ƒåŠŸèƒ½](#æ ¸å¿ƒåŠŸèƒ½)
- [APIæ–‡æ¡£](#apiæ–‡æ¡£)
- [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)
- [æµ‹è¯•ç”¨ä¾‹](#æµ‹è¯•ç”¨ä¾‹)
- [æ€§èƒ½æŒ‡æ ‡](#æ€§èƒ½æŒ‡æ ‡)

---

## ğŸ¯ æœåŠ¡æ¦‚è¿°

### èŒè´£

RequestTracerServiceè´Ÿè´£åˆ†å¸ƒå¼è¯·æ±‚è¿½è¸ªï¼Œæä¾›å®Œæ•´çš„è¯·æ±‚é“¾è·¯è·Ÿè¸ªã€Spançº§åˆ«ç›‘æ§ã€æ€§èƒ½åˆ†æç­‰åŠŸèƒ½ã€‚

### æ ¸å¿ƒç‰¹æ€§

1. **åˆ†å¸ƒå¼è¿½è¸ª** - è·¨æœåŠ¡è¯·æ±‚é“¾è·¯è¿½è¸ª
2. **Spanç®¡ç†** - ç»†ç²’åº¦æ“ä½œè·Ÿè¸ª
3. **ä¸Šä¸‹æ–‡ä¼ æ’­** - è¿½è¸ªä¸Šä¸‹æ–‡è‡ªåŠ¨ä¼ æ’­
4. **æ€§èƒ½åˆ†æ** - è¯·æ±‚æ€§èƒ½æ·±åº¦åˆ†æ
5. **å¯è§†åŒ–å±•ç¤º** - è¿½è¸ªé“¾è·¯å¯è§†åŒ–

### è®¾è®¡æ¨¡å¼

- **å•ä¾‹æ¨¡å¼** - å…¨å±€å”¯ä¸€è¿½è¸ªæœåŠ¡
- **è§‚å¯Ÿè€…æ¨¡å¼** - è¿½è¸ªäº‹ä»¶ç›‘å¬
- **è£…é¥°å™¨æ¨¡å¼** - è‡ªåŠ¨è¿½è¸ªè£…é¥°
- **è´£ä»»é“¾æ¨¡å¼** - è¿½è¸ªé“¾è·¯ä¼ é€’

---

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½

### 1. è¯·æ±‚è¿½è¸ª

**åŠŸèƒ½**: è¿½è¸ªå®Œæ•´çš„è¯·æ±‚å¤„ç†é“¾è·¯

**è¿½è¸ªè¦ç´ **:
- **Trace ID**: å…¨å±€å”¯ä¸€è¯·æ±‚æ ‡è¯†
- **Span ID**: æ“ä½œæ­¥éª¤æ ‡è¯†
- **Parent Span**: çˆ¶çº§æ“ä½œå…³ç³»
- **æ—¶é—´æˆ³**: æ“ä½œå¼€å§‹å’Œç»“æŸæ—¶é—´
- **æ ‡ç­¾**: æ“ä½œç›¸å…³å…ƒæ•°æ®

### 2. Spanç®¡ç†

**åŠŸèƒ½**: ç®¡ç†è¯·æ±‚å¤„ç†è¿‡ç¨‹ä¸­çš„å„ä¸ªæ“ä½œæ­¥éª¤

**Spanç±»å‹**:
- **Root Span**: æ ¹çº§è¯·æ±‚Span
- **Child Span**: å­æ“ä½œSpan
- **Service Span**: æœåŠ¡è°ƒç”¨Span
- **Database Span**: æ•°æ®åº“æ“ä½œSpan
- **External Span**: å¤–éƒ¨æœåŠ¡è°ƒç”¨Span

### 3. ä¸Šä¸‹æ–‡ä¼ æ’­

**åŠŸèƒ½**: åœ¨ä¸åŒæœåŠ¡å’Œç»„ä»¶é—´ä¼ æ’­è¿½è¸ªä¸Šä¸‹æ–‡

**ä¼ æ’­æœºåˆ¶**:
- HTTPå¤´ä¼ æ’­
- çº¿ç¨‹æœ¬åœ°å­˜å‚¨
- å¼‚æ­¥ä¸Šä¸‹æ–‡ä¼ æ’­
- è·¨è¿›ç¨‹ä¼ æ’­

### 4. æ€§èƒ½åˆ†æ

**åŠŸèƒ½**: åŸºäºè¿½è¸ªæ•°æ®è¿›è¡Œæ€§èƒ½åˆ†æ

**åˆ†æç»´åº¦**:
- è¯·æ±‚æ€»è€—æ—¶åˆ†æ
- å„é˜¶æ®µè€—æ—¶åˆ†å¸ƒ
- ç“¶é¢ˆæ“ä½œè¯†åˆ«
- å¼‚å¸¸è¯·æ±‚åˆ†æ

---

## ğŸ“– APIæ–‡æ¡£

### startTrace

å¼€å§‹æ–°çš„è¿½è¸ª

**ç­¾å**:
```typescript
startTrace(
  operationName: string,
  parentTraceId?: string
): string
```

**å‚æ•°**:
- `operationName` - æ“ä½œåç§°
- `parentTraceId` - çˆ¶çº§è¿½è¸ªIDï¼ˆå¯é€‰ï¼‰

**è¿”å›å€¼**: è¿½è¸ªID

**ç¤ºä¾‹**:
```typescript
const traceId = requestTracer.startTrace('user_request', parentTraceId);
```

### startSpan

å¼€å§‹æ–°çš„Span

**ç­¾å**:
```typescript
startSpan(
  traceId: string,
  spanName: string,
  parentSpanId?: string
): string
```

**è¿”å›å€¼**: Span ID

**ç¤ºä¾‹**:
```typescript
const spanId = requestTracer.startSpan(traceId, 'database_query', parentSpanId);
```

### endSpan

ç»“æŸSpan

**ç­¾å**:
```typescript
endSpan(
  traceId: string,
  spanId: string,
  result?: SpanResult
): void
```

**å‚æ•°**:
```typescript
interface SpanResult {
  status: 'success' | 'error';
  error?: Error;
  metadata?: Record<string, any>;
}
```

### addSpanTag

æ·»åŠ Spanæ ‡ç­¾

**ç­¾å**:
```typescript
addSpanTag(
  traceId: string,
  spanId: string,
  key: string,
  value: any
): void
```

### endTrace

ç»“æŸè¿½è¸ª

**ç­¾å**:
```typescript
endTrace(
  traceId: string,
  result?: TraceResult
): TraceAnalysis
```

**è¿”å›å€¼**:
```typescript
interface TraceAnalysis {
  traceId: string;
  totalDuration: number;
  spanCount: number;
  errorCount: number;
  bottlenecks: BottleneckInfo[];
  timeline: SpanTimeline[];
}
```

### getTrace

è·å–è¿½è¸ªä¿¡æ¯

**ç­¾å**:
```typescript
getTrace(traceId: string): TraceInfo | null
```

**è¿”å›å€¼**:
```typescript
interface TraceInfo {
  traceId: string;
  operationName: string;
  startTime: number;
  endTime?: number;
  duration?: number;
  spans: SpanInfo[];
  status: 'active' | 'completed' | 'error';
}

interface SpanInfo {
  spanId: string;
  spanName: string;
  parentSpanId?: string;
  startTime: number;
  endTime?: number;
  duration?: number;
  tags: Record<string, any>;
  status: 'active' | 'completed' | 'error';
}
```

### analyzeTrace

åˆ†æè¿½è¸ªæ€§èƒ½

**ç­¾å**:
```typescript
analyzeTrace(traceId: string): TraceAnalysis
```

---

## ğŸ’¡ ä½¿ç”¨ç¤ºä¾‹

### ç¤ºä¾‹1: åŸºç¡€è¯·æ±‚è¿½è¸ª

```typescript
import { requestTracer } from './monitoring/request-tracer.service';

async function handleUserRequest(req: Request, res: Response) {
  // å¼€å§‹è¯·æ±‚è¿½è¸ª
  const traceId = requestTracer.startTrace('user_request');
  
  try {
    // æ·»åŠ è¯·æ±‚ä¿¡æ¯
    requestTracer.addSpanTag(traceId, traceId, 'user_id', req.user?.id);
    requestTracer.addSpanTag(traceId, traceId, 'endpoint', req.path);
    requestTracer.addSpanTag(traceId, traceId, 'method', req.method);
    
    // å¤„ç†è¯·æ±‚
    const result = await processRequest(req, traceId);
    
    // ç»“æŸè¿½è¸ª
    const analysis = requestTracer.endTrace(traceId, {
      status: 'success',
      metadata: { resultSize: JSON.stringify(result).length }
    });
    
    console.log(`è¯·æ±‚å¤„ç†å®Œæˆï¼Œæ€»è€—æ—¶: ${analysis.totalDuration}ms`);
    
    res.json(result);
    
  } catch (error) {
    // é”™è¯¯è¿½è¸ª
    requestTracer.endTrace(traceId, {
      status: 'error',
      error: error as Error
    });
    
    res.status(500).json({ error: error.message });
  }
}
```

### ç¤ºä¾‹2: æ•°æ®åº“æ“ä½œè¿½è¸ª

```typescript
async function queryStudentsWithTracing(traceId: string, filters: any) {
  // å¼€å§‹æ•°æ®åº“æŸ¥è¯¢Span
  const spanId = requestTracer.startSpan(traceId, 'database_query');
  
  try {
    // æ·»åŠ æŸ¥è¯¢ä¿¡æ¯
    requestTracer.addSpanTag(traceId, spanId, 'table', 'students');
    requestTracer.addSpanTag(traceId, spanId, 'operation', 'select');
    requestTracer.addSpanTag(traceId, spanId, 'filters', JSON.stringify(filters));
    
    // æ‰§è¡ŒæŸ¥è¯¢
    const students = await Student.findAll({
      where: filters,
      include: [Class, Grade]
    });
    
    // æ·»åŠ ç»“æœä¿¡æ¯
    requestTracer.addSpanTag(traceId, spanId, 'result_count', students.length);
    
    // ç»“æŸSpan
    requestTracer.endSpan(traceId, spanId, {
      status: 'success',
      metadata: { recordCount: students.length }
    });
    
    return students;
    
  } catch (error) {
    // é”™è¯¯å¤„ç†
    requestTracer.addSpanTag(traceId, spanId, 'error', error.message);
    requestTracer.endSpan(traceId, spanId, {
      status: 'error',
      error: error as Error
    });
    
    throw error;
  }
}
```

### ç¤ºä¾‹3: æœåŠ¡è°ƒç”¨è¿½è¸ª

```typescript
async function callExternalServiceWithTracing(traceId: string, serviceUrl: string, data: any) {
  // å¼€å§‹å¤–éƒ¨æœåŠ¡è°ƒç”¨Span
  const spanId = requestTracer.startSpan(traceId, 'external_service_call');
  
  try {
    // æ·»åŠ æœåŠ¡ä¿¡æ¯
    requestTracer.addSpanTag(traceId, spanId, 'service_url', serviceUrl);
    requestTracer.addSpanTag(traceId, spanId, 'request_size', JSON.stringify(data).length);
    
    // å‡†å¤‡è¯·æ±‚å¤´ï¼ˆä¼ æ’­è¿½è¸ªä¸Šä¸‹æ–‡ï¼‰
    const headers = {
      'Content-Type': 'application/json',
      'X-Trace-Id': traceId,
      'X-Span-Id': spanId
    };
    
    // å‘èµ·è¯·æ±‚
    const response = await fetch(serviceUrl, {
      method: 'POST',
      headers,
      body: JSON.stringify(data)
    });
    
    // æ·»åŠ å“åº”ä¿¡æ¯
    requestTracer.addSpanTag(traceId, spanId, 'response_status', response.status);
    requestTracer.addSpanTag(traceId, spanId, 'response_size', response.headers.get('content-length') || '0');
    
    const result = await response.json();
    
    // ç»“æŸSpan
    requestTracer.endSpan(traceId, spanId, {
      status: response.ok ? 'success' : 'error',
      metadata: { 
        statusCode: response.status,
        responseTime: Date.now() - spanStartTime
      }
    });
    
    return result;
    
  } catch (error) {
    requestTracer.endSpan(traceId, spanId, {
      status: 'error',
      error: error as Error
    });
    
    throw error;
  }
}
```

### ç¤ºä¾‹4: å¤æ‚ä¸šåŠ¡æµç¨‹è¿½è¸ª

```typescript
async function processStudentEnrollmentWithTracing(enrollmentData: any) {
  // å¼€å§‹ä¸»æµç¨‹è¿½è¸ª
  const traceId = requestTracer.startTrace('student_enrollment');
  
  try {
    // 1. éªŒè¯å­¦ç”Ÿä¿¡æ¯
    const validationSpan = requestTracer.startSpan(traceId, 'validate_student');
    const isValid = await validateStudentInfo(enrollmentData.student, traceId);
    requestTracer.endSpan(traceId, validationSpan, {
      status: isValid ? 'success' : 'error',
      metadata: { isValid }
    });
    
    if (!isValid) {
      throw new Error('å­¦ç”Ÿä¿¡æ¯éªŒè¯å¤±è´¥');
    }
    
    // 2. æ£€æŸ¥ç­çº§å®¹é‡
    const capacitySpan = requestTracer.startSpan(traceId, 'check_class_capacity');
    const hasCapacity = await checkClassCapacity(enrollmentData.classId, traceId);
    requestTracer.endSpan(traceId, capacitySpan, {
      status: 'success',
      metadata: { hasCapacity }
    });
    
    if (!hasCapacity) {
      throw new Error('ç­çº§å·²æ»¡');
    }
    
    // 3. åˆ›å»ºå­¦ç”Ÿè®°å½•
    const createSpan = requestTracer.startSpan(traceId, 'create_student_record');
    const student = await createStudentRecord(enrollmentData.student, traceId);
    requestTracer.endSpan(traceId, createSpan, {
      status: 'success',
      metadata: { studentId: student.id }
    });
    
    // 4. åˆ†é…ç­çº§
    const assignSpan = requestTracer.startSpan(traceId, 'assign_to_class');
    await assignStudentToClass(student.id, enrollmentData.classId, traceId);
    requestTracer.endSpan(traceId, assignSpan, {
      status: 'success'
    });
    
    // 5. å‘é€é€šçŸ¥
    const notifySpan = requestTracer.startSpan(traceId, 'send_notification');
    await sendEnrollmentNotification(student, traceId);
    requestTracer.endSpan(traceId, notifySpan, {
      status: 'success'
    });
    
    // ç»“æŸä¸»æµç¨‹
    const analysis = requestTracer.endTrace(traceId, {
      status: 'success',
      metadata: { studentId: student.id, classId: enrollmentData.classId }
    });
    
    console.log('å­¦ç”Ÿå…¥å­¦æµç¨‹å®Œæˆ:');
    console.log(`- æ€»è€—æ—¶: ${analysis.totalDuration}ms`);
    console.log(`- æ­¥éª¤æ•°: ${analysis.spanCount}`);
    console.log(`- é”™è¯¯æ•°: ${analysis.errorCount}`);
    
    if (analysis.bottlenecks.length > 0) {
      console.log('- æ€§èƒ½ç“¶é¢ˆ:');
      analysis.bottlenecks.forEach(bottleneck => {
        console.log(`  ${bottleneck.spanName}: ${bottleneck.duration}ms`);
      });
    }
    
    return student;
    
  } catch (error) {
    requestTracer.endTrace(traceId, {
      status: 'error',
      error: error as Error
    });
    
    throw error;
  }
}
```

### ç¤ºä¾‹5: è¿½è¸ªæ•°æ®åˆ†æ

```typescript
function analyzeRequestTraces() {
  console.log('ğŸ“Š è¯·æ±‚è¿½è¸ªåˆ†ææŠ¥å‘Š');
  console.log('='.repeat(50));
  
  // è·å–æœ€è¿‘çš„è¿½è¸ªæ•°æ®
  const recentTraces = requestTracer.getRecentTraces(100);
  
  // ç»Ÿè®¡åˆ†æ
  const stats = {
    totalRequests: recentTraces.length,
    successfulRequests: recentTraces.filter(t => t.status === 'completed').length,
    errorRequests: recentTraces.filter(t => t.status === 'error').length,
    averageDuration: 0,
    slowestRequests: [] as any[],
    commonBottlenecks: new Map<string, number>()
  };
  
  // è®¡ç®—å¹³å‡è€—æ—¶
  const completedTraces = recentTraces.filter(t => t.duration);
  stats.averageDuration = completedTraces.reduce((sum, t) => sum + t.duration!, 0) / completedTraces.length;
  
  // æ‰¾å‡ºæœ€æ…¢çš„è¯·æ±‚
  stats.slowestRequests = completedTraces
    .sort((a, b) => b.duration! - a.duration!)
    .slice(0, 5)
    .map(t => ({
      traceId: t.traceId,
      operationName: t.operationName,
      duration: t.duration
    }));
  
  // åˆ†æå¸¸è§ç“¶é¢ˆ
  recentTraces.forEach(trace => {
    const analysis = requestTracer.analyzeTrace(trace.traceId);
    analysis.bottlenecks.forEach(bottleneck => {
      const count = stats.commonBottlenecks.get(bottleneck.spanName) || 0;
      stats.commonBottlenecks.set(bottleneck.spanName, count + 1);
    });
  });
  
  // è¾“å‡ºæŠ¥å‘Š
  console.log(`æ€»è¯·æ±‚æ•°: ${stats.totalRequests}`);
  console.log(`æˆåŠŸè¯·æ±‚: ${stats.successfulRequests} (${(stats.successfulRequests / stats.totalRequests * 100).toFixed(1)}%)`);
  console.log(`å¤±è´¥è¯·æ±‚: ${stats.errorRequests} (${(stats.errorRequests / stats.totalRequests * 100).toFixed(1)}%)`);
  console.log(`å¹³å‡è€—æ—¶: ${stats.averageDuration.toFixed(2)}ms`);
  
  console.log('\nğŸŒ æœ€æ…¢çš„è¯·æ±‚:');
  stats.slowestRequests.forEach((req, index) => {
    console.log(`${index + 1}. ${req.operationName} (${req.traceId}): ${req.duration}ms`);
  });
  
  console.log('\nğŸ” å¸¸è§ç“¶é¢ˆ:');
  const sortedBottlenecks = Array.from(stats.commonBottlenecks.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 5);
  
  sortedBottlenecks.forEach(([spanName, count]) => {
    console.log(`- ${spanName}: å‡ºç° ${count} æ¬¡`);
  });
  
  return stats;
}
```

---

## ğŸ§ª æµ‹è¯•ç”¨ä¾‹

### å•å…ƒæµ‹è¯•

```typescript
describe('RequestTracerService', () => {
  let tracer: RequestTracerService;

  beforeEach(() => {
    tracer = RequestTracerService.getInstance();
    tracer.clearAllTraces(); // æ¸…ç†å†å²æ•°æ®
  });

  describe('è¿½è¸ªç®¡ç†', () => {
    it('åº”è¯¥å¼€å§‹æ–°çš„è¿½è¸ª', () => {
      const traceId = tracer.startTrace('test_operation');
      
      expect(traceId).toBeDefined();
      expect(typeof traceId).toBe('string');
      
      const trace = tracer.getTrace(traceId);
      expect(trace).toBeDefined();
      expect(trace!.operationName).toBe('test_operation');
      expect(trace!.status).toBe('active');
    });

    it('åº”è¯¥ç»“æŸè¿½è¸ª', () => {
      const traceId = tracer.startTrace('test_operation');
      
      const analysis = tracer.endTrace(traceId, { status: 'success' });
      
      expect(analysis.traceId).toBe(traceId);
      expect(analysis.totalDuration).toBeGreaterThan(0);
      
      const trace = tracer.getTrace(traceId);
      expect(trace!.status).toBe('completed');
    });
  });

  describe('Spanç®¡ç†', () => {
    it('åº”è¯¥åˆ›å»ºå’Œç®¡ç†Span', () => {
      const traceId = tracer.startTrace('test_operation');
      const spanId = tracer.startSpan(traceId, 'test_span');
      
      expect(spanId).toBeDefined();
      
      tracer.addSpanTag(traceId, spanId, 'test_tag', 'test_value');
      tracer.endSpan(traceId, spanId, { status: 'success' });
      
      const trace = tracer.getTrace(traceId);
      const span = trace!.spans.find(s => s.spanId === spanId);
      
      expect(span).toBeDefined();
      expect(span!.spanName).toBe('test_span');
      expect(span!.tags.test_tag).toBe('test_value');
      expect(span!.status).toBe('completed');
    });

    it('åº”è¯¥æ”¯æŒåµŒå¥—Span', () => {
      const traceId = tracer.startTrace('test_operation');
      const parentSpanId = tracer.startSpan(traceId, 'parent_span');
      const childSpanId = tracer.startSpan(traceId, 'child_span', parentSpanId);
      
      tracer.endSpan(traceId, childSpanId, { status: 'success' });
      tracer.endSpan(traceId, parentSpanId, { status: 'success' });
      
      const trace = tracer.getTrace(traceId);
      const childSpan = trace!.spans.find(s => s.spanId === childSpanId);
      
      expect(childSpan!.parentSpanId).toBe(parentSpanId);
    });
  });

  describe('æ€§èƒ½åˆ†æ', () => {
    it('åº”è¯¥åˆ†æè¿½è¸ªæ€§èƒ½', async () => {
      const traceId = tracer.startTrace('test_operation');
      
      // åˆ›å»ºä¸€äº›Span
      const span1 = tracer.startSpan(traceId, 'fast_operation');
      await new Promise(resolve => setTimeout(resolve, 10));
      tracer.endSpan(traceId, span1, { status: 'success' });
      
      const span2 = tracer.startSpan(traceId, 'slow_operation');
      await new Promise(resolve => setTimeout(resolve, 100));
      tracer.endSpan(traceId, span2, { status: 'success' });
      
      const analysis = tracer.analyzeTrace(traceId);
      
      expect(analysis.spanCount).toBe(2);
      expect(analysis.bottlenecks.length).toBeGreaterThan(0);
      expect(analysis.bottlenecks[0].spanName).toBe('slow_operation');
    });
  });

  describe('é”™è¯¯å¤„ç†', () => {
    it('åº”è¯¥å¤„ç†Spané”™è¯¯', () => {
      const traceId = tracer.startTrace('test_operation');
      const spanId = tracer.startSpan(traceId, 'error_span');
      
      const error = new Error('æµ‹è¯•é”™è¯¯');
      tracer.endSpan(traceId, spanId, {
        status: 'error',
        error
      });
      
      const trace = tracer.getTrace(traceId);
      const span = trace!.spans.find(s => s.spanId === spanId);
      
      expect(span!.status).toBe('error');
      expect(span!.tags.error).toBe('æµ‹è¯•é”™è¯¯');
    });
  });
});
```

---

## ğŸ“Š æ€§èƒ½æŒ‡æ ‡

### ç›®æ ‡æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡ | å®é™… | çŠ¶æ€ |
|------|------|------|------|
| è¿½è¸ªå¼€é”€ | <1% | ~0.5% | âœ… |
| å†…å­˜ä½¿ç”¨ | <100MB | ~80MB | âœ… |
| å¹¶å‘è¿½è¸ªæ•° | >1000 | ~1500 | âœ… |
| åˆ†ææ—¶é—´ | <100ms | ~80ms | âœ… |

### æ€§èƒ½ä¼˜åŒ–

1. **å¼‚æ­¥å¤„ç†** - å¼‚æ­¥å†™å…¥è¿½è¸ªæ•°æ®
2. **æ‰¹é‡æ“ä½œ** - æ‰¹é‡å¤„ç†è¿½è¸ªäº‹ä»¶
3. **å†…å­˜ç®¡ç†** - å®šæœŸæ¸…ç†è¿‡æœŸè¿½è¸ª
4. **ç´¢å¼•ä¼˜åŒ–** - ä¼˜åŒ–è¿½è¸ªæ•°æ®æŸ¥è¯¢

---

**æ–‡æ¡£ç»´æŠ¤**: AIåŠ©æ‰‹å¼€å‘å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2025-10-08
