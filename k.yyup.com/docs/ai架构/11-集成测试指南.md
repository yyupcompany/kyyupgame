# AIåŠ©æ‰‹ç³»ç»Ÿé›†æˆæµ‹è¯•æŒ‡å—

**ç‰ˆæœ¬**: 2.0.0  
**æœ€åæ›´æ–°**: 2025-10-05  
**æµ‹è¯•æ¡†æ¶**: Jest + Vitest

---

## ğŸ“‹ ç›®å½•

- [æµ‹è¯•æ¦‚è¿°](#æµ‹è¯•æ¦‚è¿°)
- [æµ‹è¯•ç¯å¢ƒ](#æµ‹è¯•ç¯å¢ƒ)
- [æ ¸å¿ƒæœåŠ¡æµ‹è¯•](#æ ¸å¿ƒæœåŠ¡æµ‹è¯•)
- [é›†æˆæµ‹è¯•](#é›†æˆæµ‹è¯•)
- [æ€§èƒ½æµ‹è¯•](#æ€§èƒ½æµ‹è¯•)
- [æµ‹è¯•è¦†ç›–ç‡](#æµ‹è¯•è¦†ç›–ç‡)

---

## ğŸ¯ æµ‹è¯•æ¦‚è¿°

### æµ‹è¯•ç­–ç•¥

```
æµ‹è¯•é‡‘å­—å¡”
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  E2E    â”‚  10%  - ç«¯åˆ°ç«¯æµ‹è¯•
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ é›†æˆæµ‹è¯• â”‚  30%  - æœåŠ¡é›†æˆæµ‹è¯•
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ å•å…ƒæµ‹è¯• â”‚  60%  - å•å…ƒæµ‹è¯•
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æµ‹è¯•ç±»å‹

1. **å•å…ƒæµ‹è¯•** - æµ‹è¯•å•ä¸ªå‡½æ•°/æ–¹æ³•
2. **é›†æˆæµ‹è¯•** - æµ‹è¯•æœåŠ¡é—´äº¤äº’
3. **æ€§èƒ½æµ‹è¯•** - æµ‹è¯•æ€§èƒ½æŒ‡æ ‡
4. **E2Eæµ‹è¯•** - æµ‹è¯•å®Œæ•´æµç¨‹

---

## ğŸ”§ æµ‹è¯•ç¯å¢ƒ

### ç¯å¢ƒé…ç½®

```bash
# æµ‹è¯•ç¯å¢ƒå˜é‡
NODE_ENV=test
DB_NAME=kindergarten_test
REDIS_DB=1

# AIæ¨¡å‹é…ç½®ï¼ˆä½¿ç”¨Mockï¼‰
AI_MODEL=mock
DOUBAO_API_KEY=test_key
```

### æµ‹è¯•æ•°æ®åº“

```bash
# åˆ›å»ºæµ‹è¯•æ•°æ®åº“
npm run db:create:test

# è¿è¡Œæµ‹è¯•è¿ç§»
npm run db:migrate:test

# åŠ è½½æµ‹è¯•æ•°æ®
npm run db:seed:test
```

---

## ğŸ§ª æ ¸å¿ƒæœåŠ¡æµ‹è¯•

### 1. MemoryIntegrationService æµ‹è¯•

**æµ‹è¯•æ–‡ä»¶**: `server/src/services/ai-operator/__tests__/memory-integration.test.ts`

```typescript
describe('MemoryIntegrationService', () => {
  let service: MemoryIntegrationService;

  beforeEach(() => {
    service = MemoryIntegrationService.getInstance();
  });

  afterEach(() => {
    // æ¸…ç†ç¼“å­˜
    service.clearCache();
  });

  describe('è®°å¿†æ£€ç´¢', () => {
    it('åº”è¯¥æˆåŠŸæ£€ç´¢è®°å¿†', async () => {
      const context = await service.retrieveMemoryContext(
        'å­¦ç”Ÿæˆç»©',
        'user123'
      );

      expect(context).toBeDefined();
      expect(context.items).toBeInstanceOf(Array);
      expect(context.totalCount).toBeGreaterThanOrEqual(0);
    });

    it('åº”è¯¥æ”¯æŒç»´åº¦è¿‡æ»¤', async () => {
      const context = await service.retrieveMemoryContext(
        'å­¦ç”Ÿæˆç»©',
        'user123',
        { dimensions: ['episodic', 'semantic'] }
      );

      expect(context.dimensions).toContain('episodic');
      expect(context.dimensions).toContain('semantic');
    });

    it('åº”è¯¥æ”¯æŒç›¸å…³åº¦è¿‡æ»¤', async () => {
      const context = await service.retrieveMemoryContext(
        'å­¦ç”Ÿæˆç»©',
        'user123',
        { minRelevance: 0.7 }
      );

      context.items.forEach(item => {
        expect(item.relevance).toBeGreaterThanOrEqual(0.7);
      });
    });

    it('åº”è¯¥ä½¿ç”¨ç¼“å­˜æå‡æ€§èƒ½', async () => {
      const start1 = Date.now();
      await service.retrieveMemoryContext('å­¦ç”Ÿæˆç»©', 'user123');
      const duration1 = Date.now() - start1;

      const start2 = Date.now();
      await service.retrieveMemoryContext('å­¦ç”Ÿæˆç»©', 'user123');
      const duration2 = Date.now() - start2;

      expect(duration2).toBeLessThan(duration1);
    });
  });

  describe('è®°å¿†å­˜å‚¨', () => {
    it('åº”è¯¥æˆåŠŸå­˜å‚¨è®°å¿†', async () => {
      const memory = await service.storeMemory(
        'å¼ ä¸‰æ•°å­¦è€ƒè¯•95åˆ†',
        'user123',
        'episodic',
        { subject: 'math', score: 95 }
      );

      expect(memory.id).toBeDefined();
      expect(memory.content).toBe('å¼ ä¸‰æ•°å­¦è€ƒè¯•95åˆ†');
      expect(memory.dimension).toBe('episodic');
    });

    it('åº”è¯¥æ”¯æŒæ‰¹é‡å­˜å‚¨', async () => {
      const memories = await service.batchStoreMemories([
        { content: 'è®°å¿†1', dimension: 'episodic' },
        { content: 'è®°å¿†2', dimension: 'semantic' }
      ], 'user123');

      expect(memories).toHaveLength(2);
    });
  });

  describe('è®°å¿†æ ¼å¼åŒ–', () => {
    it('åº”è¯¥æ­£ç¡®æ ¼å¼åŒ–è®°å¿†', () => {
      const context = {
        items: [
          {
            id: '1',
            content: 'æµ‹è¯•è®°å¿†',
            dimension: 'episodic',
            relevance: 0.9,
            timestamp: new Date()
          }
        ],
        dimensions: ['episodic'],
        totalCount: 1,
        relevanceScore: 0.9
      };

      const formatted = service.formatMemoryContext(context);

      expect(formatted).toContain('ğŸ“š ç›¸å…³è®°å¿†');
      expect(formatted).toContain('æµ‹è¯•è®°å¿†');
    });
  });
});
```

### 2. UnifiedIntelligenceCoordinator æµ‹è¯•

```typescript
describe('UnifiedIntelligenceCoordinator', () => {
  let service: UnifiedIntelligenceCoordinator;

  beforeEach(() => {
    service = UnifiedIntelligenceCoordinator.getInstance();
  });

  describe('AIè°ƒç”¨', () => {
    it('åº”è¯¥æˆåŠŸè°ƒç”¨AIæ¨¡å‹', async () => {
      const response = await service.callAI({
        messages: [
          { role: 'user', content: 'ä½ å¥½' }
        ]
      });

      expect(response).toBeDefined();
      expect(response.content).toBeDefined();
    });

    it('åº”è¯¥æ”¯æŒè¶…æ—¶æ§åˆ¶', async () => {
      const start = Date.now();

      try {
        await service.callAI({
          messages: [{ role: 'user', content: 'æµ‹è¯•' }],
          timeout: 100
        });
      } catch (error) {
        const duration = Date.now() - start;
        expect(duration).toBeLessThan(200);
      }
    });

    it('åº”è¯¥æ”¯æŒé™çº§ç­–ç•¥', async () => {
      // æ¨¡æ‹Ÿä¸»æ¨¡å‹å¤±è´¥
      const response = await service.callAI({
        messages: [{ role: 'user', content: 'æµ‹è¯•' }],
        fallbackEnabled: true
      });

      expect(response).toBeDefined();
    });
  });

  describe('ç¼“å­˜æœºåˆ¶', () => {
    it('åº”è¯¥ç¼“å­˜ç›¸åŒè¯·æ±‚', async () => {
      const request = {
        messages: [{ role: 'user', content: 'æµ‹è¯•ç¼“å­˜' }]
      };

      const start1 = Date.now();
      const response1 = await service.callAI(request);
      const duration1 = Date.now() - start1;

      const start2 = Date.now();
      const response2 = await service.callAI(request);
      const duration2 = Date.now() - start2;

      expect(response1.content).toBe(response2.content);
      expect(duration2).toBeLessThan(duration1);
    });
  });
});
```

### 3. StreamingService æµ‹è¯•

```typescript
describe('StreamingService', () => {
  let service: StreamingService;

  beforeEach(() => {
    service = StreamingService.getInstance();
  });

  describe('æµä¼šè¯ç®¡ç†', () => {
    it('åº”è¯¥åˆ›å»ºæµä¼šè¯', () => {
      const sessionId = service.createStreamSession();

      expect(sessionId).toBeDefined();
      expect(typeof sessionId).toBe('string');
    });

    it('åº”è¯¥å‘é€åˆ†å—æ•°æ®', async () => {
      const sessionId = service.createStreamSession();
      const chunks: string[] = [];

      await service.sendChunked(
        sessionId,
        'è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æ¶ˆæ¯',
        (chunk) => chunks.push(chunk),
        { chunkSize: 5 }
      );

      expect(chunks.length).toBeGreaterThan(0);
      expect(chunks.join('')).toBe('è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æ¶ˆæ¯');
    });

    it('åº”è¯¥æ”¯æŒèŠ‚æµæ§åˆ¶', async () => {
      const sessionId = service.createStreamSession();
      const timestamps: number[] = [];

      await service.sendChunked(
        sessionId,
        'æµ‹è¯•èŠ‚æµ',
        () => timestamps.push(Date.now()),
        { throttleMs: 100 }
      );

      // æ£€æŸ¥æ—¶é—´é—´éš”
      for (let i = 1; i < timestamps.length; i++) {
        const interval = timestamps[i] - timestamps[i - 1];
        expect(interval).toBeGreaterThanOrEqual(90);
      }
    });
  });

  describe('æµæŒ‡æ ‡', () => {
    it('åº”è¯¥è®°å½•æµæŒ‡æ ‡', async () => {
      const sessionId = service.createStreamSession();

      await service.sendChunked(
        sessionId,
        'æµ‹è¯•æ•°æ®',
        () => {}
      );

      const metrics = service.getStreamMetrics(sessionId);

      expect(metrics).toBeDefined();
      expect(metrics.totalChunks).toBeGreaterThan(0);
      expect(metrics.totalBytes).toBeGreaterThan(0);
    });
  });
});
```

### 4. MultiRoundChatService æµ‹è¯•

```typescript
describe('MultiRoundChatService', () => {
  let service: MultiRoundChatService;

  beforeEach(() => {
    service = MultiRoundChatService.getInstance();
  });

  describe('å¯¹è¯ç®¡ç†', () => {
    it('åº”è¯¥åˆ›å»ºå¯¹è¯', () => {
      const conversationId = service.createConversation('user123');

      expect(conversationId).toBeDefined();
    });

    it('åº”è¯¥æ·»åŠ æ¶ˆæ¯', () => {
      const conversationId = service.createConversation('user123');

      service.addMessage(conversationId, {
        role: 'user',
        content: 'ä½ å¥½'
      });

      const history = service.getConversationHistory(conversationId);

      expect(history).toHaveLength(1);
      expect(history[0].content).toBe('ä½ å¥½');
    });

    it('åº”è¯¥è·å–å¯¹è¯å†å²', () => {
      const conversationId = service.createConversation('user123');

      service.addMessage(conversationId, {
        role: 'user',
        content: 'æ¶ˆæ¯1'
      });

      service.addMessage(conversationId, {
        role: 'assistant',
        content: 'å›å¤1'
      });

      const history = service.getConversationHistory(conversationId);

      expect(history).toHaveLength(2);
    });

    it('åº”è¯¥æ”¯æŒå¯¹è¯æŒä¹…åŒ–', async () => {
      const conversationId = service.createConversation('user123');

      service.addMessage(conversationId, {
        role: 'user',
        content: 'æµ‹è¯•æŒä¹…åŒ–'
      });

      await service.saveConversation(conversationId);

      // é‡æ–°åŠ è½½
      const loaded = await service.loadConversation(conversationId);

      expect(loaded).toBeDefined();
      expect(loaded.messages).toHaveLength(1);
    });
  });

  describe('å¯¹è¯åˆ†æ', () => {
    it('åº”è¯¥åˆ†æå¯¹è¯è´¨é‡', () => {
      const conversationId = service.createConversation('user123');

      service.addMessage(conversationId, {
        role: 'user',
        content: 'é—®é¢˜1'
      });

      service.addMessage(conversationId, {
        role: 'assistant',
        content: 'å›ç­”1'
      });

      const analysis = service.analyzeConversation(conversationId);

      expect(analysis).toBeDefined();
      expect(analysis.messageCount).toBe(2);
      expect(analysis.turnCount).toBe(1);
    });
  });
});
```

### 5. ToolOrchestratorService æµ‹è¯•

```typescript
describe('ToolOrchestratorService', () => {
  let service: ToolOrchestratorService;

  beforeEach(() => {
    service = ToolOrchestratorService.getInstance();
  });

  describe('å·¥å…·æ³¨å†Œ', () => {
    it('åº”è¯¥æ³¨å†Œå·¥å…·', () => {
      service.registerTool({
        name: 'testTool',
        description: 'æµ‹è¯•å·¥å…·',
        parameters: { param1: 'string' },
        execute: async (params) => ({ result: 'success' })
      });

      const tools = service.getAllTools();

      expect(tools).toContainEqual(
        expect.objectContaining({ name: 'testTool' })
      );
    });

    it('åº”è¯¥è·å–å·¥å…·å®šä¹‰', () => {
      service.registerTool({
        name: 'testTool',
        description: 'æµ‹è¯•å·¥å…·',
        parameters: {},
        execute: async () => ({})
      });

      const tool = service.getToolDefinition('testTool');

      expect(tool).toBeDefined();
      expect(tool.name).toBe('testTool');
    });
  });

  describe('å·¥å…·æ‰§è¡Œ', () => {
    it('åº”è¯¥æ‰§è¡Œå·¥å…·', async () => {
      service.registerTool({
        name: 'testTool',
        description: 'æµ‹è¯•å·¥å…·',
        parameters: {},
        execute: async (params) => ({ result: 'success' })
      });

      const result = await service.executeTool('testTool', {});

      expect(result.result).toBe('success');
    });

    it('åº”è¯¥æ”¯æŒè¶…æ—¶æ§åˆ¶', async () => {
      service.registerTool({
        name: 'slowTool',
        description: 'æ…¢å·¥å…·',
        parameters: {},
        execute: async () => {
          await new Promise(resolve => setTimeout(resolve, 5000));
          return {};
        }
      });

      const start = Date.now();

      try {
        await service.executeTool('slowTool', {}, { timeout: 1000 });
      } catch (error) {
        const duration = Date.now() - start;
        expect(duration).toBeLessThan(1500);
      }
    });

    it('åº”è¯¥æ”¯æŒé‡è¯•æœºåˆ¶', async () => {
      let attempts = 0;

      service.registerTool({
        name: 'retryTool',
        description: 'é‡è¯•å·¥å…·',
        parameters: {},
        execute: async () => {
          attempts++;
          if (attempts < 3) {
            throw new Error('Temporary failure');
          }
          return { result: 'success' };
        }
      });

      const result = await service.executeTool('retryTool', {}, {
        maxRetries: 3
      });

      expect(result.result).toBe('success');
      expect(attempts).toBe(3);
    });
  });

  describe('å·¥å…·é“¾æ‰§è¡Œ', () => {
    it('åº”è¯¥æ‰§è¡Œå·¥å…·é“¾', async () => {
      service.registerTool({
        name: 'tool1',
        description: 'å·¥å…·1',
        parameters: {},
        execute: async () => ({ value: 1 })
      });

      service.registerTool({
        name: 'tool2',
        description: 'å·¥å…·2',
        parameters: {},
        execute: async () => ({ value: 2 })
      });

      const results = await service.executeToolChain([
        { name: 'tool1', params: {} },
        { name: 'tool2', params: {} }
      ]);

      expect(results).toHaveLength(2);
      expect(results[0].value).toBe(1);
      expect(results[1].value).toBe(2);
    });

    it('åº”è¯¥æ”¯æŒå¹¶è¡Œæ‰§è¡Œ', async () => {
      service.registerTool({
        name: 'parallelTool',
        description: 'å¹¶è¡Œå·¥å…·',
        parameters: {},
        execute: async () => {
          await new Promise(resolve => setTimeout(resolve, 100));
          return { timestamp: Date.now() };
        }
      });

      const start = Date.now();

      const results = await service.executeToolChain([
        { name: 'parallelTool', params: {} },
        { name: 'parallelTool', params: {} },
        { name: 'parallelTool', params: {} }
      ], { parallel: true });

      const duration = Date.now() - start;

      expect(results).toHaveLength(3);
      expect(duration).toBeLessThan(200); // å¹¶è¡Œæ‰§è¡Œåº”è¯¥å¿«äºä¸²è¡Œ
    });
  });
});
```

---

## ğŸ”„ é›†æˆæµ‹è¯•

### å®Œæ•´æµç¨‹æµ‹è¯•

**æµ‹è¯•æ–‡ä»¶**: `server/src/services/ai-operator/__tests__/integration/ai-services.integration.test.ts`

```typescript
describe('AI Services Integration Tests', () => {
  it('åº”è¯¥å®Œæˆå®Œæ•´çš„AIå¯¹è¯æµç¨‹', async () => {
    const userId = 'test_user_001';
    const query = 'æŸ¥è¯¢å¼ ä¸‰çš„æˆç»©';

    // 1. å¼€å§‹è¿½è¸ª
    const traceId = requestTracer.startTrace(userId);

    // 2. è¯†åˆ«æ„å›¾
    const intent = await intentRecognitionService.recognizeIntent(query);
    expect(intent.intent).toBeDefined();

    // 3. æ£€ç´¢è®°å¿†
    const memory = await memoryIntegrationService.retrieveMemoryContext(
      query,
      userId
    );
    expect(memory.items).toBeDefined();

    // 4. æ„å»ºæç¤ºè¯
    const prompt = promptBuilderService.buildSystemPrompt({
      userRole: 'teacher',
      memoryContext: memory.items
    });
    expect(prompt).toBeDefined();

    // 5. åˆ›å»ºå¯¹è¯
    const conversationId = multiRoundChatService.createConversation(userId);
    multiRoundChatService.addMessage(conversationId, {
      role: 'user',
      content: query
    });

    // 6. è°ƒç”¨AI
    const response = await unifiedIntelligenceCoordinator.callAI({
      messages: [
        { role: 'system', content: prompt },
        { role: 'user', content: query }
      ]
    });
    expect(response.content).toBeDefined();

    // 7. ç»“æŸè¿½è¸ª
    requestTracer.endTrace(traceId, 'success');

    // 8. éªŒè¯è¿½è¸ª
    const analysis = requestTracer.analyzeTrace(traceId);
    expect(analysis).toBeDefined();
    expect(analysis.totalDuration).toBeGreaterThan(0);
  });
});
```

---

## ğŸ“Š æµ‹è¯•è¦†ç›–ç‡

### è¦†ç›–ç‡ç›®æ ‡

| ç»„ä»¶ | è¯­å¥è¦†ç›–ç‡ | åˆ†æ”¯è¦†ç›–ç‡ | å‡½æ•°è¦†ç›–ç‡ | è¡Œè¦†ç›–ç‡ |
|------|------------|------------|------------|----------|
| æ ¸å¿ƒæœåŠ¡ | â‰¥90% | â‰¥85% | â‰¥90% | â‰¥90% |
| ç›‘æ§æœåŠ¡ | â‰¥85% | â‰¥80% | â‰¥85% | â‰¥85% |
| é”™è¯¯å¤„ç† | â‰¥95% | â‰¥90% | â‰¥95% | â‰¥95% |
| å…¨å±€ | â‰¥90% | â‰¥85% | â‰¥90% | â‰¥90% |

### è¿è¡Œè¦†ç›–ç‡æµ‹è¯•

```bash
# è¿è¡Œæ‰€æœ‰æµ‹è¯•å¹¶ç”Ÿæˆè¦†ç›–ç‡æŠ¥å‘Š
npm run test:coverage

# æŸ¥çœ‹è¦†ç›–ç‡æŠ¥å‘Š
open coverage/index.html
```

---

**æ–‡æ¡£ç»´æŠ¤**: AIåŠ©æ‰‹å¼€å‘å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2025-10-05

