# AI助手系统性能测试指南

**版本**: 2.0.0  
**最后更新**: 2025-10-08  
**测试框架**: Jest + Artillery + K6

---

## 📋 目录

- [测试概述](#测试概述)
- [性能基准](#性能基准)
- [压力测试](#压力测试)
- [负载测试](#负载测试)
- [测试工具](#测试工具)
- [测试报告](#测试报告)

---

## 🎯 测试概述

### 测试目标

1. **性能基准测试** - 建立系统性能基线
2. **压力测试** - 确定系统极限负载
3. **负载测试** - 验证正常负载下的性能
4. **稳定性测试** - 长时间运行稳定性
5. **瓶颈分析** - 识别性能瓶颈

### 测试策略

```
性能测试金字塔
    ┌─────────────┐
    │  压力测试    │  10%  - 极限负载测试
    ├─────────────┤
    │  负载测试    │  30%  - 正常负载测试
    ├─────────────┤
    │  基准测试    │  60%  - 基础性能测试
    └─────────────┘
```

---

## 📊 性能基准

### 基准指标

| 组件 | 响应时间 | 吞吐量 | 并发数 | 错误率 |
|------|----------|--------|--------|--------|
| AI查询 | <2000ms | >100 QPS | >200 | <1% |
| 记忆检索 | <500ms | >500 QPS | >1000 | <0.5% |
| 工具执行 | <1000ms | >200 QPS | >500 | <2% |
| 流式响应 | <100ms | >1000 QPS | >2000 | <0.1% |

### 基准测试脚本

**文件**: `performance/benchmarks/ai-services.benchmark.js`

```javascript
import { check, sleep } from 'k6';
import http from 'k6/http';

export let options = {
  stages: [
    { duration: '2m', target: 10 },   // 预热
    { duration: '5m', target: 50 },   // 基准负载
    { duration: '2m', target: 0 },    // 冷却
  ],
  thresholds: {
    http_req_duration: ['p(95)<2000'],
    http_req_failed: ['rate<0.01'],
  },
};

export default function() {
  // AI查询基准测试
  let aiResponse = http.post('http://localhost:3000/api/ai/unified-chat', {
    query: '查询学生总数',
    userId: 'test_user'
  });
  
  check(aiResponse, {
    'AI查询状态正常': (r) => r.status === 200,
    'AI查询响应时间<2s': (r) => r.timings.duration < 2000,
  });
  
  sleep(1);
  
  // 记忆检索基准测试
  let memoryResponse = http.get('http://localhost:3000/api/ai/memory/search?q=学生');
  
  check(memoryResponse, {
    '记忆检索状态正常': (r) => r.status === 200,
    '记忆检索响应时间<500ms': (r) => r.timings.duration < 500,
  });
  
  sleep(0.5);
}
```

---

## 🔥 压力测试

### 压力测试配置

**目标**: 确定系统在极限负载下的表现

**测试场景**:
1. **峰值负载测试** - 模拟用户访问高峰
2. **突发负载测试** - 模拟突然的流量激增
3. **持续高负载测试** - 长时间高负载运行

### 压力测试脚本

**文件**: `performance/stress/high-load.stress.js`

```javascript
export let options = {
  stages: [
    { duration: '5m', target: 100 },   // 快速增长到100用户
    { duration: '10m', target: 500 },  // 增长到500用户
    { duration: '15m', target: 1000 }, // 增长到1000用户
    { duration: '10m', target: 1500 }, // 峰值1500用户
    { duration: '5m', target: 0 },     // 快速下降
  ],
  thresholds: {
    http_req_duration: ['p(95)<5000'],  // 95%请求<5s
    http_req_failed: ['rate<0.05'],     // 错误率<5%
  },
};

export default function() {
  // 模拟真实用户行为
  let scenarios = [
    () => testAIQuery(),
    () => testMemorySearch(),
    () => testToolExecution(),
    () => testStreamingResponse(),
  ];
  
  // 随机选择测试场景
  let scenario = scenarios[Math.floor(Math.random() * scenarios.length)];
  scenario();
  
  sleep(Math.random() * 3 + 1); // 1-4秒随机间隔
}

function testAIQuery() {
  let queries = [
    '查询学生总数',
    '分析班级成绩',
    '生成学期报告',
    '查看课程安排'
  ];
  
  let query = queries[Math.floor(Math.random() * queries.length)];
  
  let response = http.post('http://localhost:3000/api/ai/unified-chat', {
    query: query,
    userId: `stress_user_${__VU}`
  });
  
  check(response, {
    'AI查询成功': (r) => r.status === 200,
  });
}
```

---

## ⚖️ 负载测试

### 负载测试场景

**目标**: 验证系统在正常负载下的性能表现

**测试类型**:
1. **平均负载测试** - 模拟日常平均负载
2. **渐增负载测试** - 逐步增加负载
3. **波动负载测试** - 模拟负载波动

### 负载测试脚本

**文件**: `performance/load/normal-load.load.js`

```javascript
export let options = {
  stages: [
    { duration: '5m', target: 50 },   // 预热到50用户
    { duration: '30m', target: 100 }, // 稳定100用户30分钟
    { duration: '5m', target: 0 },    // 冷却
  ],
  thresholds: {
    http_req_duration: ['p(95)<1500'],
    http_req_failed: ['rate<0.01'],
    checks: ['rate>0.99'],
  },
};

export default function() {
  // 模拟教师日常使用场景
  teacherWorkflow();
  sleep(2);
}

function teacherWorkflow() {
  // 1. 登录
  let loginResponse = http.post('http://localhost:3000/api/auth/login', {
    username: `teacher_${__VU}`,
    password: 'test123'
  });
  
  if (loginResponse.status !== 200) return;
  
  let token = JSON.parse(loginResponse.body).data.token;
  let headers = { 'Authorization': `Bearer ${token}` };
  
  // 2. 查询学生信息
  let studentsResponse = http.get(
    'http://localhost:3000/api/students?page=1&pageSize=10',
    { headers }
  );
  
  check(studentsResponse, {
    '学生查询成功': (r) => r.status === 200,
    '学生查询响应时间正常': (r) => r.timings.duration < 1000,
  });
  
  // 3. AI助手查询
  let aiResponse = http.post('http://localhost:3000/api/ai/unified-chat', {
    query: '分析班级整体表现',
    userId: `teacher_${__VU}`
  }, { headers });
  
  check(aiResponse, {
    'AI查询成功': (r) => r.status === 200,
    'AI查询响应时间正常': (r) => r.timings.duration < 2000,
  });
  
  // 4. 生成报告
  let reportResponse = http.post('http://localhost:3000/api/reports/generate', {
    type: 'class_summary',
    classId: 'class_001'
  }, { headers });
  
  check(reportResponse, {
    '报告生成成功': (r) => r.status === 200,
  });
}
```

---

## 🛠️ 测试工具

### K6 性能测试

**安装和使用**:
```bash
# 安装K6
npm install -g k6

# 运行基准测试
k6 run performance/benchmarks/ai-services.benchmark.js

# 运行压力测试
k6 run performance/stress/high-load.stress.js

# 运行负载测试
k6 run performance/load/normal-load.load.js
```

### Artillery 负载测试

**配置文件**: `performance/artillery/load-test.yml`

```yaml
config:
  target: 'http://localhost:3000'
  phases:
    - duration: 300
      arrivalRate: 10
    - duration: 600
      arrivalRate: 50
    - duration: 300
      arrivalRate: 10
  defaults:
    headers:
      Content-Type: 'application/json'

scenarios:
  - name: "AI查询测试"
    weight: 40
    flow:
      - post:
          url: "/api/ai/unified-chat"
          json:
            query: "查询学生信息"
            userId: "{{ $randomString() }}"
  
  - name: "记忆检索测试"
    weight: 30
    flow:
      - get:
          url: "/api/ai/memory/search?q=学生&limit=10"
  
  - name: "工具执行测试"
    weight: 30
    flow:
      - post:
          url: "/api/ai/tools/execute"
          json:
            toolName: "query_students"
            parameters: {}
```

### 自定义性能监控

**文件**: `performance/monitors/performance-monitor.js`

```javascript
const { PerformanceObserver, performance } = require('perf_hooks');

class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.setupObservers();
  }
  
  setupObservers() {
    // HTTP请求监控
    const httpObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        this.recordMetric('http_request', {
          name: entry.name,
          duration: entry.duration,
          startTime: entry.startTime
        });
      }
    });
    httpObserver.observe({ entryTypes: ['measure'] });
    
    // 内存使用监控
    setInterval(() => {
      const memUsage = process.memoryUsage();
      this.recordMetric('memory_usage', {
        heapUsed: memUsage.heapUsed,
        heapTotal: memUsage.heapTotal,
        rss: memUsage.rss
      });
    }, 5000);
  }
  
  recordMetric(type, data) {
    if (!this.metrics.has(type)) {
      this.metrics.set(type, []);
    }
    
    this.metrics.get(type).push({
      ...data,
      timestamp: Date.now()
    });
  }
  
  getMetrics(type) {
    return this.metrics.get(type) || [];
  }
  
  generateReport() {
    const report = {};
    
    for (const [type, metrics] of this.metrics) {
      if (type === 'http_request') {
        const durations = metrics.map(m => m.duration);
        report[type] = {
          count: durations.length,
          average: durations.reduce((a, b) => a + b, 0) / durations.length,
          min: Math.min(...durations),
          max: Math.max(...durations),
          p95: this.percentile(durations, 95),
          p99: this.percentile(durations, 99)
        };
      }
    }
    
    return report;
  }
  
  percentile(arr, p) {
    const sorted = arr.sort((a, b) => a - b);
    const index = Math.ceil(sorted.length * p / 100) - 1;
    return sorted[index];
  }
}

module.exports = PerformanceMonitor;
```

---

## 📈 测试报告

### 自动化测试报告

**文件**: `performance/reports/generate-report.js`

```javascript
const fs = require('fs');
const path = require('path');

class PerformanceReportGenerator {
  constructor() {
    this.reportData = {
      timestamp: new Date().toISOString(),
      summary: {},
      details: {},
      recommendations: []
    };
  }
  
  async generateReport() {
    console.log('📊 生成性能测试报告...');
    
    // 收集测试结果
    await this.collectTestResults();
    
    // 分析性能数据
    this.analyzePerformance();
    
    // 生成建议
    this.generateRecommendations();
    
    // 输出报告
    this.outputReport();
  }
  
  async collectTestResults() {
    // 从K6结果文件读取数据
    const k6Results = this.readK6Results();
    
    // 从Artillery结果读取数据
    const artilleryResults = this.readArtilleryResults();
    
    // 合并结果
    this.reportData.details = {
      k6: k6Results,
      artillery: artilleryResults
    };
  }
  
  analyzePerformance() {
    const { k6, artillery } = this.reportData.details;
    
    this.reportData.summary = {
      averageResponseTime: this.calculateAverage(k6.http_req_duration),
      throughput: k6.http_reqs?.rate || 0,
      errorRate: k6.http_req_failed?.rate || 0,
      p95ResponseTime: k6.http_req_duration?.p95 || 0,
      p99ResponseTime: k6.http_req_duration?.p99 || 0
    };
  }
  
  generateRecommendations() {
    const { summary } = this.reportData;
    
    if (summary.averageResponseTime > 1000) {
      this.reportData.recommendations.push(
        '平均响应时间过高，建议优化数据库查询和缓存策略'
      );
    }
    
    if (summary.errorRate > 0.01) {
      this.reportData.recommendations.push(
        '错误率偏高，建议检查错误处理和重试机制'
      );
    }
    
    if (summary.p95ResponseTime > 2000) {
      this.reportData.recommendations.push(
        'P95响应时间过高，建议进行性能调优'
      );
    }
  }
  
  outputReport() {
    // 生成HTML报告
    const htmlReport = this.generateHTMLReport();
    fs.writeFileSync('performance/reports/latest-report.html', htmlReport);
    
    // 生成JSON报告
    fs.writeFileSync(
      'performance/reports/latest-report.json',
      JSON.stringify(this.reportData, null, 2)
    );
    
    // 控制台输出摘要
    this.printSummary();
  }
  
  printSummary() {
    const { summary, recommendations } = this.reportData;
    
    console.log('\n📊 性能测试报告摘要');
    console.log('='.repeat(50));
    console.log(`平均响应时间: ${summary.averageResponseTime.toFixed(2)}ms`);
    console.log(`吞吐量: ${summary.throughput.toFixed(2)} req/s`);
    console.log(`错误率: ${(summary.errorRate * 100).toFixed(2)}%`);
    console.log(`P95响应时间: ${summary.p95ResponseTime.toFixed(2)}ms`);
    console.log(`P99响应时间: ${summary.p99ResponseTime.toFixed(2)}ms`);
    
    if (recommendations.length > 0) {
      console.log('\n💡 优化建议:');
      recommendations.forEach((rec, index) => {
        console.log(`${index + 1}. ${rec}`);
      });
    }
  }
}

// 运行报告生成
if (require.main === module) {
  const generator = new PerformanceReportGenerator();
  generator.generateReport().catch(console.error);
}
```

### 持续性能监控

**文件**: `performance/monitoring/continuous-monitor.js`

```javascript
const cron = require('node-cron');
const { exec } = require('child_process');

class ContinuousPerformanceMonitor {
  constructor() {
    this.setupScheduledTests();
  }
  
  setupScheduledTests() {
    // 每小时运行基准测试
    cron.schedule('0 * * * *', () => {
      this.runBenchmarkTest();
    });
    
    // 每天凌晨2点运行完整负载测试
    cron.schedule('0 2 * * *', () => {
      this.runFullLoadTest();
    });
    
    // 每周日运行压力测试
    cron.schedule('0 3 * * 0', () => {
      this.runStressTest();
    });
  }
  
  runBenchmarkTest() {
    console.log('🔄 运行定时基准测试...');
    
    exec('k6 run performance/benchmarks/ai-services.benchmark.js --out json=results/benchmark-$(date +%Y%m%d-%H%M%S).json', 
      (error, stdout, stderr) => {
        if (error) {
          console.error('基准测试失败:', error);
          return;
        }
        
        console.log('✅ 基准测试完成');
        this.analyzeAndAlert(stdout);
      }
    );
  }
  
  analyzeAndAlert(testOutput) {
    // 分析测试结果
    const results = JSON.parse(testOutput);
    
    // 检查是否超过阈值
    if (results.metrics.http_req_duration.avg > 2000) {
      this.sendAlert('响应时间告警', '平均响应时间超过2秒');
    }
    
    if (results.metrics.http_req_failed.rate > 0.01) {
      this.sendAlert('错误率告警', '错误率超过1%');
    }
  }
  
  sendAlert(title, message) {
    console.warn(`🚨 ${title}: ${message}`);
    // 这里可以集成邮件、短信、钉钉等告警渠道
  }
}

// 启动持续监控
new ContinuousPerformanceMonitor();
```

---

## 🎯 测试最佳实践

### 测试环境准备

1. **独立测试环境** - 使用专门的性能测试环境
2. **数据准备** - 准备足够的测试数据
3. **监控工具** - 部署完整的监控体系
4. **基线建立** - 建立性能基线数据

### 测试执行原则

1. **渐进式测试** - 从小负载开始逐步增加
2. **多轮测试** - 多次运行确保结果稳定
3. **环境隔离** - 避免其他因素干扰
4. **数据清理** - 测试后及时清理数据

---

**文档维护**: AI助手开发团队  
**最后更新**: 2025-10-08
