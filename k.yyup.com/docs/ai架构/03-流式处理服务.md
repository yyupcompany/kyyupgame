# æµå¼å¤„ç†æœåŠ¡ (StreamingService)

**æœåŠ¡åç§°**: StreamingService  
**ä»£ç ä½ç½®**: `server/src/services/ai-operator/core/streaming.service.ts`  
**ä»£ç é‡**: ~190è¡Œ  
**çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

## ğŸ“‹ ç›®å½•

- [æœåŠ¡æ¦‚è¿°](#æœåŠ¡æ¦‚è¿°)
- [æ ¸å¿ƒåŠŸèƒ½](#æ ¸å¿ƒåŠŸèƒ½)
- [APIæ–‡æ¡£](#apiæ–‡æ¡£)
- [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)
- [æµ‹è¯•ç”¨ä¾‹](#æµ‹è¯•ç”¨ä¾‹)
- [æ€§èƒ½æŒ‡æ ‡](#æ€§èƒ½æŒ‡æ ‡)

---

## ğŸ¯ æœåŠ¡æ¦‚è¿°

### èŒè´£

StreamingServiceè´Ÿè´£SSEæµå¼ä¼ è¾“å¤„ç†ï¼Œæ”¯æŒåˆ†å—å‘é€ã€èŠ‚æµæ§åˆ¶ã€æµæŒ‡æ ‡è·Ÿè¸ªï¼Œä¸ºAIå“åº”æä¾›å®æ—¶æµå¼ä½“éªŒã€‚

### æ ¸å¿ƒç‰¹æ€§

1. **SSEæµå¼ä¼ è¾“** - Server-Sent Eventså®æ—¶æ¨é€
2. **åˆ†å—å‘é€** - æ™ºèƒ½åˆ†å—ï¼Œä¼˜åŒ–ä¼ è¾“æ•ˆç‡
3. **èŠ‚æµæ§åˆ¶** - å¯é…ç½®çš„å‘é€é¢‘ç‡æ§åˆ¶
4. **æµæŒ‡æ ‡è·Ÿè¸ª** - å®Œæ•´çš„æµæ€§èƒ½ç›‘æ§
5. **ä¼šè¯ç®¡ç†** - å¤šæµä¼šè¯å¹¶å‘ç®¡ç†

### è®¾è®¡æ¨¡å¼

- **å•ä¾‹æ¨¡å¼** - å…¨å±€å”¯ä¸€æµæœåŠ¡å®ä¾‹
- **è§‚å¯Ÿè€…æ¨¡å¼** - æµäº‹ä»¶ç›‘å¬å’Œå¤„ç†
- **ç­–ç•¥æ¨¡å¼** - å¤šç§åˆ†å—ç­–ç•¥
- **çŠ¶æ€æ¨¡å¼** - æµçŠ¶æ€ç®¡ç†

---

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½

### 1. SSEæµå¼ä¼ è¾“

**åŠŸèƒ½**: å»ºç«‹SSEè¿æ¥ï¼Œå®æ—¶æ¨é€æ•°æ®

**ç‰¹æ€§**:
- è‡ªåŠ¨è®¾ç½®SSEå“åº”å¤´
- æ”¯æŒå¤šç§äº‹ä»¶ç±»å‹
- è¿æ¥çŠ¶æ€ç›‘æ§
- è‡ªåŠ¨é‡è¿æœºåˆ¶

### 2. åˆ†å—å‘é€

**åŠŸèƒ½**: å°†å¤§æ–‡æœ¬åˆ†å—å‘é€ï¼Œæå‡ç”¨æˆ·ä½“éªŒ

**åˆ†å—ç­–ç•¥**:
- é»˜è®¤å—å¤§å°: 1KB
- æ™ºèƒ½æ–­å¥: é¿å…è¯æ±‡æˆªæ–­
- æ¸è¿›å¼åŠ è½½: é€æ­¥æ˜¾ç¤ºå†…å®¹
- ç¼“å†²æ§åˆ¶: é˜²æ­¢å†…å­˜æº¢å‡º

### 3. èŠ‚æµæ§åˆ¶

**åŠŸèƒ½**: æ§åˆ¶å‘é€é¢‘ç‡ï¼Œé¿å…å®¢æˆ·ç«¯è¿‡è½½

**èŠ‚æµæœºåˆ¶**:
- é»˜è®¤é—´éš”: 50ms
- å¯é…ç½®é¢‘ç‡: 10-1000ms
- è‡ªé€‚åº”è°ƒèŠ‚: æ ¹æ®ç½‘ç»œçŠ¶å†µ
- ä¼˜å…ˆçº§é˜Ÿåˆ—: é‡è¦æ¶ˆæ¯ä¼˜å…ˆ

### 4. æµæŒ‡æ ‡è·Ÿè¸ª

**åŠŸèƒ½**: ç›‘æ§æµæ€§èƒ½ï¼Œæä¾›ä¼˜åŒ–ä¾æ®

**ç›‘æ§æŒ‡æ ‡**:
- æ€»å—æ•°: å‘é€çš„æ•°æ®å—æ•°é‡
- æ€»å­—èŠ‚æ•°: ä¼ è¾“çš„æ•°æ®é‡
- ä¼ è¾“æ—¶é—´: æµçš„æŒç»­æ—¶é—´
- é”™è¯¯æ¬¡æ•°: ä¼ è¾“é”™è¯¯ç»Ÿè®¡

---

## ğŸ“– APIæ–‡æ¡£

### sendChunked

åˆ†å—å‘é€æ•°æ®

**ç­¾å**:
```typescript
async sendChunked(
  res: Response,
  event: string,
  data: string,
  options: ChunkedOptions = {}
): Promise<void>
```

**å‚æ•°**:
```typescript
interface ChunkedOptions {
  chunkSize?: number;      // å—å¤§å°ï¼Œé»˜è®¤1024
  throttleMs?: number;     // èŠ‚æµé—´éš”ï¼Œé»˜è®¤50ms
  streamId?: string;       // æµIDï¼Œç”¨äºè·Ÿè¸ª
}
```

**ç¤ºä¾‹**:
```typescript
await streamingService.sendChunked(
  res,
  'message',
  'è¿™æ˜¯ä¸€æ®µå¾ˆé•¿çš„æ–‡æœ¬å†…å®¹...',
  {
    chunkSize: 512,
    throttleMs: 100,
    streamId: 'stream_001'
  }
);
```

### startStream

å¼€å§‹æµå¼ä¼šè¯

**ç­¾å**:
```typescript
startStream(streamId: string): void
```

**åŠŸèƒ½**: åˆå§‹åŒ–æµä¼šè¯ï¼Œå¼€å§‹æŒ‡æ ‡è·Ÿè¸ª

**ç¤ºä¾‹**:
```typescript
const streamId = 'stream_' + Date.now();
streamingService.startStream(streamId);
```

### endStream

ç»“æŸæµå¼ä¼šè¯

**ç­¾å**:
```typescript
endStream(streamId: string): StreamMetrics | null
```

**è¿”å›å€¼**:
```typescript
interface StreamMetrics {
  totalChunks: number;
  totalBytes: number;
  duration: number;
  errors: number;
  avgChunkSize: number;
  throughput: number;
}
```

### streamAIResponse

æµå¼å‘é€AIå“åº”

**ç­¾å**:
```typescript
async streamAIResponse(
  res: Response,
  aiStream: AsyncIterable<any>,
  options: StreamOptions = {}
): Promise<void>
```

**åŠŸèƒ½**: ä¸“é—¨ç”¨äºAIå“åº”çš„æµå¼å‘é€

**ç¤ºä¾‹**:
```typescript
await streamingService.streamAIResponse(
  res,
  aiResponseStream,
  {
    chunkSize: 256,
    throttleMs: 30
  }
);
```

### createStreamHandler

åˆ›å»ºæµå¤„ç†å™¨

**ç­¾å**:
```typescript
createStreamHandler(res: Response, streamId?: string): StreamHandler
```

**è¿”å›å€¼**:
```typescript
interface StreamHandler {
  send: (event: string, data: any) => void;
  progress: (current: number, total: number, message?: string) => void;
  status: (status: any, message?: string) => void;
  complete: (data?: any) => void;
  error: (error: Error) => void;
  getMetrics: () => StreamMetrics | null;
}
```

---

## ğŸ’¡ ä½¿ç”¨ç¤ºä¾‹

### ç¤ºä¾‹1: åŸºç¡€æµå¼å‘é€

```typescript
import { streamingService } from './core/streaming.service';

async function sendStreamResponse(res: Response) {
  // åˆå§‹åŒ–SSEè¿æ¥
  streamingService.initializeSSE(res);
  
  // å¼€å§‹æµä¼šè¯
  const streamId = 'demo_' + Date.now();
  streamingService.startStream(streamId);
  
  // åˆ†å—å‘é€æ•°æ®
  await streamingService.sendChunked(
    res,
    'message',
    'è¿™æ˜¯ä¸€ä¸ªæµå¼å“åº”çš„æ¼”ç¤ºï¼Œå†…å®¹ä¼šåˆ†å—å‘é€ç»™å®¢æˆ·ç«¯...',
    {
      chunkSize: 20,
      throttleMs: 100,
      streamId
    }
  );
  
  // ç»“æŸæµä¼šè¯
  const metrics = streamingService.endStream(streamId);
  console.log('æµæŒ‡æ ‡:', metrics);
  
  res.end();
}
```

### ç¤ºä¾‹2: AIå“åº”æµå¼å¤„ç†

```typescript
async function streamAIChat(res: Response, aiStream: AsyncIterable<string>) {
  // åˆ›å»ºæµå¤„ç†å™¨
  const handler = streamingService.createStreamHandler(res, 'ai_chat');
  
  try {
    // å‘é€å¼€å§‹äº‹ä»¶
    handler.status('processing', 'æ­£åœ¨ç”Ÿæˆå›ç­”...');
    
    // æµå¼å‘é€AIå“åº”
    await streamingService.streamAIResponse(res, aiStream, {
      chunkSize: 256,
      throttleMs: 50
    });
    
    // å‘é€å®Œæˆäº‹ä»¶
    handler.complete({ message: 'å›ç­”ç”Ÿæˆå®Œæˆ' });
    
  } catch (error) {
    handler.error(error as Error);
  }
}
```

### ç¤ºä¾‹3: è¿›åº¦è·Ÿè¸ª

```typescript
async function streamWithProgress(res: Response) {
  const handler = streamingService.createStreamHandler(res, 'progress_demo');
  
  const tasks = ['åˆ†ææ•°æ®', 'ç”ŸæˆæŠ¥å‘Š', 'æ ¼å¼åŒ–è¾“å‡º', 'å‘é€ç»“æœ'];
  
  for (let i = 0; i < tasks.length; i++) {
    // æ›´æ–°è¿›åº¦
    handler.progress(i + 1, tasks.length, `æ­£åœ¨${tasks[i]}...`);
    
    // æ¨¡æ‹Ÿä»»åŠ¡å¤„ç†
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // å‘é€ä»»åŠ¡ç»“æœ
    handler.send('task_complete', {
      task: tasks[i],
      index: i + 1,
      result: `${tasks[i]}å®Œæˆ`
    });
  }
  
  handler.complete({ message: 'æ‰€æœ‰ä»»åŠ¡å®Œæˆ' });
}
```

---

## ğŸ§ª æµ‹è¯•ç”¨ä¾‹

### å•å…ƒæµ‹è¯•

```typescript
describe('StreamingService', () => {
  let service: StreamingService;
  let mockRes: any;

  beforeEach(() => {
    service = StreamingService.getInstance();
    mockRes = {
      setHeader: jest.fn(),
      write: jest.fn(),
      end: jest.fn()
    };
  });

  describe('sendChunked', () => {
    it('åº”è¯¥åˆ†å—å‘é€æ•°æ®', async () => {
      const data = 'è¿™æ˜¯æµ‹è¯•æ•°æ®'.repeat(100);
      
      await service.sendChunked(mockRes, 'test', data, {
        chunkSize: 50,
        throttleMs: 0
      });
      
      expect(mockRes.write).toHaveBeenCalledTimes(
        Math.ceil(data.length / 50)
      );
    });

    it('åº”è¯¥æ”¯æŒèŠ‚æµæ§åˆ¶', async () => {
      const start = Date.now();
      
      await service.sendChunked(mockRes, 'test', 'abcdefgh', {
        chunkSize: 2,
        throttleMs: 100
      });
      
      const duration = Date.now() - start;
      expect(duration).toBeGreaterThan(300); // 4ä¸ªå—ï¼Œ3ä¸ªé—´éš”
    });
  });

  describe('æµä¼šè¯ç®¡ç†', () => {
    it('åº”è¯¥è·Ÿè¸ªæµæŒ‡æ ‡', () => {
      const streamId = 'test_stream';
      
      service.startStream(streamId);
      
      // æ¨¡æ‹Ÿå‘é€æ•°æ®
      service.updateStreamMetrics(streamId, 5, 1024);
      
      const metrics = service.getStreamMetrics(streamId);
      
      expect(metrics).toBeDefined();
      expect(metrics!.totalChunks).toBe(5);
      expect(metrics!.totalBytes).toBe(1024);
    });

    it('åº”è¯¥æ¸…ç†è¿‡æœŸæµ', () => {
      const streamId = 'expired_stream';
      
      service.startStream(streamId);
      service.endStream(streamId);
      
      const metrics = service.getStreamMetrics(streamId);
      expect(metrics).toBeNull();
    });
  });

  describe('SSEåˆå§‹åŒ–', () => {
    it('åº”è¯¥è®¾ç½®æ­£ç¡®çš„å“åº”å¤´', () => {
      service.initializeSSE(mockRes);
      
      expect(mockRes.setHeader).toHaveBeenCalledWith(
        'Content-Type', 'text/event-stream'
      );
      expect(mockRes.setHeader).toHaveBeenCalledWith(
        'Cache-Control', 'no-cache'
      );
      expect(mockRes.setHeader).toHaveBeenCalledWith(
        'Connection', 'keep-alive'
      );
    });
  });
});
```

### é›†æˆæµ‹è¯•

```typescript
describe('StreamingService Integration', () => {
  it('åº”è¯¥å®Œæˆå®Œæ•´çš„æµå¼å¤„ç†', async () => {
    const service = StreamingService.getInstance();
    const chunks: string[] = [];
    
    const mockRes = {
      setHeader: jest.fn(),
      write: jest.fn((data) => chunks.push(data)),
      end: jest.fn()
    };
    
    // åˆå§‹åŒ–SSE
    service.initializeSSE(mockRes);
    
    // åˆ›å»ºæµå¤„ç†å™¨
    const handler = service.createStreamHandler(mockRes, 'integration_test');
    
    // å‘é€æ•°æ®
    handler.send('message', { content: 'æµ‹è¯•æ¶ˆæ¯' });
    handler.progress(50, 100, 'å¤„ç†ä¸­...');
    handler.complete({ result: 'å®Œæˆ' });
    
    // éªŒè¯ç»“æœ
    expect(chunks.length).toBeGreaterThan(0);
    expect(mockRes.end).toHaveBeenCalled();
  });
});
```

---

## ğŸ“Š æ€§èƒ½æŒ‡æ ‡

### ç›®æ ‡æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡ | å®é™… | çŠ¶æ€ |
|------|------|------|------|
| ååé‡ | >1MB/s | ~1.5MB/s | âœ… |
| å»¶è¿Ÿ | <50ms | ~30ms | âœ… |
| å¹¶å‘æµ | >100 | ~150 | âœ… |
| å†…å­˜ä½¿ç”¨ | <100MB | ~80MB | âœ… |

### æ€§èƒ½ä¼˜åŒ–

1. **åˆ†å—ç­–ç•¥** - æ™ºèƒ½åˆ†å—å¤§å°è°ƒèŠ‚
2. **èŠ‚æµæ§åˆ¶** - è‡ªé€‚åº”å‘é€é¢‘ç‡
3. **å†…å­˜ç®¡ç†** - åŠæ—¶æ¸…ç†è¿‡æœŸæµ
4. **è¿æ¥å¤ç”¨** - å‡å°‘è¿æ¥å¼€é”€

---

**æ–‡æ¡£ç»´æŠ¤**: AIåŠ©æ‰‹å¼€å‘å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2025-10-08
