# é”™è¯¯å¤„ç†æœåŠ¡ (UnifiedErrorHandlerService)

**æœåŠ¡åç§°**: UnifiedErrorHandlerService  
**ä»£ç ä½ç½®**: `server/src/services/ai-operator/error-handling/unified-error-handler.service.ts`  
**ä»£ç é‡**: ~350è¡Œ  
**çŠ¶æ€**: âœ… ç”Ÿäº§å°±ç»ª

---

## ğŸ“‹ ç›®å½•

- [æœåŠ¡æ¦‚è¿°](#æœåŠ¡æ¦‚è¿°)
- [æ ¸å¿ƒåŠŸèƒ½](#æ ¸å¿ƒåŠŸèƒ½)
- [APIæ–‡æ¡£](#apiæ–‡æ¡£)
- [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)
- [æµ‹è¯•ç”¨ä¾‹](#æµ‹è¯•ç”¨ä¾‹)
- [æ€§èƒ½æŒ‡æ ‡](#æ€§èƒ½æŒ‡æ ‡)

---

## ğŸ¯ æœåŠ¡æ¦‚è¿°

### èŒè´£

UnifiedErrorHandlerServiceè´Ÿè´£ç»Ÿä¸€é”™è¯¯å¤„ç†ã€åˆ†ç±»ã€é‡è¯•ã€æ¢å¤ç­–ç•¥ï¼Œæä¾›å®Œæ•´çš„é”™è¯¯ç®¡ç†å’Œç³»ç»Ÿç¨³å®šæ€§ä¿éšœã€‚

### æ ¸å¿ƒç‰¹æ€§

1. **é”™è¯¯åˆ†ç±»** - æ™ºèƒ½é”™è¯¯ç±»å‹è¯†åˆ«å’Œåˆ†ç±»
2. **é‡è¯•æœºåˆ¶** - æŒ‡æ•°é€€é¿æ™ºèƒ½é‡è¯•
3. **æ¢å¤ç­–ç•¥** - å¤šç§é”™è¯¯æ¢å¤ç­–ç•¥
4. **é”™è¯¯èšåˆ** - é”™è¯¯ç»Ÿè®¡å’Œè¶‹åŠ¿åˆ†æ
5. **å‘Šè­¦æœºåˆ¶** - é”™è¯¯é˜ˆå€¼å‘Šè­¦

### è®¾è®¡æ¨¡å¼

- **å•ä¾‹æ¨¡å¼** - å…¨å±€å”¯ä¸€é”™è¯¯å¤„ç†å™¨
- **ç­–ç•¥æ¨¡å¼** - å¤šç§é”™è¯¯å¤„ç†ç­–ç•¥
- **è´£ä»»é“¾æ¨¡å¼** - é”™è¯¯å¤„ç†é“¾
- **è§‚å¯Ÿè€…æ¨¡å¼** - é”™è¯¯äº‹ä»¶ç›‘å¬

---

## ğŸ”§ æ ¸å¿ƒåŠŸèƒ½

### 1. é”™è¯¯åˆ†ç±»

**åŠŸèƒ½**: æ™ºèƒ½è¯†åˆ«å’Œåˆ†ç±»å„ç§é”™è¯¯ç±»å‹

**é”™è¯¯ç±»å‹**:
- **ç³»ç»Ÿé”™è¯¯**: å†…å­˜ä¸è¶³ã€ç£ç›˜æ»¡ç­‰
- **ç½‘ç»œé”™è¯¯**: è¿æ¥è¶…æ—¶ã€ç½‘ç»œä¸å¯è¾¾
- **æ•°æ®åº“é”™è¯¯**: è¿æ¥å¤±è´¥ã€æŸ¥è¯¢è¶…æ—¶
- **ä¸šåŠ¡é”™è¯¯**: æ•°æ®éªŒè¯å¤±è´¥ã€æƒé™ä¸è¶³
- **å¤–éƒ¨æœåŠ¡é”™è¯¯**: APIè°ƒç”¨å¤±è´¥ã€æœåŠ¡ä¸å¯ç”¨

### 2. é‡è¯•æœºåˆ¶

**åŠŸèƒ½**: æ™ºèƒ½é‡è¯•å¤±è´¥çš„æ“ä½œ

**é‡è¯•ç­–ç•¥**:
- **æŒ‡æ•°é€€é¿**: é‡è¯•é—´éš”æŒ‡æ•°å¢é•¿
- **å›ºå®šé—´éš”**: å›ºå®šæ—¶é—´é—´éš”é‡è¯•
- **çº¿æ€§é€€é¿**: é‡è¯•é—´éš”çº¿æ€§å¢é•¿
- **è‡ªå®šä¹‰ç­–ç•¥**: åŸºäºé”™è¯¯ç±»å‹çš„è‡ªå®šä¹‰é‡è¯•

### 3. æ¢å¤ç­–ç•¥

**åŠŸèƒ½**: æä¾›å¤šç§é”™è¯¯æ¢å¤æœºåˆ¶

**æ¢å¤ç±»å‹**:
- **è‡ªåŠ¨æ¢å¤**: è‡ªåŠ¨é‡è¯•å’Œä¿®å¤
- **é™çº§æœåŠ¡**: æä¾›å¤‡ç”¨åŠŸèƒ½
- **ç†”æ–­æœºåˆ¶**: é˜²æ­¢çº§è”å¤±è´¥
- **å›æ»šæ“ä½œ**: æ’¤é”€å¤±è´¥çš„æ“ä½œ

### 4. é”™è¯¯ç›‘æ§

**åŠŸèƒ½**: ç›‘æ§å’Œåˆ†æé”™è¯¯è¶‹åŠ¿

**ç›‘æ§ç»´åº¦**:
- é”™è¯¯é¢‘ç‡ç»Ÿè®¡
- é”™è¯¯ç±»å‹åˆ†å¸ƒ
- é”™è¯¯å½±å“èŒƒå›´
- æ¢å¤æˆåŠŸç‡

---

## ğŸ“– APIæ–‡æ¡£

### handleError

å¤„ç†é”™è¯¯

**ç­¾å**:
```typescript
async handleError(
  error: Error,
  context: ErrorContext,
  options?: ErrorHandlingOptions
): Promise<ErrorHandlingResult>
```

**å‚æ•°**:
```typescript
interface ErrorContext {
  operation: string;
  userId?: string;
  traceId?: string;
  metadata?: Record<string, any>;
}

interface ErrorHandlingOptions {
  retryable?: boolean;
  maxRetries?: number;
  retryStrategy?: RetryStrategy;
  fallbackAction?: () => Promise<any>;
}
```

**è¿”å›å€¼**:
```typescript
interface ErrorHandlingResult {
  handled: boolean;
  recovered: boolean;
  retryCount: number;
  finalError?: Error;
  fallbackResult?: any;
}
```

### classifyError

é”™è¯¯åˆ†ç±»

**ç­¾å**:
```typescript
classifyError(error: Error): ErrorClassification
```

**è¿”å›å€¼**:
```typescript
interface ErrorClassification {
  category: ErrorCategory;
  severity: ErrorSeverity;
  retryable: boolean;
  recoverable: boolean;
  suggestedAction: string;
}

enum ErrorCategory {
  SYSTEM = 'system',
  NETWORK = 'network',
  DATABASE = 'database',
  BUSINESS = 'business',
  EXTERNAL = 'external'
}

enum ErrorSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}
```

### retryOperation

é‡è¯•æ“ä½œ

**ç­¾å**:
```typescript
async retryOperation<T>(
  operation: () => Promise<T>,
  options: RetryOptions
): Promise<T>
```

**å‚æ•°**:
```typescript
interface RetryOptions {
  maxRetries: number;
  strategy: RetryStrategy;
  backoffMs?: number;
  maxBackoffMs?: number;
  retryCondition?: (error: Error) => boolean;
}

enum RetryStrategy {
  EXPONENTIAL = 'exponential',
  LINEAR = 'linear',
  FIXED = 'fixed',
  CUSTOM = 'custom'
}
```

### createCircuitBreaker

åˆ›å»ºç†”æ–­å™¨

**ç­¾å**:
```typescript
createCircuitBreaker(
  name: string,
  options: CircuitBreakerOptions
): CircuitBreaker
```

**å‚æ•°**:
```typescript
interface CircuitBreakerOptions {
  failureThreshold: number;
  resetTimeout: number;
  monitoringPeriod: number;
  fallbackFunction?: () => Promise<any>;
}
```

### getErrorStats

è·å–é”™è¯¯ç»Ÿè®¡

**ç­¾å**:
```typescript
getErrorStats(timeRange?: TimeRange): ErrorStatistics
```

**è¿”å›å€¼**:
```typescript
interface ErrorStatistics {
  totalErrors: number;
  errorsByCategory: Record<ErrorCategory, number>;
  errorsBySeverity: Record<ErrorSeverity, number>;
  recoveryRate: number;
  topErrors: ErrorSummary[];
}
```

---

## ğŸ’¡ ä½¿ç”¨ç¤ºä¾‹

### ç¤ºä¾‹1: åŸºç¡€é”™è¯¯å¤„ç†

```typescript
import { unifiedErrorHandler } from './error-handling/unified-error-handler.service';

async function safeApiCall() {
  try {
    const result = await callExternalAPI();
    return result;
    
  } catch (error) {
    // ç»Ÿä¸€é”™è¯¯å¤„ç†
    const handlingResult = await unifiedErrorHandler.handleError(
      error as Error,
      {
        operation: 'external_api_call',
        userId: 'user123',
        traceId: 'trace_456'
      },
      {
        retryable: true,
        maxRetries: 3,
        retryStrategy: 'exponential',
        fallbackAction: async () => {
          // é™çº§å¤„ç†ï¼šè¿”å›ç¼“å­˜æ•°æ®
          return getCachedData();
        }
      }
    );
    
    if (handlingResult.recovered) {
      console.log('âœ… é”™è¯¯å·²æ¢å¤');
      return handlingResult.fallbackResult;
    } else {
      console.log('âŒ é”™è¯¯å¤„ç†å¤±è´¥');
      throw handlingResult.finalError;
    }
  }
}
```

### ç¤ºä¾‹2: æ•°æ®åº“æ“ä½œé”™è¯¯å¤„ç†

```typescript
async function safeDatabaseOperation() {
  const operation = async () => {
    return await Student.findAll({
      include: [Class, Grade]
    });
  };
  
  try {
    // ä½¿ç”¨é‡è¯•æœºåˆ¶
    const students = await unifiedErrorHandler.retryOperation(
      operation,
      {
        maxRetries: 3,
        strategy: 'exponential',
        backoffMs: 1000,
        maxBackoffMs: 10000,
        retryCondition: (error) => {
          // åªå¯¹ç‰¹å®šé”™è¯¯è¿›è¡Œé‡è¯•
          const classification = unifiedErrorHandler.classifyError(error);
          return classification.category === 'database' && classification.retryable;
        }
      }
    );
    
    return students;
    
  } catch (error) {
    console.error('æ•°æ®åº“æ“ä½œæœ€ç»ˆå¤±è´¥:', error);
    
    // è®°å½•é”™è¯¯
    await unifiedErrorHandler.handleError(
      error as Error,
      {
        operation: 'database_query',
        metadata: { table: 'students', operation: 'findAll' }
      }
    );
    
    throw error;
  }
}
```

### ç¤ºä¾‹3: ç†”æ–­å™¨ä½¿ç”¨

```typescript
function setupCircuitBreaker() {
  // åˆ›å»ºå¤–éƒ¨æœåŠ¡ç†”æ–­å™¨
  const externalServiceBreaker = unifiedErrorHandler.createCircuitBreaker(
    'external_service',
    {
      failureThreshold: 5,      // 5æ¬¡å¤±è´¥åç†”æ–­
      resetTimeout: 60000,      // 60ç§’åå°è¯•æ¢å¤
      monitoringPeriod: 10000,  // 10ç§’ç›‘æ§å‘¨æœŸ
      fallbackFunction: async () => {
        // ç†”æ–­æ—¶çš„é™çº§å¤„ç†
        return { message: 'æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•' };
      }
    }
  );
  
  return externalServiceBreaker;
}

async function callExternalServiceWithBreaker() {
  const breaker = setupCircuitBreaker();
  
  try {
    const result = await breaker.execute(async () => {
      // è°ƒç”¨å¤–éƒ¨æœåŠ¡
      const response = await fetch('https://external-api.com/data');
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return await response.json();
    });
    
    return result;
    
  } catch (error) {
    console.log('å¤–éƒ¨æœåŠ¡è°ƒç”¨å¤±è´¥ï¼Œå·²è§¦å‘ç†”æ–­å™¨');
    throw error;
  }
}
```

### ç¤ºä¾‹4: é”™è¯¯åˆ†ç±»å’Œå¤„ç†ç­–ç•¥

```typescript
async function intelligentErrorHandling(error: Error, context: any) {
  // é”™è¯¯åˆ†ç±»
  const classification = unifiedErrorHandler.classifyError(error);
  
  console.log('é”™è¯¯åˆ†ç±»ç»“æœ:');
  console.log(`- ç±»åˆ«: ${classification.category}`);
  console.log(`- ä¸¥é‡ç¨‹åº¦: ${classification.severity}`);
  console.log(`- å¯é‡è¯•: ${classification.retryable}`);
  console.log(`- å¯æ¢å¤: ${classification.recoverable}`);
  console.log(`- å»ºè®®æ“ä½œ: ${classification.suggestedAction}`);
  
  // æ ¹æ®åˆ†ç±»åˆ¶å®šå¤„ç†ç­–ç•¥
  let handlingOptions: any = {
    retryable: classification.retryable,
    maxRetries: 0
  };
  
  switch (classification.category) {
    case 'network':
      handlingOptions.maxRetries = 3;
      handlingOptions.retryStrategy = 'exponential';
      handlingOptions.fallbackAction = async () => {
        return getCachedResponse();
      };
      break;
      
    case 'database':
      handlingOptions.maxRetries = 2;
      handlingOptions.retryStrategy = 'linear';
      handlingOptions.fallbackAction = async () => {
        return getDefaultData();
      };
      break;
      
    case 'business':
      // ä¸šåŠ¡é”™è¯¯é€šå¸¸ä¸é‡è¯•
      handlingOptions.retryable = false;
      handlingOptions.fallbackAction = async () => {
        return { error: 'ä¸šåŠ¡è§„åˆ™éªŒè¯å¤±è´¥' };
      };
      break;
      
    case 'system':
      if (classification.severity === 'critical') {
        // ç³»ç»Ÿä¸¥é‡é”™è¯¯ï¼Œç«‹å³å‘Šè­¦
        await sendCriticalAlert(error, context);
      }
      handlingOptions.maxRetries = 1;
      break;
  }
  
  // æ‰§è¡Œé”™è¯¯å¤„ç†
  const result = await unifiedErrorHandler.handleError(
    error,
    context,
    handlingOptions
  );
  
  return result;
}
```

### ç¤ºä¾‹5: é”™è¯¯ç›‘æ§å’Œåˆ†æ

```typescript
function monitorErrorTrends() {
  console.log('ğŸ“Š é”™è¯¯ç›‘æ§æŠ¥å‘Š');
  console.log('='.repeat(50));
  
  // è·å–é”™è¯¯ç»Ÿè®¡
  const stats = unifiedErrorHandler.getErrorStats({
    start: new Date(Date.now() - 24 * 60 * 60 * 1000), // æœ€è¿‘24å°æ—¶
    end: new Date()
  });
  
  console.log(`æ€»é”™è¯¯æ•°: ${stats.totalErrors}`);
  console.log(`æ¢å¤æˆåŠŸç‡: ${(stats.recoveryRate * 100).toFixed(1)}%`);
  
  console.log('\né”™è¯¯ç±»åˆ«åˆ†å¸ƒ:');
  Object.entries(stats.errorsByCategory).forEach(([category, count]) => {
    const percentage = (count / stats.totalErrors * 100).toFixed(1);
    console.log(`- ${category}: ${count} (${percentage}%)`);
  });
  
  console.log('\né”™è¯¯ä¸¥é‡ç¨‹åº¦åˆ†å¸ƒ:');
  Object.entries(stats.errorsBySeverity).forEach(([severity, count]) => {
    const percentage = (count / stats.totalErrors * 100).toFixed(1);
    console.log(`- ${severity}: ${count} (${percentage}%)`);
  });
  
  console.log('\né«˜é¢‘é”™è¯¯ Top 5:');
  stats.topErrors.slice(0, 5).forEach((error, index) => {
    console.log(`${index + 1}. ${error.message} (${error.count} æ¬¡)`);
  });
  
  // æ£€æŸ¥æ˜¯å¦éœ€è¦å‘Šè­¦
  if (stats.recoveryRate < 0.8) {
    console.warn('âš ï¸ é”™è¯¯æ¢å¤ç‡è¿‡ä½ï¼Œå»ºè®®æ£€æŸ¥ç³»ç»ŸçŠ¶æ€');
  }
  
  if (stats.errorsBySeverity.critical > 0) {
    console.error('ğŸš¨ å‘ç°ä¸¥é‡é”™è¯¯ï¼Œéœ€è¦ç«‹å³å¤„ç†');
  }
  
  return stats;
}

// å®šæœŸç›‘æ§
setInterval(() => {
  monitorErrorTrends();
}, 5 * 60 * 1000); // æ¯5åˆ†é’Ÿç›‘æ§ä¸€æ¬¡
```

### ç¤ºä¾‹6: è‡ªå®šä¹‰é”™è¯¯å¤„ç†ç­–ç•¥

```typescript
class CustomErrorHandler {
  constructor(private errorHandler: UnifiedErrorHandlerService) {}
  
  async handleAIServiceError(error: Error, context: any) {
    // AIæœåŠ¡ç‰¹å®šçš„é”™è¯¯å¤„ç†
    const classification = this.errorHandler.classifyError(error);
    
    if (error.message.includes('rate limit')) {
      // é™æµé”™è¯¯ï¼šç­‰å¾…åé‡è¯•
      return await this.errorHandler.retryOperation(
        async () => { throw error; },
        {
          maxRetries: 3,
          strategy: 'exponential',
          backoffMs: 5000, // ä»5ç§’å¼€å§‹
          maxBackoffMs: 60000 // æœ€å¤šç­‰å¾…1åˆ†é’Ÿ
        }
      );
    }
    
    if (error.message.includes('model not available')) {
      // æ¨¡å‹ä¸å¯ç”¨ï¼šåˆ‡æ¢åˆ°å¤‡ç”¨æ¨¡å‹
      return await this.switchToFallbackModel(context);
    }
    
    if (error.message.includes('context too long')) {
      // ä¸Šä¸‹æ–‡è¿‡é•¿ï¼šå‹ç¼©åé‡è¯•
      return await this.retryWithCompressedContext(context);
    }
    
    // å…¶ä»–é”™è¯¯ä½¿ç”¨é»˜è®¤å¤„ç†
    return await this.errorHandler.handleError(error, context);
  }
  
  private async switchToFallbackModel(context: any) {
    console.log('ğŸ”„ åˆ‡æ¢åˆ°å¤‡ç”¨AIæ¨¡å‹');
    // å®ç°æ¨¡å‹åˆ‡æ¢é€»è¾‘
    return { message: 'å·²åˆ‡æ¢åˆ°å¤‡ç”¨æ¨¡å‹å¤„ç†' };
  }
  
  private async retryWithCompressedContext(context: any) {
    console.log('ğŸ—œï¸ å‹ç¼©ä¸Šä¸‹æ–‡åé‡è¯•');
    // å®ç°ä¸Šä¸‹æ–‡å‹ç¼©é€»è¾‘
    return { message: 'å·²å‹ç¼©ä¸Šä¸‹æ–‡é‡æ–°å¤„ç†' };
  }
}
```

---

## ğŸ§ª æµ‹è¯•ç”¨ä¾‹

### å•å…ƒæµ‹è¯•

```typescript
describe('UnifiedErrorHandlerService', () => {
  let errorHandler: UnifiedErrorHandlerService;

  beforeEach(() => {
    errorHandler = UnifiedErrorHandlerService.getInstance();
    errorHandler.clearErrorStats(); // æ¸…ç†å†å²æ•°æ®
  });

  describe('é”™è¯¯åˆ†ç±»', () => {
    it('åº”è¯¥æ­£ç¡®åˆ†ç±»ç½‘ç»œé”™è¯¯', () => {
      const networkError = new Error('ECONNREFUSED');
      const classification = errorHandler.classifyError(networkError);
      
      expect(classification.category).toBe('network');
      expect(classification.retryable).toBe(true);
      expect(classification.severity).toBe('medium');
    });

    it('åº”è¯¥æ­£ç¡®åˆ†ç±»æ•°æ®åº“é”™è¯¯', () => {
      const dbError = new Error('Connection timeout');
      const classification = errorHandler.classifyError(dbError);
      
      expect(classification.category).toBe('database');
      expect(classification.retryable).toBe(true);
    });

    it('åº”è¯¥æ­£ç¡®åˆ†ç±»ä¸šåŠ¡é”™è¯¯', () => {
      const businessError = new Error('Validation failed');
      const classification = errorHandler.classifyError(businessError);
      
      expect(classification.category).toBe('business');
      expect(classification.retryable).toBe(false);
    });
  });

  describe('é‡è¯•æœºåˆ¶', () => {
    it('åº”è¯¥æˆåŠŸé‡è¯•æ“ä½œ', async () => {
      let attempts = 0;
      const operation = async () => {
        attempts++;
        if (attempts < 3) {
          throw new Error('Temporary failure');
        }
        return 'success';
      };
      
      const result = await errorHandler.retryOperation(operation, {
        maxRetries: 3,
        strategy: 'fixed',
        backoffMs: 10
      });
      
      expect(result).toBe('success');
      expect(attempts).toBe(3);
    });

    it('åº”è¯¥åœ¨è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°åå¤±è´¥', async () => {
      const operation = async () => {
        throw new Error('Persistent failure');
      };
      
      await expect(
        errorHandler.retryOperation(operation, {
          maxRetries: 2,
          strategy: 'fixed',
          backoffMs: 10
        })
      ).rejects.toThrow('Persistent failure');
    });
  });

  describe('é”™è¯¯å¤„ç†', () => {
    it('åº”è¯¥å¤„ç†å¯é‡è¯•çš„é”™è¯¯', async () => {
      const error = new Error('ECONNREFUSED');
      const context = {
        operation: 'test_operation',
        userId: 'user123'
      };
      
      const result = await errorHandler.handleError(error, context, {
        retryable: true,
        maxRetries: 2,
        fallbackAction: async () => 'fallback_result'
      });
      
      expect(result.handled).toBe(true);
      expect(result.recovered).toBe(true);
      expect(result.fallbackResult).toBe('fallback_result');
    });

    it('åº”è¯¥è®°å½•é”™è¯¯ç»Ÿè®¡', async () => {
      const error = new Error('Test error');
      const context = { operation: 'test' };
      
      await errorHandler.handleError(error, context);
      
      const stats = errorHandler.getErrorStats();
      expect(stats.totalErrors).toBe(1);
    });
  });

  describe('ç†”æ–­å™¨', () => {
    it('åº”è¯¥åœ¨å¤±è´¥æ¬¡æ•°è¾¾åˆ°é˜ˆå€¼æ—¶ç†”æ–­', async () => {
      const breaker = errorHandler.createCircuitBreaker('test_breaker', {
        failureThreshold: 2,
        resetTimeout: 1000,
        monitoringPeriod: 500,
        fallbackFunction: async () => 'circuit_breaker_fallback'
      });
      
      // è§¦å‘å¤±è´¥
      for (let i = 0; i < 2; i++) {
        try {
          await breaker.execute(async () => {
            throw new Error('Service failure');
          });
        } catch (error) {
          // å¿½ç•¥é”™è¯¯
        }
      }
      
      // æ­¤æ—¶åº”è¯¥ç†”æ–­
      const result = await breaker.execute(async () => {
        throw new Error('Should not reach here');
      });
      
      expect(result).toBe('circuit_breaker_fallback');
    });
  });
});
```

---

## ğŸ“Š æ€§èƒ½æŒ‡æ ‡

### ç›®æ ‡æŒ‡æ ‡

| æŒ‡æ ‡ | ç›®æ ‡ | å®é™… | çŠ¶æ€ |
|------|------|------|------|
| é”™è¯¯å¤„ç†æ—¶é—´ | <10ms | ~5ms | âœ… |
| æ¢å¤æˆåŠŸç‡ | >80% | ~85% | âœ… |
| å†…å­˜ä½¿ç”¨ | <30MB | ~25MB | âœ… |
| å¹¶å‘å¤„ç† | >1000 | ~1200 | âœ… |

### æ€§èƒ½ä¼˜åŒ–

1. **å¼‚æ­¥å¤„ç†** - å¼‚æ­¥æ‰§è¡Œé”™è¯¯å¤„ç†é€»è¾‘
2. **æ‰¹é‡ç»Ÿè®¡** - æ‰¹é‡æ›´æ–°é”™è¯¯ç»Ÿè®¡æ•°æ®
3. **å†…å­˜ç®¡ç†** - å®šæœŸæ¸…ç†è¿‡æœŸé”™è¯¯è®°å½•
4. **ç¼“å­˜ç­–ç•¥** - ç¼“å­˜é”™è¯¯åˆ†ç±»ç»“æœ

---

**æ–‡æ¡£ç»´æŠ¤**: AIåŠ©æ‰‹å¼€å‘å›¢é˜Ÿ  
**æœ€åæ›´æ–°**: 2025-10-08
