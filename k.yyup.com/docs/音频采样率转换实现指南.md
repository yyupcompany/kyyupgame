# éŸ³é¢‘é‡‡æ ·ç‡è½¬æ¢å®ç°æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æŒ‡å—è¯¦ç»†è¯´æ˜å¦‚ä½•åœ¨VOSå‘¼å«ä¸­å¿ƒä¸­å®ç°éŸ³é¢‘é‡‡æ ·ç‡è½¬æ¢ï¼Œå‚è€ƒè±†åŒ…å®æ—¶è¯­éŸ³é›†æˆçš„æœ€ä½³å®è·µã€‚

---

## ğŸ¯ æ ¸å¿ƒéœ€æ±‚

### è½¬æ¢é“¾è·¯

```
VOSè¾“å…¥ (PCMA 8kHz)
    â†“
è§£ç  (PCMA â†’ PCM)
    â†“
é‡‡æ ·ç‡è½¬æ¢ (8kHz â†’ 16kHz)
    â†“
ASRè¯†åˆ« (PCM 16kHz)
    â†“
TTSåˆæˆ (PCM 24kHz)
    â†“
é‡‡æ ·ç‡è½¬æ¢ (24kHz â†’ 8kHz)
    â†“
ç¼–ç  (PCM â†’ PCMA)
    â†“
VOSè¾“å‡º (PCMA 8kHz)
```

### æ€§èƒ½ç›®æ ‡

| æŒ‡æ ‡ | ç›®æ ‡å€¼ |
|------|--------|
| è½¬æ¢å»¶è¿Ÿ | 7-10ms/åŒ… |
| æ—¶åºç²¾åº¦ | Â±1-5ms |
| éŸ³é¢‘è´¨é‡ | æ— å¤±çœŸ |
| CPUå ç”¨ | <5% |

---

## ğŸ”§ å®ç°æ­¥éª¤

### æ­¥éª¤1ï¼šå®‰è£…ä¾èµ–

```bash
cd server
npm install alawmulaw wave-resampler
npm install --save-dev @types/alawmulaw
```

**åº“è¯´æ˜**:
- `alawmulaw` - A-law/Î¼-lawç¼–è§£ç åº“
- `wave-resampler` - PCMé‡‡æ ·ç‡è½¬æ¢åº“

### æ­¥éª¤2ï¼šåˆ›å»ºéŸ³é¢‘è½¬æ¢å™¨

**æ–‡ä»¶**: `server/src/services/vos/audio-codec-converter.ts`

```typescript
import alawmulaw from 'alawmulaw'
import { resample } from 'wave-resampler'

export class AudioCodecConverter {
  /**
   * VOS â†’ ASR: PCMA 8kHz â†’ PCM 16kHz
   * 
   * æµç¨‹:
   * 1. PCMAè§£ç  â†’ PCM 8kHz
   * 2. é‡‡æ ·ç‡è½¬æ¢ 8kHz â†’ 16kHz
   * 3. è¿”å›PCM 16kHz
   */
  async pcmaToPcm16k(pcmaData: Buffer): Promise<Buffer> {
    try {
      console.log(`ğŸ”„ [AudioConverter] PCMAâ†’PCM16k: ${pcmaData.length} bytes`)
      
      // 1. PCMAè§£ç 
      const pcm8k = alawmulaw.alaw.decode(pcmaData)
      console.log(`   âœ… PCMAè§£ç å®Œæˆ: ${pcm8k.length} samples`)
      
      // 2. é‡‡æ ·ç‡è½¬æ¢
      const pcm16k = resample(pcm8k, 8000, 16000)
      console.log(`   âœ… é‡‡æ ·ç‡è½¬æ¢å®Œæˆ: ${pcm16k.length} samples`)
      
      return Buffer.from(pcm16k)
    } catch (error) {
      console.error('âŒ PCMAâ†’PCM16kè½¬æ¢å¤±è´¥:', error)
      throw error
    }
  }

  /**
   * TTS â†’ VOS: PCM 24kHz â†’ PCMA 8kHz
   * 
   * æµç¨‹:
   * 1. é‡‡æ ·ç‡è½¬æ¢ 24kHz â†’ 8kHz
   * 2. PCMç¼–ç  â†’ PCMA
   * 3. è¿”å›PCMA 8kHz
   */
  async pcm24kToPcma(pcm24kData: Buffer): Promise<Buffer> {
    try {
      console.log(`ğŸ”„ [AudioConverter] PCM24kâ†’PCMA: ${pcm24kData.length} bytes`)
      
      // ç¡®ä¿Bufferå¯¹é½ï¼ˆå¤„ç†ä¸åŒéŸ³è‰²çš„å…¼å®¹æ€§ï¼‰
      const alignedData = this.ensureBufferAlignment(pcm24kData)
      
      // 1. é‡‡æ ·ç‡è½¬æ¢
      const pcm8k = resample(alignedData, 24000, 8000)
      console.log(`   âœ… é‡‡æ ·ç‡è½¬æ¢å®Œæˆ: ${pcm8k.length} samples`)
      
      // 2. PCMç¼–ç 
      const pcma = alawmulaw.alaw.encode(pcm8k)
      console.log(`   âœ… PCMAç¼–ç å®Œæˆ: ${pcma.length} bytes`)
      
      return Buffer.from(pcma)
    } catch (error) {
      console.error('âŒ PCM24kâ†’PCMAè½¬æ¢å¤±è´¥:', error)
      throw error
    }
  }

  /**
   * Bufferå†…å­˜å¯¹é½å¤„ç†
   * 
   * é—®é¢˜: ä¸åŒéŸ³è‰²çš„Bufferå¯èƒ½æœ‰ä¸åŒçš„byteOffset
   * è§£å†³: åˆ›å»ºæ–°çš„å¯¹é½Bufferï¼Œç¡®ä¿byteOffsetä»0å¼€å§‹
   */
  private ensureBufferAlignment(data: Buffer): Buffer {
    if (data.byteOffset % 2 !== 0) {
      console.warn(`âš ï¸  Bufferæœªå¯¹é½ (offset=${data.byteOffset}), åˆ›å»ºæ–°Buffer`)
      return Buffer.from(data)
    }
    return data
  }
}

// å¯¼å‡ºå•ä¾‹
export const audioCodecConverter = new AudioCodecConverter()
```

### æ­¥éª¤3ï¼šé›†æˆåˆ°ASRæµç¨‹

**ä¿®æ”¹**: `server/src/services/call-audio-stream.service.ts`

```typescript
import { audioCodecConverter } from './vos/audio-codec-converter'

export class CallAudioStreamService extends EventEmitter {
  /**
   * å¤„ç†æ¥è‡ªVOSçš„éŸ³é¢‘æ•°æ®
   */
  async processAudioFromVOS(callId: string, pcmaData: Buffer): Promise<void> {
    const session = this.activeSessions.get(callId)
    if (!session) {
      console.warn(`âš ï¸  ä¼šè¯ä¸å­˜åœ¨: ${callId}`)
      return
    }

    try {
      // 1. è½¬æ¢é‡‡æ ·ç‡: PCMA 8kHz â†’ PCM 16kHz
      const pcm16k = await audioCodecConverter.pcmaToPcm16k(pcmaData)
      
      // 2. ç«‹å³å‘é€ç»™ASRï¼ˆä¸ç¼“å†²ï¼‰
      if (session.asrConnection) {
        session.asrConnection.send(pcm16k)
        console.log(`ğŸ“¤ [ASR] å‘é€éŸ³é¢‘: ${pcm16k.length} bytes`)
      }
      
      // 3. å‘å‡ºäº‹ä»¶
      this.emit('audio-processed', {
        callId,
        audioData: pcm16k,
        format: 'pcm',
        sampleRate: 16000
      })
    } catch (error) {
      console.error(`âŒ éŸ³é¢‘å¤„ç†å¤±è´¥ (${callId}):`, error)
      this.emit('audio-error', { callId, error })
    }
  }
}
```

### æ­¥éª¤4ï¼šé›†æˆåˆ°TTSæµç¨‹

**ä¿®æ”¹**: `server/src/services/doubao-realtime-voice.service.ts`

```typescript
import { audioCodecConverter } from './vos/audio-codec-converter'

export class DoubaoRealtimeVoiceService extends EventEmitter {
  /**
   * å¤„ç†TTSéŸ³é¢‘è¾“å‡º
   */
  async handleTTSAudioOutput(sessionId: string, pcm24kData: Buffer): Promise<void> {
    try {
      // 1. è½¬æ¢é‡‡æ ·ç‡: PCM 24kHz â†’ PCMA 8kHz
      const pcmaData = await audioCodecConverter.pcm24kToPcma(pcm24kData)
      
      // 2. ç«‹å³å‘é€ç»™VOS
      const session = this.sessions.get(sessionId)
      if (session?.callId) {
        await this.sendAudioToVOS(session.callId, pcmaData)
        console.log(`ğŸ“¤ [VOS] å‘é€éŸ³é¢‘: ${pcmaData.length} bytes`)
      }
      
      // 3. å‘å‡ºäº‹ä»¶
      this.emit('audio-output', {
        sessionId,
        audioData: pcmaData,
        format: 'pcma',
        sampleRate: 8000
      })
    } catch (error) {
      console.error(`âŒ TTSéŸ³é¢‘å¤„ç†å¤±è´¥ (${sessionId}):`, error)
      this.emit('audio-error', { sessionId, error })
    }
  }
}
```

### æ­¥éª¤5ï¼šä¼˜åŒ–RTPå‘é€æ—¶åº

**ä¿®æ”¹**: `server/src/services/vos/vos-dialer.service.ts`

```typescript
/**
 * ç²¾ç¡®æ—¶åºå‘é€RTPåŒ…
 *
 * åŸç†: ä½¿ç”¨ç»å¯¹æ—¶é—´è€Œä¸æ˜¯ç´¯ç§¯setTimeout
 * æ•ˆæœ: æ—¶åºç²¾åº¦ä»Â±100msæå‡åˆ°Â±1-5ms
 *
 * RTPåŒ…é—´éš”è®¡ç®—:
 * - åŒ…å¤§å°: 160 bytes (PCMA @ 8kHz)
 * - é‡‡æ ·ç‡: 8000 Hz
 * - æ¯ä¸ªæ ·æœ¬: 1/8000 = 0.125ms
 * - 160ä¸ªæ ·æœ¬: 160 * 0.125ms = 20ms
 * - æ‰€ä»¥æ¯ä¸ªRTPåŒ…é—´éš”æ˜¯20ms
 */
async sendAudioWithPreciseTiming(
  callId: string,
  pcmaData: Buffer,
  packetSize: number = 160
): Promise<void> {
  const packetInterval = 20 // ms (160 bytes @ 8kHz = 20ms)
  const startTime = Date.now()
  let packetCount = 0

  console.log(`ğŸ“¤ [RTP] å¼€å§‹å‘é€éŸ³é¢‘: ${pcmaData.length} bytes, ${Math.ceil(pcmaData.length / packetSize)} åŒ…`)

  for (let i = 0; i < pcmaData.length; i += packetSize) {
    const packet = pcmaData.slice(i, i + packetSize)
    
    // ç»å¯¹æ—¶é—´è®¡ç®—ï¼ˆå…³é”®ï¼ï¼‰
    const expectedTime = startTime + packetCount * packetInterval
    const currentTime = Date.now()
    const waitTime = expectedTime - currentTime
    
    // å¦‚æœéœ€è¦ç­‰å¾…ï¼Œç²¾ç¡®ç­‰å¾…
    if (waitTime > 0) {
      await new Promise(resolve => setTimeout(resolve, waitTime))
    }
    
    // å‘é€RTPåŒ…
    await this.sendRTPPacket(callId, packet)
    
    // æ—¥å¿—ï¼ˆæ¯10åŒ…è¾“å‡ºä¸€æ¬¡ï¼‰
    if (packetCount % 10 === 0) {
      const actualTime = Date.now() - startTime
      const expectedTotalTime = packetCount * packetInterval
      const drift = actualTime - expectedTotalTime
      console.log(`   ğŸ“Š åŒ…#${packetCount}: æ—¶é—´æ¼‚ç§»=${drift}ms`)
    }
    
    packetCount++
  }

  console.log(`âœ… [RTP] å‘é€å®Œæˆ: ${packetCount} åŒ…, æ€»è€—æ—¶: ${Date.now() - startTime}ms`)
}
```

---

## ğŸ§ª æµ‹è¯•éªŒè¯

### å•å…ƒæµ‹è¯•

**æ–‡ä»¶**: `server/tests/services/audio-codec-converter.test.ts`

```typescript
import { describe, it, expect } from 'vitest'
import { audioCodecConverter } from '@/services/vos/audio-codec-converter'

describe('AudioCodecConverter', () => {
  it('åº”è¯¥æ­£ç¡®è½¬æ¢PCMAâ†’PCM16k', async () => {
    // åˆ›å»ºæ¨¡æ‹ŸPCMAæ•°æ® (160 bytes = 20ms @ 8kHz)
    const pcmaData = Buffer.alloc(160)
    
    const result = await audioCodecConverter.pcmaToPcm16k(pcmaData)
    
    // PCM 16kHz 20ms = 320 bytes (16000 * 2 * 0.02)
    expect(result.length).toBe(320)
  })

  it('åº”è¯¥æ­£ç¡®è½¬æ¢PCM24kâ†’PCMA', async () => {
    // åˆ›å»ºæ¨¡æ‹ŸPCM 24kHzæ•°æ® (960 bytes = 20ms @ 24kHz)
    const pcm24kData = Buffer.alloc(960)
    
    const result = await audioCodecConverter.pcm24kToPcma(pcm24kData)
    
    // PCMA 8kHz 20ms = 160 bytes (8000 * 0.02)
    expect(result.length).toBe(160)
  })
})
```

### é›†æˆæµ‹è¯•

```bash
# è¿è¡Œæµ‹è¯•
npm run test:unit -- audio-codec-converter

# æ£€æŸ¥æ€§èƒ½
npm run test:performance -- audio-codec-converter
```

---

## ğŸ“Š æ€§èƒ½ç›‘æ§

### æ·»åŠ æ€§èƒ½æ—¥å¿—

```typescript
const startTime = performance.now()
const result = await audioCodecConverter.pcmaToPcm16k(pcmaData)
const duration = performance.now() - startTime

console.log(`â±ï¸  è½¬æ¢è€—æ—¶: ${duration.toFixed(2)}ms`)

// ç›®æ ‡: 7-10ms
if (duration > 15) {
  console.warn(`âš ï¸  è½¬æ¢è€—æ—¶è¿‡é•¿: ${duration.toFixed(2)}ms`)
}
```

### ç›‘æ§æŒ‡æ ‡

- **è½¬æ¢å»¶è¿Ÿ**: åº”è¯¥ < 15ms
- **å†…å­˜å ç”¨**: åº”è¯¥ < 10MB
- **CPUå ç”¨**: åº”è¯¥ < 5%

---

## ğŸ› å¸¸è§é—®é¢˜

### Q1: è½¬æ¢åéŸ³é¢‘æ— å£°

**åŸå› **: é‡‡æ ·ç‡è½¬æ¢å‚æ•°é”™è¯¯

**è§£å†³**:
```typescript
// âŒ é”™è¯¯
const pcm16k = resample(pcm8k, 16000, 8000)  // åå‘äº†ï¼

// âœ… æ­£ç¡®
const pcm16k = resample(pcm8k, 8000, 16000)  // æºé‡‡æ ·ç‡ â†’ ç›®æ ‡é‡‡æ ·ç‡
```

### Q2: è½¬æ¢åéŸ³é¢‘å¤±çœŸ

**åŸå› **: Bufferå†…å­˜å¯¹é½é—®é¢˜

**è§£å†³**:
```typescript
// ç¡®ä¿Bufferå¯¹é½
const alignedData = Buffer.from(pcm24kData)
const pcm8k = resample(alignedData, 24000, 8000)
```

### Q3: è½¬æ¢è€—æ—¶è¿‡é•¿

**åŸå› **: ä½¿ç”¨äº†ffmpegï¼ˆå·²åºŸå¼ƒï¼‰

**è§£å†³**: ä½¿ç”¨çº¯JavaScriptåº“
```typescript
// âŒ æ—§æ–¹æ¡ˆ (100-400ms)
const result = await execFile('ffmpeg', [...])

// âœ… æ–°æ–¹æ¡ˆ (7-10ms)
const result = resample(pcm8k, 8000, 16000)
```

---

## ğŸ“š å‚è€ƒèµ„æº

- [alawmulawæ–‡æ¡£](https://www.npmjs.com/package/alawmulaw)
- [wave-resampleræ–‡æ¡£](https://www.npmjs.com/package/wave-resampler)
- [VOSè±†åŒ…å®æ—¶è¯­éŸ³é›†æˆæµ‹è¯•](./VOS+è±†åŒ…å®æ—¶è¯­éŸ³é›†æˆæµ‹è¯•æ–‡æ¡£.md)

---

**ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-10-25  
**çŠ¶æ€**: å¾…å®æ–½

