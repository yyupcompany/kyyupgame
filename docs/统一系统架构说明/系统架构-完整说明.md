# 系统架构完整说明

## 一、系统总览

### 1.1 双系统架构

本项目采用**主从架构**的SaaS多租户系统，包含两个独立但紧密集成的系统：

```
┌────────────────────────────────────────────────────────────┐
│           统一租户管理系统 (Master System)                    │
│         Unified Tenant Management System                    │
│                                                              │
│  - 域名: rent.yyup.cc                                       │
│  - 端口: 4001                                               │
│  - 数据库: admin_tenant_management (29表)                   │
│  - 职责: 认证、租户管理、AI服务、资源分配                      │
└───────────────────┬────────────────────────────────────────┘
                    │
        ┌───────────┴───────────┐
        │   统一认证 (Auth)      │
        │   AI Bridge           │
        │   资源分配             │
        └───────────┬───────────┘
                    ↓
┌──────────────────────────────────────────────────────────────┐
│              幼儿园租户实例系统 (Tenant Instances)             │
│           Kindergarten Tenant Instance System                │
│                                                               │
│  测试站点:                                                    │
│  - 域名: k.yyup.cc                                           │
│  - 数据库: kargerdensales (模板+测试)                         │
│                                                               │
│  租户实例 (k001, k002, ...):                                 │
│  - 域名: k001.yyup.cc, k002.yyup.cc                          │
│  - 数据库: rent001, rent002, ... (独立数据库)                 │
│  - OSS: /{phone}/                                            │
│  - 职责: 幼儿园业务管理、招生、教学                            │
└──────────────────────────────────────────────────────────────┘
```

### 1.2 目录结构

```
/home/zhgue/kyyupgame/
├── unified-tenant-system/          # 统一租户管理系统
│   ├── server/                     # 后端服务 (4001端口)
│   │   ├── src/
│   │   │   ├── services/
│   │   │   │   ├── unified-auth.service.ts      # 统一认证
│   │   │   │   ├── tenant.service.ts            # 租户管理
│   │   │   │   ├── ai/*.ts                      # AI服务
│   │   │   │   └── dynamic-dns.service.ts       # 域名服务
│   │   │   ├── routes/
│   │   │   │   ├── auth.routes.ts               # 认证路由
│   │   │   │   ├── tenant.routes.ts             # 租户路由
│   │   │   │   └── ai/tenant-ai-bridge.routes.ts # AI Bridge
│   │   │   └── models/                          # 数据模型
│   │   └── .env                    # DB_NAME=admin_tenant_management
│   └── client/                     # 前端 (管理界面)
│
├── k.yyup.com/                     # 幼儿园租户实例系统 (模板+测试)
│   ├── server/                     # 后端服务 (3000端口)
│   │   ├── src/
│   │   │   ├── routes/
│   │   │   ├── controllers/
│   │   │   ├── models/             # 85+个业务表模型
│   │   │   └── services/
│   │   └── .env                    # DB_NAME=kargerdensales
│   └── client/                     # 前端 (Vue3 + ElementPlus)
│
└── docs/                           # 文档目录
    └── 统一系统架构说明/
        ├── 系统架构-完整说明.md       # 本文档
        ├── 系统架构-API接口.md        # API文档
        ├── 租户开通流程.md            # 租户开通
        └── 数据库配置说明.md          # 数据库文档
```

## 二、数据库架构详解

### 2.1 admin_tenant_management 数据库 (29张表)

**用途**: 统一租户管理和全局认证

#### 核心表详解

##### 1. 用户认证相关 (3表)

**admin_users** - 系统管理员表
```sql
字段:
- id: int (主键)
- username: varchar(50) UNIQUE
- email: varchar(255) UNIQUE  
- password: varchar(255)          # 注意: 列名是password不是password_hash
- role: enum('super_admin', 'admin', 'operator')
- status: enum('active', 'inactive', 'suspended')
- last_login_at: datetime
- created_at, updated_at: datetime

用途: 
- 管理整个统一租户系统的管理员账号
- 使用username登录 (NOT phone)
- 当前有2个管理员: admin, operator
```

**global_users** - 租户用户全局表
```sql
字段:
- id: bigint AUTO_INCREMENT (主键)
- phone: varchar(20) UNIQUE         # 登录凭证
- password_hash: varchar(255)       # 密码哈希
- real_name: varchar(50)
- registration_source: varchar(100) DEFAULT 'web'
- status: enum('active', 'suspended', 'deleted')
- created_at, updated_at, last_login_at: timestamp

用途:
- 所有租户用户的全局统一认证
- 使用phone作为登录凭证 (NOT username)
- 一个用户可以属于多个租户
- 当前有23个用户
```

**global_user_tenant_relations** - 用户租户关联表
```sql
字段:
- id: bigint AUTO_INCREMENT (主键)
- global_user_id: bigint           # 关联global_users.id
- tenant_code: varchar(50)         # 关联tenants.tenant_id
- tenant_user_id: varchar(255)     # 租户内部用户ID
- role_in_tenant: varchar(50)      # 租户内角色
- permissions: json                # 租户内权限
- first_login_at, last_login_at: timestamp
- login_count: int
- created_at, updated_at: timestamp

用途:
- 管理用户与租户的多对多关系
- 用户在不同租户中可以有不同角色
- 记录登录统计信息
- 当前有19条关联记录
```

##### 2. 租户管理相关 (2表)

**tenants** - 租户信息表
```sql
字段:
- id: int AUTO_INCREMENT (主键)
- tenant_id: varchar(50) UNIQUE    # 租户代码 k001, k002
- name: varchar(255)               # 租户名称
- domain: varchar(255) UNIQUE      # 域名
- database_name: varchar(100) UNIQUE # 数据库名
- status: enum('active', 'inactive', 'suspended', 'deleted')
- plan_type: enum('basic', 'standard', 'premium', 'enterprise')
- max_users, max_storage: int
- contact_name, contact_email, contact_phone: varchar
- settings: json
- created_by: int
- deleted_at, scheduled_deletion_at: datetime
- created_at, updated_at: datetime

用途:
- 存储所有租户的基本信息
- 管理租户生命周期
- 当前有13个活跃租户
```

**tenant_accounts** - 租户账户表
```sql
字段:
- id: int AUTO_INCREMENT (主键)
- tenant_id: varchar(50) UNIQUE
- balance: decimal(10,2)
- credit_limit: decimal(10,2)
- payment_status: enum
- billing_cycle: enum
- created_at, updated_at: datetime

用途:
- 租户计费和账户管理
- 余额和信用额度管理
```

##### 3. AI服务相关 (5表)

**ai_model_config** - AI模型配置表
```sql
字段:
- id: int (主键)
- name: varchar(100) UNIQUE        # 模型名称
- display_name: varchar(200)       # 显示名称
- model_type: enum('text', 'image', 'audio', 'multimodal')
- provider: varchar(50)            # openai, anthropic, doubao
- endpoint_url: varchar(500)
- api_key: varchar(500)
- model_parameters: json           # 模型参数配置
- is_default: boolean
- status: enum('active', 'inactive', 'deprecated')
- created_at, updated_at: datetime

用途:
- 统一管理所有AI模型配置
- 支持多个AI提供商
- 配置默认模型
```

**tenant_ai_model_configs** - 租户AI模型配置
```sql
字段:
- id: int (主键)
- tenant_id: int                   # 关联tenants.id
- model_id: int                    # 关联ai_model_config.id
- is_enabled: boolean
- priority: int
- custom_parameters: json
- created_at, updated_at: datetime

用途:
- 为每个租户配置可用的AI模型
- 自定义模型参数
- 设置优先级
```

**ai_service_call_logs** - AI服务调用日志
```sql
字段:
- id: int (主键)
- tenant_id: int
- user_id: varchar(255)
- model_id: int
- request_id: varchar(255) UNIQUE
- session_id: varchar(255)
- input_tokens, output_tokens, total_tokens: int
- cost: decimal(10,6)
- response_time: int               # 响应时间(ms)
- status: enum('success', 'error', 'timeout')
- error_message: text
- user_agent, ip_address: text
- metadata: json
- created_at: timestamp

用途:
- 记录所有AI调用详情
- 统计Token使用量
- 成本计算和分析
- 问题追踪
```

**tenant_ai_usage_summary** - 租户AI使用汇总
```sql
字段:
- id: int (主键)
- tenant_id: int
- model_id: int
- date: date
- total_calls: int
- total_input_tokens, total_output_tokens: int
- total_cost: decimal(12,6)
- average_response_time: int
- success_rate: decimal(5,4)
- error_count: int
- created_at, updated_at: timestamp

用途:
- 按天汇总租户AI使用情况
- 生成账单数据
- 使用趋势分析
```

##### 4. 其他系统表

- `audit_logs` - 审计日志
- `billing_records` - 账单记录
- `billing_rules` - 计费规则
- `data_access_logs` - 数据访问日志
- `data_backup_records` - 备份记录
- `invitation_links` - 邀请链接
- `invitation_usage_stats` - 邀请统计
- `login_history` - 登录历史
- `notification_logs` - 通知日志
- `permission_changes` - 权限变更
- `scheduled_tasks` - 定时任务
- `security_events` - 安全事件
- `sms_config` - 短信配置
- `system_config` - 系统配置
- `tenant_billing_rules` - 租户计费规则
- `tenant_cleanup_logs` - 租户清理日志
- `tenant_init_progress` - 租户初始化进度
- `tenant_init_steps` - 租户初始化步骤
- `tenant_sub_accounts` - 租户子账户
- `tenant_user_details` - 租户用户详情
- `tenant_user_statistics` - 租户用户统计
- `unified_auth_logs` - 统一认证日志
- `user_registrations` - 用户注册记录

### 2.2 kargerdensales 数据库 (85+张表)

**用途**: 租户业务模板 + 测试站点

**三重角色**:
1. **模板数据库** - 新租户创建时复制此数据库
2. **测试站点** - k.yyup.cc使用此数据库
3. **开发参考** - Schema标准

#### 核心业务表

##### 1. 用户权限系统 (7表)
- `users` (574条) - 租户内部用户
- `roles` - 角色定义
- `permissions` - 权限定义
- `user_roles` - 用户角色关联
- `role_permissions` - 角色权限关联
- `user_profiles` - 用户资料
- `token_blacklist` - Token黑名单

##### 2. 学生家长系统 (4表)
- `students` - 学生信息
- `parents` - 家长信息
- `parent_student_relations` - 家长学生关系
- `classes` - 班级信息

##### 3. 教师系统 (2表)
- `teachers` - 教师信息
- `class_teachers` - 班级教师关联

##### 4. 招生管理系统 (10表)
- `enrollment_plans` - 招生计划
- `enrollment_applications` - 报名申请
- `enrollment_quotas` - 招生配额
- `enrollment_consultations` - 招生咨询
- `enrollment_consultation_followups` - 咨询跟进
- `enrollment_tasks` - 招生任务
- `admission_results` - 录取结果
- `admission_notifications` - 录取通知
- `enrollment_interviews` - 面试记录
- `channel_tracking` - 渠道追踪

##### 5. 活动管理系统 (10表)
- `activities` - 活动信息
- `activity_templates` - 活动模板
- `activity_registrations` - 活动报名
- `activity_evaluations` - 活动评价
- `activity_plans` - 活动计划
- `activity_arrangements` - 活动安排
- `activity_resources` - 活动资源
- `activity_staff` - 活动人员
- `activity_shares` - 活动分享
- `activity_posters` - 活动海报

##### 6. 营销管理系统 (8表)
- `marketing_campaigns` - 营销活动
- `advertisements` - 广告管理
- `channels` - 渠道管理
- `conversion_tracking` - 转化追踪
- `coupons` - 优惠券
- `referral_codes` - 推荐码
- `referral_relationships` - 推荐关系
- `referral_rewards` - 推荐奖励

##### 7. 内容管理系统 (6表)
- `poster_templates` - 海报模板
- `poster_elements` - 海报元素
- `poster_generations` - 海报生成
- `poster_categories` - 海报分类
- `personal_posters` - 个人海报
- `message_templates` - 消息模板

##### 8. AI助手系统 (12表)
- `ai_model_config` - AI模型配置
- `ai_model_usage` - AI使用记录
- `ai_model_billing` - AI计费
- `ai_conversations` - AI对话
- `ai_messages` - AI消息
- `ai_memories` - AI记忆
- `ai_feedback` - AI反馈
- `ai_user_permissions` - AI权限
- `ai_user_relations` - AI用户关系
- `ai_query_logs` - AI查询日志
- `ai_query_cache` - AI查询缓存
- `ai_query_templates` - AI查询模板

##### 9. 系统管理 (10表)
- `system_config` - 系统配置
- `system_logs` - 系统日志
- `operation_logs` - 操作日志
- `notifications` - 通知
- `schedules` - 日程
- `todos` - 待办事项
- `file_storage` - 文件存储
- `kindergartens` - 幼儿园信息
- `page_guides` - 页面指引
- `scripts` - 话术脚本

##### 10. 其他业务表
- 专家咨询系统
- 绩效管理系统
- 安全管理系统
- 审批流程系统
- 等...

**注意**: `users` 表有574条记录，是租户内部用户管理，与 `global_users` 不同！

### 2.3 租户独立数据库

每个租户拥有独立的数据库，从 `kargerdensales` 复制而来：

```
数据库实例:
- rent001 (租户k001的数据库)
- rent002 (租户k002的数据库)
- ... 
- rent022 (当前最新)

特点:
- 完全独立的Schema
- 数据完全隔离
- 可独立扩展表结构
```

## 三、认证系统详解

### 3.1 统一认证流程

```
┌─────────────┐
│   用户登录   │
│ (手机号密码) │
└──────┬──────┘
       │
       ↓
┌──────────────────────────────────────┐
│  unified-tenant-system               │
│  POST /api/auth/login                │
│                                      │
│  1. 查询 global_users 表             │
│     WHERE phone = ?                  │
│  2. bcrypt验证 password_hash         │
│  3. 生成JWT Token                    │
│  4. 返回 global_user_id + token      │
└──────┬───────────────────────────────┘
       │
       ↓
┌──────────────────────────────────────┐
│  查询用户可访问的租户列表             │
│  SELECT * FROM                       │
│    global_user_tenant_relations      │
│  WHERE global_user_id = ?            │
│  JOIN tenants                        │
└──────┬───────────────────────────────┘
       │
       ↓
┌──────────────────────────────────────┐
│  用户选择目标租户                     │
│  tenant_id: k001                     │
└──────┬───────────────────────────────┘
       │
       ↓
┌──────────────────────────────────────┐
│  k.yyup.com (租户系统)                │
│                                      │
│  1. 验证Token                        │
│  2. 从Token提取 global_user_id       │
│  3. 切换到租户数据库 (rent001)        │
│  4. 查询租户内用户信息                │
│  5. 加载用户权限                     │
│  6. 允许访问租户资源                  │
└──────────────────────────────────────┘
```

### 3.2 认证服务实现

#### unified-auth.service.ts (统一认证服务)

**位置**: `unified-tenant-system/server/src/services/unified-auth.service.ts`

**核心方法**:

1. **authenticate(phone, password)** - 用户认证
```typescript
async authenticate(request: AuthenticateRequest): Promise<AuthenticateResponse> {
  // 1. 查找用户
  const user = await this.findUserByPhone(phone);
  
  // 2. 检查用户状态
  if (user.status === 'locked' || user.status === 'inactive') {
    return { success: false, message: '账户已锁定' };
  }
  
  // 3. 验证密码
  const isValid = await bcrypt.compare(password, user.password_hash);
  if (!isValid) {
    await this.handleFailedLogin(user);
    return { success: false, message: '密码错误' };
  }
  
  // 4. 生成Token
  const token = this.generateToken(user.id);
  const refreshToken = this.generateRefreshToken(user.id);
  
  // 5. 更新登录时间
  await this.handleSuccessfulLogin(user);
  
  return {
    success: true,
    data: {
      globalUserId: user.id,
      phone: user.phone,
      realName: user.real_name,
      token,
      refreshToken
    }
  };
}
```

2. **register(phone, password, realName)** - 用户注册
```typescript
async register(request: RegisterRequest): Promise<RegisterResponse> {
  // 1. 检查手机号是否已存在
  const existingUser = await this.findUserByPhone(phone);
  if (existingUser) {
    return { success: false, message: '手机号已被注册' };
  }
  
  // 2. 验证密码强度
  if (!this.validatePassword(password)) {
    return { success: false, message: '密码不符合要求' };
  }
  
  // 3. 密码加密
  const passwordHash = await bcrypt.hash(password, 12);
  const globalUserId = this.generateGlobalUserId();
  
  // 4. 创建用户
  await sequelize.query(`
    INSERT INTO global_users (
      id, phone, password_hash, real_name, email,
      registration_source, created_at
    ) VALUES (?, ?, ?, ?, ?, ?, NOW())
  `, [globalUserId, phone, passwordHash, realName, email, registrationSource]);
  
  return {
    success: true,
    data: { globalUserId, phone, realName }
  };
}
```

3. **findUserTenants(phone)** - 查询用户租户
```typescript
async findUserTenants(request: FindUserTenantsRequest): Promise<FindUserTenantsResponse> {
  const user = await this.findUserByPhone(phone);
  
  const [tenants] = await sequelize.query(`
    SELECT 
      t.tenant_id as tenantCode,
      t.name as tenantName,
      t.domain,
      utr.role_in_tenant as role,
      utr.last_login_at as lastLoginAt,
      utr.login_count as loginCount,
      t.status
    FROM global_user_tenant_relations utr
    JOIN tenants t ON utr.tenant_code = t.tenant_id
    WHERE utr.global_user_id = ?
      AND t.status = 'active'
      AND t.deleted_at IS NULL
    ORDER BY utr.last_login_at DESC
  `, [user.id]);
  
  return {
    success: true,
    data: {
      phone: user.phone,
      globalUserId: user.id,
      tenants
    }
  };
}
```

4. **bindUserToTenant(globalUserId, tenantCode, role)** - 绑定用户到租户
```typescript
async bindUserToTenant(request: BindTenantRequest): Promise<BindTenantResponse> {
  // 1. 生成租户内用户ID
  const tenantUserId = uuidv4();
  
  // 2. 插入关联记录
  await sequelize.query(`
    INSERT INTO global_user_tenant_relations (
      global_user_id, tenant_code, tenant_user_id,
      role_in_tenant, permissions, first_login_at, created_at
    ) VALUES (?, ?, ?, ?, ?, NOW(), NOW())
  `, [globalUserId, tenantCode, tenantUserId, role, JSON.stringify(permissions)]);
  
  return {
    success: true,
    data: { tenantUserId, globalUserId, tenantCode, role }
  };
}
```

### 3.3 租户系统认证集成

**位置**: `k.yyup.com/server/src/middleware/auth.ts`

```typescript
export const verifyToken = async (req, res, next) => {
  try {
    // 1. 提取Token
    const token = req.headers.authorization?.replace('Bearer ', '');
    if (!token) {
      return res.status(401).json({ success: false, message: '未提供认证令牌' });
    }
    
    // 2. 验证Token
    const decoded = jwt.verify(token, JWT_SECRET);
    const globalUserId = decoded.sub;
    
    // 3. 获取租户代码
    const tenantCode = req.headers['x-tenant-code'] || process.env.DEFAULT_TENANT_CODE;
    
    // 4. 切换到租户数据库
    await databaseSwitchService.switchToTenant(tenantCode);
    
    // 5. 查询用户在租户内的信息
    const [users] = await sequelize.query(`
      SELECT u.*, ur.role_id
      FROM users u
      LEFT JOIN user_roles ur ON u.id = ur.user_id
      WHERE u.global_user_id = ?
        AND u.status = 'active'
      LIMIT 1
    `, [globalUserId]);
    
    if (!users || users.length === 0) {
      return res.status(401).json({ success: false, message: '用户未绑定到此租户' });
    }
    
    // 6. 加载权限
    req.user = users[0];
    req.tenantCode = tenantCode;
    
    next();
  } catch (error) {
    return res.status(401).json({ success: false, message: 'Token无效或已过期' });
  }
};
```

## 四、AI服务架构

### 4.1 AIBridge统一服务

**架构设计**:

```
┌──────────────────────────────────────────────────┐
│      Tenant Instance 1 (k001.yyup.cc)            │
│                                                  │
│   AI功能: 文案生成、智能推荐、数据分析           │
└────────────┬─────────────────────────────────────┘
             │
┌────────────┴─────────────────────────────────────┐
│      Tenant Instance 2 (k002.yyup.cc)            │
│                                                  │
│   AI功能: 对话助手、图片生成、语音识别           │
└────────────┬─────────────────────────────────────┘
             │
             │  所有租户统一调用
             ↓
┌──────────────────────────────────────────────────┐
│    Unified Tenant System - AIBridge              │
│         (rent.yyup.cc:4001)                      │
│                                                  │
│  Routes: /api/v1/ai/bridge/*                     │
│  - /chat          - AI对话                       │
│  - /embedding     - 文本嵌入                     │
│  - /completion    - 文本补全                     │
│  - /models        - 模型列表                     │
│                                                  │
│  Services:                                       │
│  - 模型管理 (ai_model_config)                    │
│  - Token计费 (tenant_ai_usage_summary)           │
│  - 调用日志 (ai_service_call_logs)               │
│  - 配额管理                                      │
└────────────┬─────────────────────────────────────┘
             │
             │  统一调用
             ↓
┌──────────────────────────────────────────────────┐
│         AI Provider Services                     │
│                                                  │
│  - OpenAI (GPT-3.5, GPT-4)                       │
│  - Anthropic (Claude)                            │
│  - Doubao (豆包 Seed-1.6)                        │
│  - 其他AI服务商                                  │
└──────────────────────────────────────────────────┘
```

### 4.2 AIBridge路由实现

**位置**: `unified-tenant-system/server/src/routes/ai/tenant-ai-bridge.routes.ts`

```typescript
import { Router } from 'express';
import { TenantAIBridgeController } from '../../controllers/ai/tenant-ai-bridge.controller';
import { verifyTenantToken } from '../../middlewares/tenant-auth.middleware';
import { rateLimit } from '../../middlewares/rate-limit.middleware';

const router = Router();
const controller = new TenantAIBridgeController();

// 所有AI Bridge路由都需要租户认证
router.use(verifyTenantToken);

// 应用频率限制 (每分钟100次)
router.use(rateLimit({
  windowMs: 1 * 60 * 1000,
  max: 100,
  message: 'AI调用频率过高，请稍后再试',
}));

/**
 * AI对话
 * POST /api/v1/ai/bridge/chat
 */
router.post('/chat', controller.chat);

/**
 * 文本嵌入
 * POST /api/v1/ai/bridge/embedding
 */
router.post('/embedding', controller.embedding);

/**
 * 模型列表
 * GET /api/v1/ai/bridge/models
 */
router.get('/models', controller.listModels);

export default router;
```

### 4.3 AI调用流程

```
租户系统调用AI:
1. 用户触发AI功能
2. 前端发送请求到租户后端
3. 租户后端调用 AIBridge API
4. AIBridge验证租户Token
5. AIBridge选择合适的AI模型
6. 调用AI提供商API
7. 记录调用日志
8. 计算Token使用量和成本
9. 返回AI响应
10. 租户后端返回给前端
```

**调用示例**:

```typescript
// 租户系统调用AIBridge
const response = await axios.post(
  'http://rent.yyup.cc:4001/api/v1/ai/bridge/chat',
  {
    model: 'gpt-3.5-turbo',
    messages: [
      { role: 'user', content: '你好，请介绍一下幼儿园管理系统' }
    ],
    temperature: 0.7,
    max_tokens: 2000
  },
  {
    headers: {
      'Authorization': `Bearer ${tenantToken}`,
      'X-Tenant-Code': 'k001'
    }
  }
);

// AIBridge返回
{
  success: true,
  data: {
    message: '您好！我是幼儿园管理系统AI助手...',
    usage: {
      inputTokens: 15,
      outputTokens: 120,
      totalTokens: 135,
      cost: 0.000203,
      responseTime: 1250
    }
  }
}
```

### 4.4 AI使用统计

AIBridge自动统计所有租户的AI使用情况：

```sql
-- 查询某租户的AI使用汇总
SELECT 
  date,
  model_id,
  total_calls,
  total_input_tokens,
  total_output_tokens,
  total_cost,
  average_response_time,
  success_rate
FROM tenant_ai_usage_summary
WHERE tenant_id = (SELECT id FROM tenants WHERE tenant_id = 'k001')
  AND date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)
ORDER BY date DESC;
```

## 五、租户开通流程

### 5.1 完整流程

**API**: `POST /api/tenant/create`

**请求体**:
```json
{
  "tenantCode": "k003",
  "name": "示例幼儿园",
  "contactName": "张三",
  "contactEmail": "zhangsan@example.com",
  "contactPhone": "13800138000",
  "smsVerificationCode": "123456",
  "subdomain": "k003",
  "address": "北京市朝阳区xxx街道",
  "description": "一所优质的幼儿园"
}
```

**处理步骤**:

```
1. 参数验证
   ├─ 租户代码格式: /^k\d{3,}$/
   ├─ 手机号格式: /^1[3-9]\d{9}$/
   └─ 邮箱格式验证

2. 短信验证
   └─ 验证 contactPhone + smsVerificationCode

3. 唯一性检查
   ├─ 检查 tenant_id 是否已存在
   └─ 检查 domain 是否已被使用

4. 生成密码配置
   ├─ 生成强密码
   ├─ 加密存储
   └─ 生成连接字符串

5. 创建子域名
   ├─ 域名: k003.yyup.cc
   ├─ DNS A记录指向服务器IP
   └─ 记录域名配置

6. 创建租户数据库
   ├─ 数据库名: rent003
   ├─ 从 kargerdensales 复制结构
   ├─ 复制初始数据
   └─ 创建数据库用户权限

7. 分配OSS目录
   ├─ 目录: /13800138000/
   ├─ 创建子目录结构
   └─ 设置访问权限

8. 创建租户记录
   └─ INSERT INTO tenants

9. 初始化数据库
   ├─ 运行初始化脚本
   ├─ 创建系统配置
   └─ 创建默认数据

10. 创建管理员账户
    ├─ global_users 表添加记录
    ├─ tenant.users 表添加记录
    └─ global_user_tenant_relations 关联

11. 配置AI模型
    └─ 从 ai_model_config 复制默认配置

12. 返回租户信息
    └─ 域名、数据库、密码等
```

### 5.2 租户资源分配

#### 子域名分配
```
格式: {tenant_id}.yyup.cc
示例:
- k001.yyup.cc
- k002.yyup.cc
- k003.yyup.cc

DNS配置:
- 类型: A记录
- 值: 服务器IP地址
- TTL: 600秒
```

#### 数据库分配
```
数据库名规则:
- 租户代码 k001 → 数据库 rent001
- 租户代码 k002 → 数据库 rent002

创建步骤:
1. CREATE DATABASE rent001;
2. GRANT ALL ON rent001.* TO 'db_user'@'%';
3. 从 kargerdensales 导出结构
4. 导入到 rent001
5. 初始化默认数据
```

#### OSS目录分配

**设计原则**: 基于手机号的多租户文件隔离

```
目录结构:
/{phone}/                 # 以联系人手机号为根目录
  ├─ uploads/             # 用户上传文件
  │   ├─ images/          # 图片
  │   ├─ videos/          # 视频
  │   └─ files/           # 其他文件
  ├─ generated/           # AI生成内容
  │   ├─ posters/         # AI生成海报
  │   └─ documents/       # AI生成文档
  ├─ posters/             # 海报素材
  │   ├─ templates/       # 海报模板
  │   └─ user_created/    # 用户创建
  ├─ documents/           # 文档资料
  │   ├─ enrollment/      # 招生资料
  │   └─ activities/      # 活动资料
  └─ temp/                # 临时文件（自动清理）

示例:
- 租户k001 (联系人: 13800138000) → OSS目录: /13800138000/
- 租户k002 (联系人: 15900159000) → OSS目录: /15900159000/
- 租户k003 (联系人: 13900139000) → OSS目录: /13900139000/
```

**为什么使用手机号作为OSS目录名？**

1. **唯一性保证**
   - 手机号全局唯一，不会发生冲突
   - 与global_users表的phone字段一一对应

2. **数据关联**
   - 通过手机号快速定位用户的OSS目录
   - 用户更换租户代码时，OSS目录不变

3. **权限隔离**
   - 每个租户只能访问自己手机号对应的目录
   - 通过STS临时授权实现细粒度权限控制

**OSS权限配置**:

```json
{
  "Version": "1",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "oss:PutObject",
        "oss:GetObject",
        "oss:DeleteObject",
        "oss:ListObjects"
      ],
      "Resource": [
        "acs:oss:*:*:tenant-storage/{phone}/*"
      ],
      "Condition": {
        "StringEquals": {
          "oss:Prefix": "{phone}/"
        }
      }
    }
  ]
}
```

**访问控制流程**:

```
1. 用户登录 → 获取 global_user_id 和 phone
2. 请求OSS访问 → 后端验证用户身份
3. 生成STS临时凭证 → 限定访问范围为 /{phone}/*
4. 返回临时凭证给前端
5. 前端使用临时凭证直接访问OSS
6. OSS SDK验证凭证权限
```

**自动清理机制**:
- 临时文件（/temp/）超过7天自动删除
- 已删除租户的OSS目录标记为待删除
- 30天后永久删除已标记目录

### 5.4 租户删除流程（完整资源清理）

**API**: `DELETE /api/tenant/:tenantCode`

**删除策略**: 软删除 + 延迟物理删除（30天保留期）

```
╔════════════════════════════════════╗
║  租户删除流程（分阶段清理）        ║
╚════════════════════════════════════╝

阶段1：立即执行（软删除）
─────────────────────────
1. 删除子域名DNS记录
   └─ DELETE A记录: k003.yyup.cc → IP

2. 软删除租户记录
   └─ UPDATE tenants SET status='deleted', deleted_at=NOW()

阶段2：标记资源待删除（30天后）
─────────────────────────────────
3. 标记租户数据库
   ├─ INSERT INTO tenant_resource_cleanup
   ├─ resource_type: 'database'
   ├─ resource_name: 'rent003'
   └─ scheduled_deletion_at: NOW() + 30天

4. 标记上海OSS相册目录
   ├─ bucket: faceshanghaikarden
   ├─ region: oss-cn-shanghai
   ├─ paths:
   │   ├─ kindergarten/rent/13800138000/photos/
   │   ├─ kindergarten/rent/13800138000/students/
   │   └─ kindergarten/rent/13800138000/albums/
   └─ scheduled_deletion_at: NOW() + 30天

5. 标记广州OSS系统文件
   ├─ bucket: systemkarder
   ├─ region: oss-cn-guangzhou
   ├─ path: kindergarten/rent/13800138000/
   └─ scheduled_deletion_at: NOW() + 30天

阶段3：定时清理（30天后自动执行）
──────────────────────────────────
6. 执行物理删除
   ├─ 删除租户数据库: DROP DATABASE rent003
   ├─ 删除上海OSS目录及所有文件
   ├─ 删除广州OSS目录及所有文件
   └─ 更新清理记录状态为completed
```

**资源清理表结构**:

```sql
CREATE TABLE tenant_resource_cleanup (
  id INT AUTO_INCREMENT PRIMARY KEY,
  tenant_code VARCHAR(50) NOT NULL,
  resource_type ENUM('database', 'oss', 'subdomain', 'other'),
  resource_name VARCHAR(255),
  
  -- OSS相关
  oss_bucket VARCHAR(100),
  oss_region VARCHAR(50),
  oss_path VARCHAR(500),
  
  -- 删除计划
  scheduled_deletion_at DATETIME NOT NULL,
  deletion_started_at DATETIME,
  deletion_completed_at DATETIME,
  
  -- 状态
  status ENUM('pending', 'in_progress', 'completed', 'failed'),
  error_message TEXT,
  retry_count INT DEFAULT 0,
  
  created_at DATETIME,
  updated_at DATETIME
);
```

**删除示例**:

```typescript
// 删除租户k003
await tenantService.deleteTenant('k003');

// 立即效果：
// ✅ DNS记录删除
// ✅ 租户状态变为deleted

// 30天后自动清理：
// ✅ 数据库 rent003 被删除
// ✅ 上海OSS /13800138000/photos/ 目录删除
// ✅ 上海OSS /13800138000/students/ 目录删除
// ✅ 上海OSS /13800138000/albums/ 目录删除
// ✅ 广州OSS /13800138000/ 目录删除
```

**定时清理任务**:

```sql
-- MySQL事件调度器（每天凌晨3点执行）
CREATE EVENT cleanup_tenant_resources
ON SCHEDULE EVERY 1 DAY
STARTS '2025-01-01 03:00:00'
DO
  CALL CleanupTenantResources();
```

**手动查询待删除资源**:

```sql
-- 查看即将删除的资源（7天内）
SELECT 
  tenant_code,
  resource_type,
  resource_name,
  oss_bucket,
  oss_path,
  scheduled_deletion_at,
  DATEDIFF(scheduled_deletion_at, NOW()) as days_until_deletion
FROM tenant_resource_cleanup
WHERE scheduled_deletion_at <= DATE_ADD(NOW(), INTERVAL 7 DAY)
  AND status = 'pending'
ORDER BY scheduled_deletion_at ASC;
```

**安全保障**:

1. **30天缓冲期** - 误删除可恢复
2. **分步执行** - 降低风险
3. **详细日志** - 可追溯
4. **重试机制** - 失败自动重试（最多3次）
5. **手动干预** - 支持取消删除计划

**取消删除示例**:

```sql
-- 取消租户k003的所有删除计划
DELETE FROM tenant_resource_cleanup
WHERE tenant_code = 'k003' AND status = 'pending';

-- 恢复租户状态
UPDATE tenants 
SET status = 'active', deleted_at = NULL 
WHERE tenant_code = 'k003';
```

**位置**: `unified-tenant-system/server/src/services/tenant-init-monitor.service.ts`

记录租户初始化的每个步骤：

```sql
INSERT INTO tenant_init_progress (
  tenant_id, current_step, total_steps,
  status, error_message
) VALUES (?, ?, ?, ?, ?);

INSERT INTO tenant_init_steps (
  tenant_id, step_name, step_order,
  status, started_at, completed_at, error_message
) VALUES (?, ?, ?, ?, NOW(), ?, ?);
```

初始化步骤包括:
1. 验证参数
2. 创建域名
3. 创建数据库
4. 初始化数据库结构
5. 创建管理员账户
6. 配置AI模型
7. 创建OSS目录
8. 完成初始化

## 六、系统对接规范

### 6.1 租户系统访问统一认证

**场景**: 租户系统需要验证用户身份

```typescript
// 租户系统调用统一认证
import axios from 'axios';

const UNIFIED_AUTH_URL = process.env.UNIFIED_TENANT_API_URL || 'http://localhost:4001';

// 用户登录
async function login(phone: string, password: string) {
  const response = await axios.post(`${UNIFIED_AUTH_URL}/api/auth/login`, {
    phone,
    password
  });
  
  if (response.data.success) {
    const { globalUserId, token, tenants } = response.data.data;
    
    // 保存Token
    localStorage.setItem('auth_token', token);
    localStorage.setItem('global_user_id', globalUserId);
    
    // 如果用户有多个租户，让用户选择
    if (tenants.length > 1) {
      showTenantSelector(tenants);
    } else {
      // 自动选择唯一租户
      selectTenant(tenants[0].tenantCode);
    }
  }
}

// 选择租户
async function selectTenant(tenantCode: string) {
  // 保存当前租户
  localStorage.setItem('current_tenant', tenantCode);
  
  // 切换到租户数据库
  await axios.post(`/api/tenant/switch`, { tenantCode }, {
    headers: { 'Authorization': `Bearer ${localStorage.getItem('auth_token')}` }
  });
  
  // 跳转到租户首页
  window.location.href = '/dashboard';
}
```

### 6.2 租户系统调用AIBridge

**场景**: 租户系统需要使用AI功能

```typescript
// AI调用封装
class AIBridgeClient {
  private baseUrl: string;
  private tenantCode: string;
  private token: string;
  
  constructor() {
    this.baseUrl = process.env.AI_BRIDGE_URL || 'http://localhost:4001/api/v1/ai/bridge';
    this.tenantCode = localStorage.getItem('current_tenant');
    this.token = localStorage.getItem('auth_token');
  }
  
  async chat(messages: Array<{role: string, content: string}>, options = {}) {
    const response = await axios.post(`${this.baseUrl}/chat`, {
      model: options.model || 'gpt-3.5-turbo',
      messages,
      temperature: options.temperature || 0.7,
      max_tokens: options.maxTokens || 2000
    }, {
      headers: {
        'Authorization': `Bearer ${this.token}`,
        'X-Tenant-Code': this.tenantCode
      }
    });
    
    return response.data;
  }
  
  async generateEmbedding(text: string) {
    const response = await axios.post(`${this.baseUrl}/embedding`, {
      input: text
    }, {
      headers: {
        'Authorization': `Bearer ${this.token}`,
        'X-Tenant-Code': this.tenantCode
      }
    });
    
    return response.data;
  }
  
  async listModels() {
    const response = await axios.get(`${this.baseUrl}/models`, {
      headers: {
        'Authorization': `Bearer ${this.token}`,
        'X-Tenant-Code': this.tenantCode
      }
    });
    
    return response.data;
  }
}

// 使用示例
const aiClient = new AIBridgeClient();

// AI对话
const chatResponse = await aiClient.chat([
  { role: 'user', content: '帮我生成一份招生简章' }
]);

// 获取可用模型
const models = await aiClient.listModels();
```

### 6.3 租户系统访问OSS存储

**场景**: 租户系统需要上传/下载文件

```typescript
// OSS访问封装
class OSSClient {
  private stsCredentials: any = null;
  private ossClient: any = null;
  private phone: string;
  
  constructor() {
    // 从用户信息中获取手机号
    const userInfo = JSON.parse(localStorage.getItem('user_info') || '{}');
    this.phone = userInfo.phone;
  }
  
  /**
   * 获取STS临时凭证
   * 后端限定访问范围为 /{phone}/*
   */
  async getStsCredentials() {
    const response = await axios.post(
      `${UNIFIED_TENANT_API_URL}/api/v1/oss/sts-token`,
      {},
      {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        }
      }
    );
    
    if (response.data.success) {
      this.stsCredentials = response.data.data;
      
      // 初始化OSS客户端（使用STS凭证）
      this.ossClient = new OSS({
        region: 'oss-cn-hangzhou',
        accessKeyId: this.stsCredentials.accessKeyId,
        accessKeySecret: this.stsCredentials.accessKeySecret,
        stsToken: this.stsCredentials.securityToken,
        bucket: 'tenant-storage'
      });
    }
  }
  
  /**
   * 上传文件
   * 自动前缀 /{phone}/ 路径
   */
  async uploadFile(file: File, folder: string = 'uploads') {
    if (!this.ossClient) {
      await this.getStsCredentials();
    }
    
    const fileName = `${Date.now()}-${file.name}`;
    const objectName = `${this.phone}/${folder}/${fileName}`;
    
    try {
      const result = await this.ossClient.put(objectName, file);
      return {
        success: true,
        url: result.url,
        objectName: objectName
      };
    } catch (error) {
      console.error('OSS上传失败:', error);
      return {
        success: false,
        message: '文件上传失败'
      };
    }
  }
  
  /**
   * 获取文件签名URL（用于下载）
   */
  async getSignedUrl(objectName: string, expires: number = 3600) {
    if (!this.ossClient) {
      await this.getStsCredentials();
    }
    
    // 验证访问权限：只能访问自己的目录
    if (!objectName.startsWith(`${this.phone}/`)) {
      throw new Error('无权访问该文件');
    }
    
    try {
      const url = this.ossClient.signatureUrl(objectName, {
        expires: expires
      });
      return url;
    } catch (error) {
      console.error('获取签名URL失败:', error);
      throw error;
    }
  }
  
  /**
   * 列出目录下的文件
   */
  async listFiles(folder: string = '') {
    if (!this.ossClient) {
      await this.getStsCredentials();
    }
    
    const prefix = folder ? `${this.phone}/${folder}/` : `${this.phone}/`;
    
    try {
      const result = await this.ossClient.list({
        prefix: prefix,
        'max-keys': 100
      });
      
      return {
        success: true,
        files: result.objects || []
      };
    } catch (error) {
      console.error('OSS列表失败:', error);
      return {
        success: false,
        files: []
      };
    }
  }
  
  /**
   * 删除文件
   */
  async deleteFile(objectName: string) {
    if (!this.ossClient) {
      await this.getStsCredentials();
    }
    
    // 验证访问权限
    if (!objectName.startsWith(`${this.phone}/`)) {
      throw new Error('无权删除该文件');
    }
    
    try {
      await this.ossClient.delete(objectName);
      return {
        success: true,
        message: '文件删除成功'
      };
    } catch (error) {
      console.error('OSS删除失败:', error);
      return {
        success: false,
        message: '文件删除失败'
      };
    }
  }
}

// 使用示例
const ossClient = new OSSClient();

// 上传图片
const uploadResult = await ossClient.uploadFile(imageFile, 'uploads/images');
console.log('上传结果:', uploadResult);

// 获取文件列表
const files = await ossClient.listFiles('uploads');
console.log('文件列表:', files);

// 获取下载链接
const downloadUrl = await ossClient.getSignedUrl('13800138000/uploads/poster.png');
console.log('下载URL:', downloadUrl);
```

**后端STS凭证生成示例** (`unified-tenant-system`):

```typescript
// POST /api/v1/oss/sts-token
export const getStsToken = async (req: Request, res: Response) => {
  try {
    const user = req.user; // 从认证中间件获取
    const phone = user.phone;
    
    // 使用阿里云STS SDK生成临时凭证
    const sts = new STS({
      accessKeyId: process.env.OSS_ACCESS_KEY_ID,
      accessKeySecret: process.env.OSS_ACCESS_KEY_SECRET
    });
    
    // 设置权限策略：只允许访问 /{phone}/* 目录
    const policy = {
      "Version": "1",
      "Statement": [
        {
          "Effect": "Allow",
          "Action": [
            "oss:PutObject",
            "oss:GetObject",
            "oss:DeleteObject",
            "oss:ListObjects"
          ],
          "Resource": [
            `acs:oss:*:*:tenant-storage/${phone}/*`
          ]
        }
      ]
    };
    
    const result = await sts.assumeRole(
      process.env.OSS_ROLE_ARN,
      JSON.stringify(policy),
      3600, // 1小时过期
      `tenant-${phone}`
    );
    
    ApiResponse.success(res, {
      accessKeyId: result.credentials.AccessKeyId,
      accessKeySecret: result.credentials.AccessKeySecret,
      securityToken: result.credentials.SecurityToken,
      expiration: result.credentials.Expiration,
      phone: phone,
      allowedPath: `${phone}/*`
    }, 'STS凭证获取成功');
    
  } catch (error) {
    console.error('STS凭证生成失败:', error);
    ApiResponse.error(res, 'STS凭证获取失败');
  }
};
```

## 七、部署配置

### 7.1 环境变量配置

**unified-tenant-system/server/.env**:
```env
# 数据库配置 - 关键配置
DB_HOST=dbconn.sealoshzh.site
DB_PORT=43906
DB_USER=root
DB_PASSWORD=pwk5ls7j
DB_NAME=admin_tenant_management  # ⚠️ 必须是这个

# 服务器配置
NODE_ENV=production
PORT=4001
SERVER_URL=http://rent.yyup.cc

# JWT配置
UNIFIED_AUTH_SECRET=your-secret-key-here
UNIFIED_AUTH_TOKEN_EXPIRES=24h
UNIFIED_AUTH_REFRESH_EXPIRES=7d

# AI服务配置
OPENAI_API_KEY=sk-xxx
DOUBAO_API_KEY=your-doubao-key
AI_BRIDGE_ENABLED=true

# 短信服务配置
SMS_PROVIDER=aliyun
SMS_ACCESS_KEY=your-access-key
SMS_ACCESS_SECRET=your-secret

# OSS配置
OSS_ENDPOINT=oss-cn-hangzhou.aliyuncs.com
OSS_ACCESS_KEY_ID=your-key
OSS_ACCESS_KEY_SECRET=your-secret
OSS_BUCKET=tenant-storage

# DNS服务配置 (阿里云DNS)
ALIYUN_DNS_ACCESS_KEY=your-key
ALIYUN_DNS_SECRET=your-secret
DNS_DOMAIN=yyup.cc
```

**k.yyup.com/server/.env**:
```env
# 数据库配置
DB_HOST=dbconn.sealoshzh.site
DB_PORT=43906
DB_USER=root
DB_PASSWORD=pwk5ls7j
DB_NAME=kargerdensales  # 测试站点用模板库

# 服务器配置
NODE_ENV=production
PORT=3000
SERVER_URL=http://k.yyup.cc

# 统一租户中心配置 - 关键配置
UNIFIED_TENANT_CENTER_URL=http://rent.yyup.cc
UNIFIED_TENANT_API_URL=http://localhost:4001
UNIFIED_TENANT_API_KEY=your-api-key

# 当前租户配置 (仅开发环境)
DEFAULT_TENANT_CODE=k_test

# JWT配置
JWT_SECRET=your-jwt-secret

# AI配置 - 通过AIBridge
AI_BRIDGE_URL=http://localhost:4001/api/v1/ai/bridge
AI_BRIDGE_ENABLED=true
```

### 7.2 Nginx配置

```nginx
# 统一租户管理系统
server {
    listen 80;
    server_name rent.yyup.cc;
    
    location / {
        proxy_pass http://localhost:4001;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}

# 幼儿园租户系统 - 测试站点
server {
    listen 80;
    server_name k.yyup.cc;
    
    location / {
        proxy_pass http://localhost:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}

# 租户子域名 - 通配符配置
server {
    listen 80;
    server_name *.yyup.cc;
    
    location / {
        # 从子域名提取租户代码
        set $tenant_code "";
        if ($host ~ ^([^.]+)\.yyup\.cc$) {
            set $tenant_code $1;
        }
        
        proxy_pass http://localhost:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Tenant-Code $tenant_code;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

### 7.3 PM2配置

**ecosystem.config.js**:
```javascript
module.exports = {
  apps: [
    {
      name: 'unified-tenant-system',
      cwd: '/home/zhgue/kyyupgame/unified-tenant-system/server',
      script: 'dist/server.js',
      instances: 2,
      exec_mode: 'cluster',
      env: {
        NODE_ENV: 'production',
        PORT: 4001
      }
    },
    {
      name: 'kindergarten-tenant',
      cwd: '/home/zhgue/kyyupgame/k.yyup.com/server',
      script: 'dist/server.js',
      instances: 4,
      exec_mode: 'cluster',
      env: {
        NODE_ENV: 'production',
        PORT: 3000
      }
    }
  ]
};
```

## 八、常见问题

### Q1: 用户登录应该使用哪个API？
**A**: 统一使用 `unified-tenant-system` 的认证API:
```
POST http://rent.yyup.cc:4001/api/auth/login
Body: { phone: "13800138000", password: "xxx" }
```

### Q2: 如何区分系统管理员和租户用户？
**A**: 
- **系统管理员**: `admin_users` 表，username登录，管理整个系统
- **租户用户**: `global_users` 表，phone登录，使用租户功能

### Q3: 租户系统如何调用AI功能？
**A**: 通过AIBridge统一调用:
```
POST http://rent.yyup.cc:4001/api/v1/ai/bridge/chat
Headers: 
  - Authorization: Bearer {token}
  - X-Tenant-Code: k001
```

### Q4: 如何查看租户的AI使用情况？
**A**: 查询 `tenant_ai_usage_summary` 表:
```sql
SELECT * FROM tenant_ai_usage_summary
WHERE tenant_id = (SELECT id FROM tenants WHERE tenant_id = 'k001')
ORDER BY date DESC;
```

### Q5: kargerdensales数据库的作用是什么？
**A**: 三重作用:
1. k.yyup.cc测试站点的数据库
2. 新租户创建时的模板数据库
3. 租户数据库Schema的参考标准

### Q6: 如何为租户分配新的子域名？
**A**: 租户创建时自动分配，格式为 `{tenant_id}.yyup.cc`

### Q7: 租户数据如何隔离？
**A**: 
- 数据库隔离: 每个租户独立数据库
- 存储隔离: 每个租户独立OSS目录
- 权限隔离: 基于 `global_user_tenant_relations` 的访问控制

### Q8: 如何切换租户数据库？
**A**: 使用 `database-switch.service.ts`:
```typescript
await databaseSwitchService.switchToTenant(tenantCode);
```

## 九、维护指南

### 9.1 数据库备份

```bash
# 备份统一租户管理数据库
mysqldump -h dbconn.sealoshzh.site -P 43906 -u root -p \
  admin_tenant_management > admin_tenant_management_$(date +%Y%m%d).sql

# 备份模板数据库
mysqldump -h dbconn.sealoshzh.site -P 43906 -u root -p \
  kargerdensales > kargerdensales_$(date +%Y%m%d).sql

# 备份所有租户数据库
for db in rent001 rent002 rent003; do
  mysqldump -h dbconn.sealoshzh.site -P 43906 -u root -p \
    $db > ${db}_$(date +%Y%m%d).sql
done
```

### 9.2 日志查看

```bash
# 统一租户系统日志
pm2 logs unified-tenant-system

# 租户实例系统日志
pm2 logs kindergarten-tenant

# 数据库慢查询日志
mysql -h dbconn.sealoshzh.site -P 43906 -u root -p \
  -e "SELECT * FROM mysql.slow_log ORDER BY start_time DESC LIMIT 10;"
```

### 9.3 性能监控

```bash
# 查看AI调用统计
mysql -h dbconn.sealoshzh.site -P 43906 -u root -p admin_tenant_management \
  -e "SELECT 
    date,
    SUM(total_calls) as total_calls,
    SUM(total_cost) as total_cost,
    AVG(average_response_time) as avg_response_time
  FROM tenant_ai_usage_summary
  WHERE date >= DATE_SUB(CURDATE(), INTERVAL 7 DAY)
  GROUP BY date
  ORDER BY date DESC;"

# 查看租户活跃度
mysql -h dbconn.sealoshzh.site -P 43906 -u root -p admin_tenant_management \
  -e "SELECT 
    t.tenant_id,
    t.name,
    COUNT(DISTINCT utr.global_user_id) as user_count,
    SUM(utr.login_count) as total_logins
  FROM tenants t
  LEFT JOIN global_user_tenant_relations utr ON t.tenant_id = utr.tenant_code
  WHERE t.status = 'active'
  GROUP BY t.id
  ORDER BY total_logins DESC;"
```

## 十、开发建议

1. **认证相关开发**: 优先使用 `global_users` 表，phone作为登录凭证
2. **数据库查询**: 明确区分系统管理查询和租户业务查询
3. **AI功能开发**: 统一通过AIBridge调用，便于监控和计费
4. **新功能测试**: 先在k.yyup.cc测试，再推广到各租户
5. **数据库变更**: 先更新kargerdensales模板库，再同步到各租户库

---

**文档版本**: 1.0
**最后更新**: 2025-11-28
**维护人**: 系统架构组
